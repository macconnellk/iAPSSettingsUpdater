
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iAPS Parameter Optimizer - v24 Multi-Detector System (with Detector 1b)</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState } = React;
        
        // Icons
        const Activity = () => (
            <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
        );
        
        const Server = () => (
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 12h14M5 12a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v4a2 2 0 01-2 2M5 12a2 2 0 00-2 2v4a2 2 0 002 2h14a2 2 0 002-2v-4a2 2 0 00-2-2m-2-4h.01M17 16h.01" />
            </svg>
        );

        const ConfidenceBadge = ({ level, score }) => {
            const colors = {
                High: 'bg-green-100 text-green-800 border-green-300',
                Medium: 'bg-yellow-100 text-yellow-800 border-yellow-300',
                Low: 'bg-orange-100 text-orange-800 border-orange-300'
            };
            
            return (
                <span className={`px-3 py-1 rounded-full text-sm font-semibold border ${colors[level] || 'bg-gray-100'}`}>
                    {level} ({score}%)
                </span>
            );
        };

        const IAPSOptimizer = () => {
            const [nightscoutData, setNightscoutData] = useState(null);
            const [analysisResults, setAnalysisResults] = useState(null);
            const [analyzing, setAnalyzing] = useState(false);
            const [error, setError] = useState(null);
            const [loading, setLoading] = useState(false);
            const [fetchStatus, setFetchStatus] = useState('');
            const [analysisWindow, setAnalysisWindow] = useState(1);
            
            const [nsConfig, setNsConfig] = useState(() => {
                try {
                    const saved = localStorage.getItem('nightscoutConfig');
                    if (saved) return JSON.parse(saved);
                } catch (e) {}
                return { 
                    baseUrl: 'https://bmac.us.nightscoutpro.com', 
                    apiSecret: 'uFhaZjS2jLaz', 
                    token: 'cockpit-cdbc465a76b45661' 
                };
            });

            const updateNsConfig = (newConfig) => {
                setNsConfig(newConfig);
                try {
                    localStorage.setItem('nightscoutConfig', JSON.stringify(newConfig));
                } catch (e) {}
            };

            // ===== SECTION 1: HELPER FUNCTIONS (Keep from v23) =====
            
            // Find which CR schedule entry applies to a given time
            const getCRForTime = (timeStr, crSchedule) => {
                const dt = new Date(timeStr);
                const hours = dt.getHours();
                const minutes = dt.getMinutes();
                const timeInMinutes = hours * 60 + minutes;
                
                // Convert schedule to minutes
                const scheduleInMinutes = crSchedule.map(entry => {
                    const [h, m] = entry.time.split(':').map(Number);
                    return { minutes: h * 60 + m, value: entry.value, time: entry.time };
                }).sort((a, b) => a.minutes - b.minutes);
                
                // Find the applicable schedule entry
                let applicable = scheduleInMinutes[0];
                for (let entry of scheduleInMinutes) {
                    if (timeInMinutes >= entry.minutes) {
                        applicable = entry;
                    } else {
                        break;
                    }
                }
                
                return applicable;
            };

            // Find which ISF schedule entry applies to a given time
            const getISFForTime = (timeStr, isfSchedule) => {
                const dt = new Date(timeStr);
                const hours = dt.getHours();
                const minutes = dt.getMinutes();
                const timeInMinutes = hours * 60 + minutes;
                
                // Convert schedule to minutes
                const scheduleInMinutes = isfSchedule.map(entry => {
                    const [h, m] = entry.time.split(':').map(Number);
                    return { minutes: h * 60 + m, value: entry.value, time: entry.time };
                }).sort((a, b) => a.minutes - b.minutes);
                
                // Find the applicable schedule entry
                let applicable = scheduleInMinutes[0];
                for (let entry of scheduleInMinutes) {
                    if (timeInMinutes >= entry.minutes) {
                        applicable = entry;
                    } else {
                        break;
                    }
                }
                
                return applicable;
            };

            // Find which basal rate applies to a given time
            const getBasalForTime = (timeStr, basalSchedule) => {
                const dt = new Date(timeStr);
                const hours = dt.getHours();
                const minutes = dt.getMinutes();
                const timeInMinutes = hours * 60 + minutes;
                
                // Convert schedule to minutes
                const scheduleInMinutes = basalSchedule.map(entry => {
                    const [h, m] = entry.time.split(':').map(Number);
                    return { minutes: h * 60 + m, value: entry.value, time: entry.time };
                }).sort((a, b) => a.minutes - b.minutes);
                
                // Find the applicable schedule entry
                let applicable = scheduleInMinutes[0];
                for (let entry of scheduleInMinutes) {
                    if (timeInMinutes >= entry.minutes) {
                        applicable = entry;
                    } else {
                        break;
                    }
                }
                
                return applicable;
            };

            const calculateRecencyWeight = (timestamp, analysisWindowDays) => {
                const now = new Date();
                const eventTime = new Date(timestamp);
                const ageHours = (now - eventTime) / (1000 * 60 * 60);
                const windowHours = analysisWindowDays * 24;
                
                const decayFactor = 0.3;
                const weight = Math.exp(-decayFactor * (ageHours / windowHours));
                
                return weight;
            };

            // Helper function to get IOB at a specific time
            const getIOBAtTime = (deviceStatus, targetTime) => {
                if (!deviceStatus || deviceStatus.length === 0) return null;
                
                const targetTimestamp = new Date(targetTime).getTime();
                let closestIOB = null;
                let minTimeDiff = Infinity;
                
                deviceStatus.forEach(status => {
                    if (status.created_at && status.iob && typeof status.iob === 'number') {
                        const statusTime = new Date(status.created_at).getTime();
                        const timeDiff = Math.abs(statusTime - targetTimestamp);
                        
                        // Within 10 minutes
                        if (timeDiff < 10 * 60 * 1000 && timeDiff < minTimeDiff) {
                            minTimeDiff = timeDiff;
                            closestIOB = status.iob;
                        }
                    }
                });
                
                return closestIOB;
            };

            // Helper function to check if an insulin treatment is a true correction
            // Keep from v23 - this works correctly
            const isTrueCorrection = (treatment, allTreatments) => {
                // If it has carbs, it's definitely not a correction-only entry
                if (treatment.carbs && treatment.carbs > 0) return false;
                
                // If no insulin, not relevant
                if (!treatment.insulin || treatment.insulin <= 0) return false;
                
                // SMBs require context checking (ENHANCED)
                if (treatment.eventType && treatment.eventType.includes('SMB')) {
                    const smbTime = new Date(treatment.created_at);
                    const oneHourAgo = new Date(smbTime - 1 * 60 * 60 * 1000);
                    
                    // Check for recent meals (within 1 hour)
                    const recentMeals = allTreatments.filter(t => {
                        if (!t.carbs || t.carbs <= 0) return false;
                        if (!t.created_at) return false;
                        const mealTime = new Date(t.created_at);
                        return mealTime >= oneHourAgo && mealTime <= smbTime;
                    });
                    
                    // If recent meal exists, SMB is likely meal coverage
                    if (recentMeals.length > 0) {
                        return false; // NOT a true correction
                    }
                    
                    // No recent meal = true correction
                    return true;
                }
                
                // For boluses, check if there's a carb entry within 2 minutes before/after
                const treatmentTime = new Date(treatment.created_at).getTime();
                const twoMinutes = 2 * 60 * 1000;
                
                const hasNearbyCarbs = allTreatments.some(t => {
                    if (!t.carbs || t.carbs <= 0) return false;
                    if (!t.created_at) return false;
                    
                    const carbTime = new Date(t.created_at).getTime();
                    const timeDiff = Math.abs(carbTime - treatmentTime);
                    
                    // If carb entry within 2 minutes, this insulin is part of a meal
                    return timeDiff <= twoMinutes;
                });
                
                // If nearby carbs found, this is a meal bolus, not a correction
                return !hasNearbyCarbs;
            };

            // ===== NEW HELPER FUNCTIONS FOR EVENT CLAIMING =====
            
            // Create unique identifiers for events
            const getEventId = (event) => {
                return event.localDateTime || event.dateString || event.created_at;
            };

            // ===== SECTION 2: THE 5 DETECTORS =====
            
            /**
             * HELPER: Detect Schedule Boundary Issues
             * Identifies meals that use the "wrong" CR due to schedule timing
             * and cause subsequent problems
             */
            const detectScheduleBoundaryIssues = (nightscoutData, crSchedule, lowProblems) => {
                console.log('\n=== Schedule Boundary Analysis ===');
                const issues = [];
                
                // For each meal, check if it's using a schedule that might be inappropriate
                nightscoutData.treatments.forEach(meal => {
                    if (!meal.created_at || !meal.carbs || meal.carbs <= 0) return;
                    
                    const mealTime = new Date(meal.created_at);
                    const crEntry = getCRForTime(meal.localDateTime, crSchedule);
                    
                    // Find the next schedule entry
                    const mealMinutes = mealTime.getHours() * 60 + mealTime.getMinutes();
                    const nextCREntry = crSchedule.find(entry => {
                        const [h, m] = entry.time.split(':').map(Number);
                        const entryMinutes = h * 60 + m;
                        return entryMinutes > mealMinutes;
                    });
                    
                    if (!nextCREntry || crEntry.time === nextCREntry.time) return;
                    
                    // Calculate time until next boundary
                    const [nextH, nextM] = nextCREntry.time.split(':').map(Number);
                    const nextMinutes = nextH * 60 + nextM;
                    const minutesUntilBoundary = nextMinutes - mealMinutes;
                    
                    // If within 2 hours of boundary
                    if (minutesUntilBoundary > 0 && minutesUntilBoundary < 120) {
                        // Check if current CR is significantly stronger (lower value = more insulin per carb)
                        const crDifference = ((nextCREntry.value - crEntry.value) / crEntry.value) * 100;
                        
                        if (crDifference > 20) { // Next CR is >20% weaker
                            console.log(`  Potential boundary issue: ${meal.localDateTime}`);
                            console.log(`    Using ${crEntry.time} CR (${crEntry.value}) but ${nextCREntry.time} CR (${nextCREntry.value}) is ${crDifference.toFixed(1)}% weaker`);
                            console.log(`    ${minutesUntilBoundary} min before boundary`);
                            
                            // Check if there was a low within 4 hours after this meal
                            const fourHoursAfter = new Date(mealTime.getTime() + 4 * 60 * 60 * 1000);
                            const hadSubsequentLow = lowProblems.some(low => {
                                const lowTime = new Date(low.time);
                                return lowTime > mealTime && lowTime <= fourHoursAfter;
                            });
                            
                            if (hadSubsequentLow) {
                                console.log(`    â†’ Subsequent low detected - boundary adjustment recommended`);
                                
                                issues.push({
                                    meal: meal,
                                    mealTime: meal.localDateTime,
                                    currentSchedule: crEntry.time,
                                    currentCR: crEntry.value,
                                    nextSchedule: nextCREntry.time,
                                    nextCR: nextCREntry.value,
                                    minutesBeforeBoundary: minutesUntilBoundary,
                                    crDifference: crDifference,
                                    hadSubsequentLow: true
                                });
                            }
                        }
                    }
                });
                
                // Generate recommendations for schedule boundary adjustments
                const recommendations = [];
                issues.forEach(issue => {
                    // Suggest moving the boundary earlier to cover the problematic meal
                    // Calculate suggested new boundary time (round to 30-min intervals)
                    const mealTime = new Date(issue.meal.created_at);
                    const suggestedHour = mealTime.getHours();
                    const suggestedMin = mealTime.getMinutes() < 30 ? 0 : 30;
                    const suggestedBoundary = `${suggestedHour.toString().padStart(2, '0')}:${suggestedMin.toString().padStart(2, '0')}`;
                    
                    recommendations.push({
                        detector: 'Schedule Boundary Optimization',
                        type: 'Schedule Boundary Adjustment',
                        reason: `Meal using strong breakfast CR (${issue.currentCR} g/U) caused subsequent low. Moving boundary earlier would use weaker lunch CR (${issue.nextCR} g/U).`,
                        scheduleTime: issue.nextSchedule,
                        currentValue: issue.nextCR,
                        newValue: issue.nextCR, // Value stays same, timing changes
                        adjustment: `Move boundary: ${issue.nextSchedule} â†’ ${suggestedBoundary}`,
                        calculation: `Meal at ${issue.mealTime} is ${issue.minutesBeforeBoundary} min before ${issue.nextSchedule} boundary. Used ${issue.currentCR} g/U (${issue.crDifference.toFixed(0)}% stronger) instead of ${issue.nextCR} g/U.`,
                        details: `Meal at ${issue.mealTime} (${issue.meal.carbs}g) used ${issue.currentSchedule} CR (${issue.currentCR} g/U) but occurred ${issue.minutesBeforeBoundary} minutes before ${issue.nextSchedule} boundary. This schedule is ${issue.crDifference.toFixed(0)}% stronger than the ${issue.nextSchedule} CR (${issue.nextCR} g/U), causing subsequent low. Recommend moving ${issue.nextSchedule} boundary to ${suggestedBoundary} to use appropriate CR for mid-morning/afternoon snacks.`,
                        confidence: { level: 'High', score: 85 },
                        priority: 'MEDIUM',
                        events: [issue.meal],
                        safetyNote: `Schedule boundary mismatch - meal using too-strong CR due to timing`,
                        suggestedBoundary: suggestedBoundary
                    });
                });
                
                console.log(`Schedule Boundary Analysis complete: ${recommendations.length} boundary adjustments recommended\n`);
                return recommendations;
            };
            
            /**
             * DETECTOR 1: Direct Meal-Induced Lows
             * Priority: 1.5 (Safety - Less Specific Pattern)
             * Pattern: Meal [WARNING]Ã‚Â¢ Low (1-4 hours later) with NO high >180 in between
             * Conclusion: CR too strong (too much upfront insulin)
             */
            const detectDirectMealInducedLows = (lowProblems, nightscoutData, crSchedule, claimedEvents, processedLowIds) => {
                console.log('=== DETECTOR 1: Direct Meal-Induced Lows ===');
                const recommendations = [];
                
                lowProblems.forEach(low => {
                    const lowId = getEventId(low);
                    console.log(`\nProcessing low at ${low.localTime} (${low.bg} mg/dL)`);
                    
                    const lowTime = new Date(low.time);  // Use UTC timestamp
                    const fourHoursAgo = new Date(lowTime - 4 * 60 * 60 * 1000);
                    const twentyMinutesAgo = new Date(lowTime - 20 * 60 * 1000);
                    
                    // Find meals in 20 minutes to 4 hours lookback window
                    const recentMeals = nightscoutData.treatments.filter(t => {
                        if (!t.created_at || !t.carbs || t.carbs <= 0) return false;
                        const tTime = new Date(t.created_at);  // Use UTC timestamp
                        return tTime >= fourHoursAgo && tTime <= twentyMinutesAgo;
                    });
                    
                    console.log(`  Found ${recentMeals.length} meals in lookback window`);
                    recentMeals.forEach(m => {
                        console.log(`    - ${m.localDateTime}: ${m.carbs}g`);
                    });
                    
                    if (recentMeals.length === 0) {
                        console.log(`  [WARNING]Ã‚Â¢ No meals found`);
                        return;
                    }
                    
                    // Get the most recent meal
                    const relevantMeal = recentMeals.reduce((latest, meal) => {
                        const latestTime = new Date(latest.created_at);
                        const mealTime = new Date(meal.created_at);
                        return mealTime > latestTime ? meal : latest;
                    });
                    
                    const mealId = getEventId(relevantMeal);
                    if (claimedEvents.meals.has(mealId)) {
                        console.log(`  [WARNING]Ã‚Â¢ Meal already claimed: ${relevantMeal.localDateTime}`);
                        return;
                    }
                    
                    // Check if BG went >180 between meal and low
                    const mealTime = new Date(relevantMeal.created_at);
                    const bgBetweenMealAndLow = nightscoutData.glucose.filter(reading => {
                        const rTime = new Date(reading.dateString);
                        return rTime > mealTime && rTime < lowTime;
                    });
                    
                    const hadHigh = bgBetweenMealAndLow.some(r => r.sgv > 180);
                    console.log(`  High >180 between meal and low: ${hadHigh ? 'YES' : 'NO'}`);
                    
                    if (hadHigh) {
                        console.log(`  [WARNING]Ã‚Â¢ Had high - leaving for Detector 3`);
                        return; // This is a pattern for Detector 3, not Detector 1
                    }
                    
                    // SAFETY CHECK: Skip if meal was given during existing low
                    const bgAtMealTime = nightscoutData.glucose.find(reading => {
                        const rTime = new Date(reading.dateString);
                        const timeDiff = Math.abs(rTime - mealTime);
                        return timeDiff < 10 * 60 * 1000; // Within 10 minutes
                    });
                    
                    if (bgAtMealTime && bgAtMealTime.sgv < 80) {
                        console.log(`  âš ï¸ SAFETY: Meal given during low (${bgAtMealTime.sgv} mg/dL) - skipping attribution`);
                        console.log(`  â†’ Low not caused by this meal's CR - meal eaten during unsafe conditions`);
                        return; // Don't attribute low to this meal
                    }
                    
                    // This is a direct meal-induced low!
                    // CRITICAL: Use MEAL TIME for schedule, not low time
                    const crEntry = getCRForTime(relevantMeal.localDateTime, crSchedule);
                    
                    // Claim the meal (but NOT the low - allow multiple attributions)
                    claimedEvents.meals.add(mealId);
                    
                    // Calculate adjustment based on severity
                    const lowSeverity = low.bg < 55 ? 'severe' : low.bg < 65 ? 'moderate' : 'minor';
                    const adjustmentPercent = lowSeverity === 'severe' ? 10 : 
                                            lowSeverity === 'moderate' ? 7.5 : 5;
                    
                    const newCR = crEntry.value * (1 + adjustmentPercent / 100);
                    
                    recommendations.push({
                        detector: 'Direct Meal-Induced Low',
                        type: 'CR Weakening',
                        reason: 'Meal caused low without causing high (CR too strong)',
                        scheduleTime: crEntry.time,
                        currentValue: crEntry.value,
                        newValue: parseFloat(newCR.toFixed(2)),
                        adjustment: `+${adjustmentPercent}%`,
                        calculation: `${crEntry.value} [WARNING]Ã‚Â ${(1 + adjustmentPercent / 100).toFixed(2)} = ${newCR.toFixed(2)}`,
                        details: `Meal at ${relevantMeal.localDateTime} (${relevantMeal.carbs}g) [WARNING]Ã‚Â¢ Low ${low.bg} mg/dL at ${low.localTime}. BG stayed < 180 between meal and low.`,
                        confidence: { level: 'High', score: 90 },
                        priority: 'HIGH',
                        events: [relevantMeal, low],
                        safetyNote: 'Meal insulin causing direct lows - immediate weakening needed'
                    });
                    
                    // Track that this low was processed
                    processedLowIds.add(lowId);
                    
                    console.log(`  [WARNING]Ã‚Â¦ DETECTED: ${relevantMeal.localDateTime} [WARNING]Ã‚Â¢ ${low.localTime}`);
                });
                
                console.log(`Detector 1 complete: ${recommendations.length} recommendations\n`);
                return recommendations;
            };

            /**
             * DETECTOR 1b: Transient High with Subsequent Low
             * Priority: 1 (Safety First - More Specific Pattern)
             * Pattern: Meal [WARNING]Ã‚Â Ã¢â€ â€˜ Brief High >180 (<60 min) [WARNING]Ã‚Â Ã¢â€ â€˜Ãƒâ€šÃ‚Â¢ Low (within 3 hours)
             * Conclusion: CR too strong (too much upfront insulin caused brief spike then crash)
             */
            const detectTransientHighWithLow = (lowProblems, nightscoutData, crSchedule, claimedEvents, processedLowIds) => {
                console.log('=== DETECTOR 1b: Transient High with Subsequent Low ===');
                const recommendations = [];
                
                lowProblems.forEach(low => {
                    const lowId = getEventId(low);
                    
                    // Skip if already processed by previous iterations
                    if (processedLowIds.has(lowId)) {
                        console.log(`  Skipping already processed low: ${low.localTime}`);
                        return;
                    }
                    
                    console.log(`\nDetector 1b: Checking low at ${low.localTime} (${low.bg} mg/dL)`);
                    
                    const lowTime = new Date(low.localTime);
                    const fourHoursAgo = new Date(lowTime - 4 * 60 * 60 * 1000);
                    const twentyMinutesAgo = new Date(lowTime - 20 * 60 * 1000);
                    
                    // STEP 1: Find meals in 20min-4hr lookback window
                    const recentMeals = nightscoutData.treatments.filter(t => {
                        if (!t.created_at || !t.carbs || t.carbs <= 0) return false;
                        const tTime = new Date(t.created_at);
                        return tTime >= fourHoursAgo && tTime <= twentyMinutesAgo;
                    });
                    
                    console.log(`  Found ${recentMeals.length} meals in lookback window`);
                    if (recentMeals.length === 0) {
                        console.log(`  Ã¢â€ â€˜ No meals found`);
                        return;
                    }
                    
                    // STEP 2: Check EACH meal for transient high pattern
                    // (Don't just pick most recent - find the meal that actually caused the transient high)
                    let bestMatch = null;
                    let bestMatchScore = 0;
                    
                    for (const meal of recentMeals) {
                        const mealId = getEventId(meal);
                        if (claimedEvents.meals.has(mealId)) {
                            console.log(`  Skipping claimed meal: ${meal.created_at}`);
                            continue;
                        }
                        
                        console.log(`  Checking meal: ${meal.created_at} (${meal.carbs}g)`);
                        
                        // Find BG readings between this meal and the low
                        const mealTime = new Date(meal.created_at);
                        const bgBetweenMealAndLow = nightscoutData.glucose.filter(reading => {
                            const rTime = new Date(reading.dateString);
                            return rTime > mealTime && rTime < lowTime;
                        });
                        
                        console.log(`    BG readings after meal: ${bgBetweenMealAndLow.length}`);
                        
                        // Check for high readings >180
                        const highReadings = bgBetweenMealAndLow.filter(r => r.sgv > 180);
                        console.log(`    High readings >180: ${highReadings.length}`);
                        
                        if (highReadings.length === 0) {
                            console.log(`    Ã¢â€ â€˜ No high after this meal`);
                            continue; // No high after this meal
                        }
                        
                        // Calculate high duration
                        const firstHigh = highReadings[0];
                        const lastHigh = highReadings[highReadings.length - 1];
                        const firstHighTime = new Date(firstHigh.dateString);
                        const lastHighTime = new Date(lastHigh.dateString);
                        const highDurationMinutes = (lastHighTime - firstHighTime) / (1000 * 60);
                        const peakBG = Math.max(...highReadings.map(r => r.sgv));
                        
                        console.log(`    High duration: ${highDurationMinutes.toFixed(1)} min, peak: ${peakBG} mg/dL`);
                        
                        // Check if high was TRANSIENT (<60 minutes)
                        const HIGH_DURATION_THRESHOLD = 60;
                        if (highDurationMinutes >= HIGH_DURATION_THRESHOLD) {
                            console.log(`    Ã¢â€ â€˜ High too sustained (${highDurationMinutes.toFixed(1)} min >= ${HIGH_DURATION_THRESHOLD} min)`);
                            continue; // Sustained high - not transient
                        }
                        
                        // Check if low occurred within 3 hours of high ending
                        const timeFromHighToLowHours = (lowTime - lastHighTime) / (1000 * 60 * 60);
                        console.log(`    Time from high to low: ${timeFromHighToLowHours.toFixed(1)} hours`);
                        
                        const TIME_TO_LOW_THRESHOLD = 3;
                        if (timeFromHighToLowHours > TIME_TO_LOW_THRESHOLD) {
                            console.log(`    Ã¢â€ â€˜ Low too delayed (${timeFromHighToLowHours.toFixed(1)} hrs > ${TIME_TO_LOW_THRESHOLD} hrs)`);
                            continue; // Low too far after high
                        }
                        
                        // Check for corrections between high and low
                        const correctionsDuringPeriod = nightscoutData.treatments.filter(t => {
                            if (!isTrueCorrection(t, nightscoutData.treatments)) return false;
                            const tTime = new Date(t.created_at);
                            return tTime >= firstHighTime && tTime <= lowTime;
                        });
                        
                        console.log(`    Corrections during period: ${correctionsDuringPeriod.length}`);
                        
                        if (correctionsDuringPeriod.length > 0) {
                            console.log(`    Ã¢â€ â€˜ Corrections were given - not pure meal effect`);
                            continue; // Corrections given - not pure meal effect
                        }
                        
                        // This meal has the transient high pattern!
                        // Score it based on peak BG and how close the timing is
                        const score = peakBG + (100 / (timeFromHighToLowHours + 0.1)); // Higher peak + shorter time = higher score
                        console.log(`    Ã¢â€ â€˜ MATCH! Score: ${score.toFixed(1)}`);
                        
                        if (score > bestMatchScore) {
                            bestMatch = {
                                meal: meal,
                                mealId: mealId,
                                highReadings: highReadings,
                                firstHigh: firstHigh,
                                lastHigh: lastHigh,
                                firstHighTime: firstHighTime,
                                lastHighTime: lastHighTime,
                                highDurationMinutes: highDurationMinutes,
                                peakBG: peakBG,
                                timeFromHighToLowHours: timeFromHighToLowHours
                            };
                            bestMatchScore = score;
                        }
                    }
                    
                    // If no meal matched the transient high pattern, skip this low
                    if (!bestMatch) {
                        console.log(`  Ã¢â€ â€˜ No meal with transient high pattern found`);
                        return;
                    }
                    
                    console.log(`  Ã¢â€ â€˜ Best match: ${bestMatch.meal.created_at} (${bestMatch.meal.carbs}g) with score ${bestMatchScore.toFixed(1)}`);
                    
                    // STEP 3: TRANSIENT HIGH DETECTED!
                    console.log(`  [WARNING]Ã‚Â¦ TRANSIENT HIGH DETECTED!`);
                    console.log(`  [WARNING]Ã‚Â Ã¢â€ â€˜ Brief spike (${bestMatch.highDurationMinutes.toFixed(1)} min) [WARNING]Ã‚Â Ã¢â€ â€˜Ãƒâ€šÃ‚Â¢ crash (${bestMatch.timeFromHighToLowHours.toFixed(1)} hrs)`);
                    console.log(`  [WARNING]Ã‚Â Ã¢â€ â€˜ Excessive insulin dosing`);
                    
                    // Use MEAL TIME for CR schedule
                    const crEntry = getCRForTime(bestMatch.meal.created_at, crSchedule);
                    
                    // Claim the events
                    claimedEvents.meals.add(bestMatch.mealId);
                    bestMatch.highReadings.forEach(h => {
                        claimedEvents.highs.add(getEventId(h));
                    });
                    
                    // Calculate adjustment based on severity
                    // More severe if: higher peak, shorter duration to crash, lower low
                    let adjustmentPercent;
                    if (low.bg < 55 || bestMatch.peakBG > 220) {
                        adjustmentPercent = 10; // Severe
                    } else if (low.bg < 65 || bestMatch.peakBG > 200) {
                        adjustmentPercent = 7.5; // Moderate
                    } else {
                        adjustmentPercent = 5; // Minor
                    }
                    
                    const newCR = crEntry.value * (1 + adjustmentPercent / 100);
                    
                    recommendations.push({
                        detector: 'Transient High with Subsequent Low',
                        type: 'CR Weakening',
                        reason: 'Meal caused brief spike then crashed to low (too much insulin)',
                        scheduleTime: crEntry.time,
                        currentValue: crEntry.value,
                        newValue: parseFloat(newCR.toFixed(2)),
                        adjustment: `+${adjustmentPercent}%`,
                        calculation: `${crEntry.value}  ${(1 + adjustmentPercent / 100).toFixed(2)} = ${newCR.toFixed(2)}`,
                        details: `Meal at ${bestMatch.meal.created_at} (${bestMatch.meal.carbs}g) [WARNING]Ã‚Â Ã¢â€ â€˜ Brief high ${bestMatch.peakBG} mg/dL (${bestMatch.highDurationMinutes.toFixed(0)} min) [WARNING]Ã‚Â Ã¢â€ â€˜Ãƒâ€šÃ‚Â¢ Low ${low.bg} mg/dL at ${low.localTime} (${bestMatch.timeFromHighToLowHours.toFixed(1)}h later). Peak-to-crash pattern indicates excessive insulin.`,
                        confidence: { level: 'High', score: 90 },
                        priority: 'HIGH',
                        events: [bestMatch.meal, bestMatch.firstHigh, bestMatch.lastHigh, low],
                        safetyNote: 'Transient spike followed by crash - too much upfront insulin causing both high and low'
                    });
                    
                    // Track that this low was processed
                    processedLowIds.add(lowId);
                    
                    console.log(`  [WARNING]Ã‚Â¦ DETECTED: ${bestMatch.meal.created_at} [WARNING]Ã‚Â Ã¢â€ â€˜ ${low.localTime}`);
                });
                
                console.log(`Detector 1b complete: ${recommendations.length} recommendations\n`);
                return recommendations;
            };

            /**
             * DETECTOR 2: Correction Overcorrection
             * Priority: 2 (ISF Issue)
             * Pattern: High >180 [WARNING]Ã‚Â¢ Corrections (within 1hr) [WARNING]Ã‚Â¢ Low (1-3 hours later)
             * Conclusion: ISF too strong (corrections too aggressive)
             */
            const detectCorrectionOvercorrection = (lowProblems, nightscoutData, isfSchedule, claimedEvents, processedLowIds) => {
                console.log('=== DETECTOR 2: Correction Overcorrection ===');
                const recommendations = [];
                
                lowProblems.forEach(low => {
                    const lowId = getEventId(low);
                    
                    // NOTE: We intentionally do NOT skip lows in processedLowIds here.
                    // This allows us to detect stacking scenarios where BOTH:
                    // - Detector 1 found: Meal [WARNING]Ã‚Â¢ Low (CR too strong)
                    // - Detector 2 finds: Corrections [WARNING]Ã‚Â¢ Same Low (ISF too strong)
                    // Both recommendations may be valid if meal + corrections stacked.
                    
                    console.log(`\nDetector 2: Checking low at ${low.localTime} (${low.bg} mg/dL)`);
                    
                    const lowTime = new Date(low.time);  // Use UTC timestamp
                    const threeHoursAgo = new Date(lowTime - 3 * 60 * 60 * 1000);
                    const oneHourAgo = new Date(lowTime - 1 * 60 * 60 * 1000);
                    
                    console.log(`  Looking for treatments between ${oneHourAgo.toISOString()} and ${lowTime.toISOString()}`);
                    
                    // First, find ALL treatments with insulin in the window (before filtering)
                    const allInsulinInWindow = nightscoutData.treatments.filter(t => {
                        if (!t.created_at) return false;
                        const tTime = new Date(t.created_at);  // Use UTC timestamp
                        if (tTime < oneHourAgo || tTime > lowTime) return false;
                        return t.insulin && t.insulin > 0;
                    });
                    
                    console.log(`  Found ${allInsulinInWindow.length} total treatments with insulin in window`);
                    allInsulinInWindow.forEach(t => {
                        const isCorrection = isTrueCorrection(t, nightscoutData.treatments);
                        console.log(`    ${t.localDateTime}: ${t.insulin}U, eventType: ${t.eventType || 'none'}, carbs: ${t.carbs || 0}, isCorrection: ${isCorrection}`);
                    });
                    
                    // Find corrections in 1-3 hour lookback window
                    const recentCorrections = nightscoutData.treatments.filter(t => {
                        if (!t.created_at || !t.insulin || t.insulin <= 0) return false;
                        const tTime = new Date(t.created_at);
                        if (tTime < oneHourAgo || tTime > lowTime) return false;
                        
                        // Allow using corrections even if claimed by other detectors (for stacking scenarios)
                        // const correctionId = getEventId(t);
                        // if (claimedEvents.corrections.has(correctionId)) return false;
                        
                        return isTrueCorrection(t, nightscoutData.treatments);
                    });
                    
                    if (recentCorrections.length === 0) {
                        console.log(`  [WARNING]Ã‚Â¢ No corrections found (after filtering)`);
                        return; // No corrections
                    }
                    
                    // CRITICAL: Find the high that these corrections were addressing
                    // Look back up to 6 hours from earliest correction
                    const earliestCorrectionTime = new Date(
                        Math.min(...recentCorrections.map(c => new Date(c.created_at)))
                    );
                    const sixHoursBeforeCorrection = new Date(earliestCorrectionTime - 6 * 60 * 60 * 1000);
                    
                    const bgBeforeCorrections = nightscoutData.glucose.filter(reading => {
                        const rTime = new Date(reading.dateString);
                        return rTime >= sixHoursBeforeCorrection && rTime <= earliestCorrectionTime;
                    });
                    
                    // Check if ANY high >180 occurred within 3 hours BEFORE corrections
                    const threeHoursBeforeCorrection = new Date(earliestCorrectionTime - 3 * 60 * 60 * 1000);
                    const highReadings = bgBeforeCorrections.filter(r => {
                        const rTime = new Date(r.dateString);
                        return r.sgv > 180 && rTime >= threeHoursBeforeCorrection && rTime <= earliestCorrectionTime;
                    });
                    
                    if (highReadings.length === 0) {
                        console.log(`Skipping - no high within 3hrs before corrections`);
                        return; // No high within 3 hours before corrections
                    }
                    
                    // Find the last high reading for reporting
                    const lastHighReading = highReadings.reduce((latest, r) => {
                        const latestTime = new Date(latest.dateString);
                        const rTime = new Date(r.dateString);
                        return rTime > latestTime ? r : latest;
                    });
                    
                    // Check for new meal with significant carbs between corrections and low
                    const mealsBetweenCorrectionAndLow = nightscoutData.treatments.filter(t => {
                        if (!t.created_at || !t.carbs || t.carbs < 15) return false;
                        const tTime = new Date(t.created_at);
                        return tTime > earliestCorrectionTime && tTime < lowTime;
                    });
                    
                    // Don't skip if meal found - flag as potential stacking scenario
                    const hasStacking = mealsBetweenCorrectionAndLow.length > 0;
                    
                    // This is correction overcorrection (possibly with stacking)!
                    // CRITICAL: Use CORRECTION TIME for ISF schedule, not low time
                    const isfEntry = getISFForTime(earliestCorrectionTime.toISOString(), isfSchedule);
                    
                    // Claim corrections and highs (but NOT lows - allow multiple attributions)
                    recentCorrections.forEach(c => {
                        claimedEvents.corrections.add(getEventId(c));
                    });
                    highReadings.forEach(h => {
                        claimedEvents.highs.add(getEventId(h));
                    });
                    
                    const totalCorrectionInsulin = recentCorrections.reduce((sum, c) => sum + c.insulin, 0);
                    const adjustmentPercent = low.bg < 55 ? 5 : 3;
                    const newISF = isfEntry.value * (1 + adjustmentPercent / 100);
                    
                    let reason = 'Corrections too aggressive for high (ISF too strong)';
                    let confidence = { level: 'Medium', score: 70 };
                    let details = `High ${lastHighReading.sgv} mg/dL at ${lastHighReading.localDateTime} [WARNING]Ã‚Â¢ ${recentCorrections.length} corrections (${totalCorrectionInsulin.toFixed(2)}U) [WARNING]Ã‚Â¢ Low ${low.bg} mg/dL at ${low.localTime}`;
                    
                    if (hasStacking) {
                        reason += ' - possible insulin stacking with meal';
                        confidence = { level: 'Medium', score: 60 };
                        details += `. Note: ${mealsBetweenCorrectionAndLow.length} meal(s) between corrections and low may have contributed.`;
                    }
                    
                    recommendations.push({
                        detector: 'Correction Overcorrection',
                        type: 'ISF Weakening',
                        reason: reason,
                        scheduleTime: isfEntry.time,
                        currentValue: isfEntry.value,
                        newValue: parseFloat(newISF.toFixed(2)),
                        adjustment: `+${adjustmentPercent}%`,
                        calculation: `${isfEntry.value} [WARNING]Ã‚Â ${(1 + adjustmentPercent / 100).toFixed(2)} = ${newISF.toFixed(2)}`,
                        details: details,
                        confidence: confidence,
                        priority: 'MEDIUM',
                        events: [lastHighReading, ...recentCorrections, low],
                        safetyNote: hasStacking ? 'Corrections + meal insulin stacking - ISF may be too strong' : 'Corrections causing lows - ISF too strong'
                    });
                    
                    // Track that this low was processed
                    processedLowIds.add(lowId);
                    
                    console.log(`[WARNING]Ã‚Â¦ Found correction overcorrection: High at ${lastHighReading.localDateTime} [WARNING]Ã‚Â¢ Low at ${low.localTime}${hasStacking ? ' (with stacking)' : ''}`);
                });
                
                console.log(`Detector 2 complete: ${recommendations.length} recommendations`);
                return recommendations;
            };

            /**
             * DETECTOR 3: Post-Meal Highs with Corrections
             * Priority: 3 (CR Weakness)
             * Pattern: Meal [WARNING]Ã‚Â¢ High >180 [WARNING]Ã‚Â¢ Corrections (with or without subsequent low)
             * Conclusion: CR too weak (not enough upfront insulin)
             */
            const detectPostMealHighsWithCorrections = (lowProblems, nightscoutData, crSchedule, claimedEvents, processedLowIds) => {
                console.log('=== DETECTOR 3: Post-Meal Highs with Corrections ===');
                const recommendations = [];
                
                // PASS 1: Traditional pattern - Meal [WARNING]Ã‚Â¢ High [WARNING]Ã‚Â¢ Corrections [WARNING]Ã‚Â¢ Low
                lowProblems.forEach(low => {
                    const lowId = getEventId(low);
                    
                    // NOTE: We intentionally do NOT skip lows in processedLowIds here.
                    // This allows detection of complex stacking scenarios.
                    
                    const lowTime = new Date(low.time);
                    const fourHoursAgo = new Date(lowTime - 4 * 60 * 60 * 1000);
                    const twoHoursAgo = new Date(lowTime - 2 * 60 * 60 * 1000);
                    
                    // Find corrections in 2-4 hour lookback window
                    const recentCorrections = nightscoutData.treatments.filter(t => {
                        if (!t.created_at || !t.insulin || t.insulin <= 0) return false;
                        const tTime = new Date(t.created_at);
                        if (tTime < twoHoursAgo || tTime > lowTime) return false;
                        
                        const correctionId = getEventId(t);
                        if (claimedEvents.corrections.has(correctionId)) return false;
                        
                        return isTrueCorrection(t, nightscoutData.treatments);
                    });
                    
                    if (recentCorrections.length === 0) return; // No corrections
                    
                    // Find the high that these corrections were addressing
                    const earliestCorrectionTime = new Date(
                        Math.min(...recentCorrections.map(c => new Date(c.created_at)))
                    );
                    const sixHoursBeforeCorrection = new Date(earliestCorrectionTime - 6 * 60 * 60 * 1000);
                    
                    const bgBeforeCorrections = nightscoutData.glucose.filter(reading => {
                        const rTime = new Date(reading.dateString);
                        return rTime >= sixHoursBeforeCorrection && rTime <= earliestCorrectionTime;
                    });
                    
                    // Was there a high >180?
                    const highReadings = bgBeforeCorrections.filter(r => r.sgv > 180);
                    if (highReadings.length === 0) return; // No high
                    
                    // Check if high occurred within 3 hours before corrections
                    const threeHoursBeforeCorrection = new Date(earliestCorrectionTime - 3 * 60 * 60 * 1000);
                    const recentHighReadings = highReadings.filter(r => {
                        const rTime = new Date(r.dateString);
                        return rTime >= threeHoursBeforeCorrection;
                    });
                    
                    if (recentHighReadings.length === 0) {
                        console.log(`Skipping - no high within 3hrs before corrections`);
                        return;
                    }
                    
                    // Find the last high reading from recent highs
                    const lastHighReading = recentHighReadings.reduce((latest, r) => {
                        const latestTime = new Date(latest.localDateTime);
                        const rTime = new Date(r.dateString);
                        return rTime > latestTime ? r : latest;
                    });
                    
                    // Find the meal that caused the high
                    // Look back 1-4 hours BEFORE the high started
                    const earliestHighReading = highReadings.reduce((earliest, r) => {
                        const earliestTime = new Date(earliest.localDateTime);
                        const rTime = new Date(r.dateString);
                        return rTime < earliestTime ? r : earliest;
                    });
                    
                    const highStartTime = new Date(earliestHighReading.localDateTime);
                    const fourHoursBeforeHigh = new Date(highStartTime - 4 * 60 * 60 * 1000);
                    const oneHourBeforeHigh = new Date(highStartTime - 1 * 60 * 60 * 1000);
                    
                    // Find meals in this window
                    const potentialMeals = nightscoutData.treatments.filter(t => {
                        if (!t.created_at || !t.carbs || t.carbs <= 0) return false;
                        const tTime = new Date(t.created_at);
                        return tTime >= oneHourBeforeHigh && tTime <= highStartTime;
                    });
                    
                    if (potentialMeals.length === 0) return; // No meal found
                    
                    // Get the most recent meal before the high
                    const relevantMeal = potentialMeals.reduce((latest, meal) => {
                        const latestTime = new Date(latest.localDateTime);
                        const mealTime = new Date(meal.created_at);
                        return mealTime > latestTime ? meal : latest;
                    });
                    
                    const mealId = getEventId(relevantMeal);
                    if (claimedEvents.meals.has(mealId)) {
                        console.log(`Skipping - meal already claimed: ${relevantMeal.localDateTime}`);
                        return;
                    }
                    
                    // SAFETY CHECK: Check if this is a rebound high (not weak CR)
                    const mealTime = new Date(relevantMeal.created_at);
                    
                    // ===== SIGNAL 1: Meal during low (SIMPLEST, MOST RELIABLE) =====
                    const bgAtMealTime = nightscoutData.glucose.find(reading => {
                        const rTime = new Date(reading.dateString);
                        const timeDiff = Math.abs(rTime - mealTime);
                        return timeDiff < 10 * 60 * 1000;
                    });
                    const mealDuringLow = bgAtMealTime && bgAtMealTime.sgv < 80;
                    
                    // ===== SIGNAL 2: Underdosing with IOB check (ONLY if BG wasn't low) =====
                    let isSafetyReduction = false;
                    if (!mealDuringLow && relevantMeal.carbs > 0) {
                        const expectedBolus = relevantMeal.carbs / crEntry.value;
                        const actualBolus = relevantMeal.insulin || 0;
                        const percentGiven = (actualBolus / expectedBolus) * 100;
                        
                        if (percentGiven < 70) {
                            // Get IOB at meal time
                            const iobAtMealTime = getIOBAtTime(nightscoutData.deviceStatus, mealTime);
                            
                            if (iobAtMealTime && iobAtMealTime > 1.0) {
                                // High IOB explains the reduction - not safety
                                console.log(`  → High IOB (${iobAtMealTime.toFixed(2)}U) explains underdosing`);
                                isSafetyReduction = false;
                            } else {
                                // Low/no IOB but still underdosed - safety reduction
                                console.log(`  → Underdosed (${percentGiven.toFixed(0)}%) with low IOB (${iobAtMealTime?.toFixed(2) || 0}U) - safety reduction`);
                                isSafetyReduction = true;
                            }
                        }
                    }
                    
                    // ===== If EITHER signal present, check for severe low + rebound =====
                    if (mealDuringLow || isSafetyReduction) {
                        // Check if severe low occurred within 2 hours after meal
                        const twoHoursAfterMeal = new Date(mealTime.getTime() + 2 * 60 * 60 * 1000);
                        const severeLowReadings = nightscoutData.glucose.filter(reading => {
                            const rTime = new Date(reading.dateString);
                            return rTime > mealTime && rTime <= twoHoursAfterMeal && reading.sgv < 55;
                        });
                        
                        if (severeLowReadings.length > 0) {
                            const lowestReading = severeLowReadings.reduce((min, r) => r.sgv < min.sgv ? r : min);
                            
                            if (mealDuringLow) {
                                console.log(`  ⚠️ REBOUND HIGH: Meal during low (${bgAtMealTime.sgv}) → severe low (${lowestReading.sgv}) → spike (${peakBG})`);
                            } else {
                                console.log(`  ⚠️ REBOUND HIGH: Safety underdosing → severe low (${lowestReading.sgv}) → spike (${peakBG})`);
                            }
                            console.log(`  → High from hypoglycemia treatment/rebound, not weak CR`);
                            
                            // Create informational flag instead of CR strengthening
                            recommendations.push({
                                detector: 'Rebound High Detection (Pass 1)',
                                type: 'Informational',
                                pattern: 'Severe Hypoglycemia with Rebound',
                                scheduleTime: crEntry.time,
                                currentValue: crEntry.value,
                                newValue: crEntry.value, // No change recommended
                                adjustment: 'None',
                                reason: 'High is physiological rebound from severe hypoglycemia, not weak CR',
                                calculation: 'N/A',
                                details: `Meal at ${relevantMeal.localDateTime} (${relevantMeal.carbs}g) ${mealDuringLow ? `during low (${bgAtMealTime.sgv} mg/dL)` : 'with safety underdosing'} → Severe low ${lowestReading.sgv} mg/dL at ${lowestReading.localDateTime} → Rebound spike to ${peakBG} mg/dL.\n\nPattern indicates need for:\n1. Better meal timing (avoid eating during lows)\n2. Adequate low treatment (~15g fast carbs)\n3. Monitor for rebounds after severe lows\n\nThis high is NOT due to weak CR - it's a physiological response to severe hypoglycemia.`,
                                confidence: { level: 'High', score: 95 },
                                priority: 'INFORMATIONAL',
                                events: [relevantMeal, lowestReading, ...highReadings],
                                safetyNote: 'Rebound high from severe hypoglycemia - no CR adjustment needed'
                            });
                            
                            return; // Skip CR strengthening recommendation
                        }
                    }
                    
                    // This is a post-meal high with corrections leading to low!
                    // CRITICAL: Use MEAL TIME for CR schedule, not low time
                    const crEntry = getCRForTime(relevantMeal.localDateTime, crSchedule);
                    
                    // Claim the events
                    claimedEvents.meals.add(mealId);
                    recentCorrections.forEach(c => {
                        claimedEvents.corrections.add(getEventId(c));
                    });
                    highReadings.forEach(h => {
                        claimedEvents.highs.add(getEventId(h));
                    });
                    
                    const totalCorrectionInsulin = recentCorrections.reduce((sum, c) => sum + c.insulin, 0);
                    
                    // Calculate adjustment based on high severity
                    const peakBG = Math.max(...highReadings.map(r => r.sgv));
                    const adjustmentPercent = peakBG > 250 ? 10 : peakBG > 220 ? 7.5 : 5;
                    const newCR = crEntry.value * (1 - adjustmentPercent / 100);
                    
                    recommendations.push({
                        detector: 'Post-Meal High with Corrections',
                        type: 'CR Strengthening',
                        reason: 'Meal caused high requiring corrections (CR too weak)',
                        scheduleTime: crEntry.time,
                        currentValue: crEntry.value,
                        newValue: parseFloat(newCR.toFixed(2)),
                        adjustment: `-${adjustmentPercent}%`,
                        calculation: `${crEntry.value} [WARNING]Ã‚Â ${(1 - adjustmentPercent / 100).toFixed(2)} = ${newCR.toFixed(2)}`,
                        details: `Meal at ${relevantMeal.localDateTime} (${relevantMeal.carbs}g) [WARNING]Ã‚Â¢ High ${peakBG} mg/dL at ${lastHighReading.localDateTime} [WARNING]Ã‚Â¢ ${recentCorrections.length} corrections (${totalCorrectionInsulin.toFixed(2)}U) [WARNING]Ã‚Â¢ Low ${low.bg} mg/dL at ${low.localTime}`,
                        confidence: { level: 'High', score: 90 },
                        priority: 'MEDIUM',
                        events: [relevantMeal, earliestHighReading, ...recentCorrections, low],
                        safetyNote: 'Meal causing high - strengthen CR but monitor for stacking'
                    });
                    
                    // Track that this low was processed
                    processedLowIds.add(lowId);
                    
                    console.log(`[WARNING]Ã‚Â¦ Found post-meal high with corrections [WARNING]Ã‚Â¢ low: ${relevantMeal.localDateTime}`);
                });
                
                // PASS 2: NEW - Meal [WARNING]Ã‚Â¢ High [WARNING]Ã‚Â¢ Corrections (NO low required)
                // Look through all unclaimed meals that caused highs requiring corrections
                const meals = nightscoutData.treatments.filter(t => 
                    t.localDateTime && t.carbs && t.carbs > 0 && !claimedEvents.meals.has(getEventId(t))
                );
                
                meals.forEach(meal => {
                    console.log(`\nPass 2: Checking meal ${meal.localDateTime} (${meal.carbs}g)`);
                    
                    const mealTime = new Date(meal.created_at);
                    const threeHoursAfter = new Date(mealTime.getTime() + 3 * 60 * 60 * 1000);
                    const oneHourAfter = new Date(mealTime.getTime() + 1 * 60 * 60 * 1000);
                    
                    // Find BG readings 1-3 hours after meal
                    const postMealReadings = nightscoutData.glucose.filter(reading => {
                        const rTime = new Date(reading.dateString);
                        return rTime >= oneHourAfter && rTime <= threeHoursAfter;
                    });
                    
                    console.log(`  Post-meal readings: ${postMealReadings.length}`);
                    
                    if (postMealReadings.length === 0) {
                        console.log(`  [WARNING]Ã‚Â¢ No post-meal readings`);
                        return;
                    }
                    
                    // Was there a high >180?
                    const highReadings = postMealReadings.filter(r => r.sgv > 180);
                    console.log(`  High readings >180: ${highReadings.length}`);
                    
                    if (highReadings.length === 0) {
                        console.log(`  [WARNING]Ã‚Â¢ No high >180`);
                        return; // No high
                    }
                    
                    const peakReading = highReadings.reduce((max, r) => r.sgv > max.sgv ? r : max);
                    const peakTime = new Date(peakReading.localDateTime);
                    const peakBG = Math.max(...highReadings.map(r => r.sgv));
                    
                    console.log(`  Peak: ${peakBG} mg/dL at ${peakReading.localDateTime}`);
                    
                    // Check if ANY corrections were given for this high (claimed or unclaimed)
                    const allCorrections = nightscoutData.treatments.filter(t => {
                        if (!isTrueCorrection(t, nightscoutData.treatments)) return false;
                        const tTime = new Date(t.created_at);
                        return tTime >= peakTime && tTime <= threeHoursAfter;
                    });
                    
                    const unclaimedCorrections = allCorrections.filter(c => 
                        !claimedEvents.corrections.has(getEventId(c))
                    );
                    
                    console.log(`  Total corrections found: ${allCorrections.length}`);
                    console.log(`  Unclaimed corrections: ${unclaimedCorrections.length}`);
                    console.log(`  Claimed corrections: ${allCorrections.length - unclaimedCorrections.length}`);
                    
                    // SAFETY CHECK: Check if this is a rebound high (not weak CR)
                    // ===== SIGNAL 1: Meal during low (SIMPLEST, MOST RELIABLE) =====
                    const bgAtMealTime = nightscoutData.glucose.find(reading => {
                        const rTime = new Date(reading.dateString);
                        const timeDiff = Math.abs(rTime - mealTime);
                        return timeDiff < 10 * 60 * 1000;
                    });
                    const mealDuringLow = bgAtMealTime && bgAtMealTime.sgv < 80;
                    
                    // ===== SIGNAL 2: Underdosing with IOB check (ONLY if BG wasn't low) =====
                    let isSafetyReduction = false;
                    const crEntry = getCRForTime(meal.localDateTime, crSchedule);
                    
                    if (!mealDuringLow && meal.carbs > 0) {
                        const expectedBolus = meal.carbs / crEntry.value;
                        const actualBolus = meal.insulin || 0;
                        const percentGiven = (actualBolus / expectedBolus) * 100;
                        
                        if (percentGiven < 70) {
                            // Get IOB at meal time
                            const iobAtMealTime = getIOBAtTime(nightscoutData.deviceStatus, mealTime);
                            
                            if (iobAtMealTime && iobAtMealTime > 1.0) {
                                // High IOB explains the reduction - not safety
                                console.log(`  → High IOB (${iobAtMealTime.toFixed(2)}U) explains underdosing`);
                                isSafetyReduction = false;
                            } else {
                                // Low/no IOB but still underdosed - safety reduction
                                console.log(`  → Underdosed (${percentGiven.toFixed(0)}%) with low IOB (${iobAtMealTime?.toFixed(2) || 0}U) - safety reduction`);
                                isSafetyReduction = true;
                            }
                        }
                    }
                    
                    // ===== If EITHER signal present, check for severe low + rebound =====
                    if (mealDuringLow || isSafetyReduction) {
                        // Check if severe low occurred within 2 hours after meal
                        const twoHoursAfterMeal = new Date(mealTime.getTime() + 2 * 60 * 60 * 1000);
                        const severeLowReadings = nightscoutData.glucose.filter(reading => {
                            const rTime = new Date(reading.dateString);
                            return rTime > mealTime && rTime <= twoHoursAfterMeal && reading.sgv < 55;
                        });
                        
                        if (severeLowReadings.length > 0) {
                            const lowestReading = severeLowReadings.reduce((min, r) => r.sgv < min.sgv ? r : min);
                            
                            if (mealDuringLow) {
                                console.log(`  ⚠️ REBOUND HIGH: Meal during low (${bgAtMealTime.sgv}) → severe low (${lowestReading.sgv}) → spike (${peakBG})`);
                            } else {
                                console.log(`  ⚠️ REBOUND HIGH: Safety underdosing → severe low (${lowestReading.sgv}) → spike (${peakBG})`);
                            }
                            console.log(`  → High from hypoglycemia treatment/rebound, not weak CR`);
                            
                            // Create informational flag instead of CR strengthening
                            recommendations.push({
                                detector: 'Rebound High Detection (Pass 2)',
                                type: 'Informational',
                                pattern: 'Severe Hypoglycemia with Rebound',
                                scheduleTime: crEntry.time,
                                currentValue: crEntry.value,
                                newValue: crEntry.value, // No change recommended
                                adjustment: 'None',
                                reason: 'High is physiological rebound from severe hypoglycemia, not weak CR',
                                calculation: 'N/A',
                                details: `Meal at ${meal.localDateTime} (${meal.carbs}g) ${mealDuringLow ? `during low (${bgAtMealTime.sgv} mg/dL)` : 'with safety underdosing'} → Severe low ${lowestReading.sgv} mg/dL at ${lowestReading.localDateTime} → Rebound spike to ${peakBG} mg/dL.\n\nPattern indicates need for:\n1. Better meal timing (avoid eating during lows)\n2. Adequate low treatment (~15g fast carbs)\n3. Monitor for rebounds after severe lows\n\nThis high is NOT due to weak CR - it's a physiological response to severe hypoglycemia.`,
                                confidence: { level: 'High', score: 95 },
                                priority: 'INFORMATIONAL',
                                events: [meal, lowestReading, ...highReadings],
                                safetyNote: 'Rebound high from severe hypoglycemia - no CR adjustment needed'
                            });
                            
                            console.log(`  → Skipping CR strengthening - rebound high detected`);
                            return; // Skip CR strengthening recommendation
                        }
                    }
                    
                    // Create recommendation if meal caused high >180 (regardless of corrections)
                    const adjustmentPercent = peakBG > 250 ? 10 : peakBG > 220 ? 7.5 : 5;
                    const newCR = crEntry.value * (1 - adjustmentPercent / 100);
                    
                    // Claim the events
                    claimedEvents.meals.add(getEventId(meal));
                    highReadings.forEach(h => claimedEvents.highs.add(getEventId(h)));
                    // Only claim unclaimed corrections to avoid conflicts with Detector 2
                    unclaimedCorrections.forEach(c => claimedEvents.corrections.add(getEventId(c)));
                    
                    // Build details and confidence based on correction status
                    let details, confidence, reason;
                    if (allCorrections.length > 0) {
                        const totalCorrectionInsulin = allCorrections.reduce((sum, c) => sum + c.insulin, 0);
                        details = `Meal at ${meal.localDateTime} (${meal.carbs}g) [WARNING]Ã‚Â¢ High ${peakBG} mg/dL at ${peakReading.localDateTime} [WARNING]Ã‚Â¢ ${allCorrections.length} corrections (${totalCorrectionInsulin.toFixed(2)}U) given. High requiring corrections indicates insufficient upfront insulin.`;
                        confidence = { level: 'High', score: 85 };
                        reason = 'Meal caused high requiring corrections (CR too weak)';
                    } else {
                        details = `Meal at ${meal.localDateTime} (${meal.carbs}g) [WARNING]Ã‚Â¢ High ${peakBG} mg/dL at ${peakReading.localDateTime}. High indicates insufficient upfront insulin.`;
                        confidence = { level: 'Medium', score: 70 };
                        reason = 'Meal caused high (CR too weak)';
                    }
                    
                    recommendations.push({
                        detector: 'Post-Meal High (Pass 2)',
                        type: 'CR Strengthening',
                        reason: reason,
                        scheduleTime: crEntry.time,
                        currentValue: crEntry.value,
                        newValue: parseFloat(newCR.toFixed(2)),
                        adjustment: `-${adjustmentPercent}%`,
                        calculation: `${crEntry.value} [WARNING]Ã‚Â ${(1 - adjustmentPercent / 100).toFixed(2)} = ${newCR.toFixed(2)}`,
                        details: details,
                        confidence: confidence,
                        priority: 'MEDIUM',
                        events: allCorrections.length > 0 ? [meal, peakReading, ...allCorrections] : [meal, peakReading],
                        safetyNote: 'Meal causing high - strengthen CR'
                    });
                    
                    console.log(`[WARNING]Ã‚Â¦ Found post-meal high: ${meal.localDateTime} [WARNING]Ã‚Â¢ ${peakBG} mg/dL (${allCorrections.length} corrections)`);
                });
                
                console.log(`Detector 3 complete: ${recommendations.length} recommendations\n`);
                return recommendations;
            };

            // Helper function to analyze basal pattern
            const analyzeBasalPattern = (schedule) => {
                // Check if uniform (all rates the same)
                const firstRate = schedule[0].value;
                const isUniform = schedule.every(entry => Math.abs(entry.value - firstRate) < 0.01);
                
                if (isUniform) {
                    return { type: 'UNIFORM', baseRate: firstRate };
                }
                
                // Check for alternating pattern (two rates alternating)
                const uniqueRates = [...new Set(schedule.map(e => e.value.toFixed(3)))];
                if (uniqueRates.length === 2) {
                    let isAlternating = true;
                    for (let i = 0; i < schedule.length - 2; i++) {
                        if (Math.abs(schedule[i].value - schedule[i + 2].value) > 0.01) {
                            isAlternating = false;
                            break;
                        }
                    }
                    if (isAlternating) {
                        return { 
                            type: 'ALTERNATING', 
                            rate1: parseFloat(uniqueRates[0]), 
                            rate2: parseFloat(uniqueRates[1])
                        };
                    }
                }
                
                // Otherwise it's a complex pattern - use blocks
                return { type: 'BLOCKS' };
            };

            // Helper to round to pump increment
            const roundToPumpIncrement = (value, increment = 0.05) => {
                return Math.round(value / increment) * increment;
            };

            // Distribute basal adjustment across 24 hours
            const distributeBasalAdjustment = (currentSchedule, targetTotalDaily) => {
                const currentTotal = currentSchedule.reduce((sum, entry) => sum + entry.value, 0);
                const targetHourlyAvg = targetTotalDaily / 24;
                
                // Try for uniform first
                const uniformRate = roundToPumpIncrement(targetHourlyAvg);
                const uniformTotal = uniformRate * 24;
                
                if (Math.abs(uniformTotal - targetTotalDaily) < 0.1) {
                    // Close enough - go uniform
                    return currentSchedule.map((entry, idx) => ({
                        ...entry,
                        value: uniformRate,
                        time: `${idx.toString().padStart(2, '0')}:00`
                    }));
                }
                
                // If current is alternating, try to simplify
                const pattern = analyzeBasalPattern(currentSchedule);
                if (pattern.type === 'ALTERNATING') {
                    const avgRate = (pattern.rate1 + pattern.rate2) / 2;
                    const adjustment = (targetTotalDaily - currentTotal) / 24;
                    const newRate = roundToPumpIncrement(avgRate + adjustment);
                    
                    return currentSchedule.map((entry, idx) => ({
                        ...entry,
                        value: newRate,
                        time: `${idx.toString().padStart(2, '0')}:00`
                    }));
                }
                
                // Otherwise, use proportional scaling with 4-hour blocks
                const scaleFactor = targetTotalDaily / currentTotal;
                const result = [];
                
                // Process in 4-hour blocks for circadian consistency
                for (let blockStart = 0; blockStart < 24; blockStart += 4) {
                    const blockEnd = Math.min(blockStart + 4, 24);
                    const blockHours = currentSchedule.slice(blockStart, blockEnd);
                    const blockAvg = blockHours.reduce((sum, e) => sum + e.value, 0) / blockHours.length;
                    const newBlockAvg = roundToPumpIncrement(blockAvg * scaleFactor);
                    
                    for (let i = blockStart; i < blockEnd; i++) {
                        result.push({
                            ...currentSchedule[i],
                            value: newBlockAvg,
                            time: `${i.toString().padStart(2, '0')}:00`
                        });
                    }
                }
                
                // Final adjustment if total doesn't match
                const resultTotal = result.reduce((sum, e) => sum + e.value, 0);
                const finalError = targetTotalDaily - resultTotal;
                
                if (Math.abs(finalError) > 0.05) {
                    // Distribute error across hours proportionally
                    const errorPerHour = finalError / 24;
                    result.forEach(entry => {
                        entry.value = roundToPumpIncrement(entry.value + errorPerHour);
                    });
                }
                
                return result;
            };

            /**
             * DETECTOR 4: Two-Stage Basal Optimization
             * Stage 1: Safety Scrubber - Fix resistant lows (basal too high)
             * Stage 2: Circadian Scaler - Apply 35% TDD target while preserving shape
             */
            const detectBasalOptimization = (nightscoutData, basalSchedule, analysisStartDateTime, analysisWindow) => {
                console.log('=== DETECTOR 4: Two-Stage Basal Optimization ===');
                const recommendations = [];
                
                // Calculate TDD (Total Daily Dose)
                const calculateTDD = () => {
                    // Try to get TDD from iAPS deviceStatus first (preferred - uses 2-week average)
                    let iapsTDD = null;
                    let iapsTwoWeekTDD = null;
                    
                    if (nightscoutData.deviceStatus && nightscoutData.deviceStatus.length > 0) {
                        // Look through recent deviceStatus entries for TDD data
                        for (let i = 0; i < Math.min(5, nightscoutData.deviceStatus.length); i++) {
                            const status = nightscoutData.deviceStatus[i];
                            if (status.openaps && status.openaps.enacted && status.openaps.enacted.reason) {
                                const reason = status.openaps.enacted.reason;
                                
                                // Parse TDD from reason string: "TDD 28.25 2week TDD 26.53"
                                const twoWeekMatch = reason.match(/2week TDD (\d+\.?\d*)/);
                                const currentMatch = reason.match(/TDD (\d+\.?\d*)/);
                                
                                if (twoWeekMatch) {
                                    iapsTwoWeekTDD = parseFloat(twoWeekMatch[1]);
                                }
                                if (currentMatch && !iapsTDD) {
                                    iapsTDD = parseFloat(currentMatch[1]);
                                }
                                
                                if (iapsTwoWeekTDD) break; // Found 2-week average, we're done
                            }
                        }
                    }
                    
                    // Calculate multi-day average TDD as fallback (uses analysisWindow: 1, 2, 3, or 7 days)
                    const now = new Date();
                    const analysisWindowDays = analysisWindow || 1;
                    const dailyTDDs = [];
                    
                    // Calculate total basal per day from schedule
                    let totalBasalPerDay = 0;
                    basalSchedule.forEach(entry => {
                        totalBasalPerDay += entry.value; // Each entry is U/hr
                    });
                    
                    // Calculate TDD for each day in the analysis window
                    for (let day = 0; day < analysisWindowDays; day++) {
                        const dayEnd = new Date(now - (day * 24 * 60 * 60 * 1000));
                        const dayStart = new Date(dayEnd - 24 * 60 * 60 * 1000);
                        
                        let dayBolus = 0;
                        nightscoutData.treatments.forEach(t => {
                            if (!t.created_at || !t.insulin || t.insulin <= 0) return;
                            const tTime = new Date(t.created_at);
                            if (tTime >= dayStart && tTime < dayEnd) {
                                dayBolus += t.insulin;
                            }
                        });
                        
                        const dayTDD = dayBolus + totalBasalPerDay;
                        if (dayTDD > 0) dailyTDDs.push(dayTDD);
                    }
                    
                    // Calculate average
                    const calculatedTDD = dailyTDDs.length > 0 
                        ? dailyTDDs.reduce((sum, tdd) => sum + tdd, 0) / dailyTDDs.length 
                        : 0;
                    
                    // Decide which TDD to use (prefer iAPS 2-week, then current iAPS, then multi-day average)
                    let finalTDD = null;
                    let tddSource = '';
                    let warning = null;
                    
                    if (iapsTwoWeekTDD) {
                        finalTDD = iapsTwoWeekTDD;
                        tddSource = 'iAPS 2-week average';
                    } else if (iapsTDD) {
                        finalTDD = iapsTDD;
                        tddSource = 'iAPS current';
                        warning = 'Using iAPS current TDD (2-week average not found)';
                    } else if (calculatedTDD > 0) {
                        finalTDD = calculatedTDD;
                        tddSource = `calculated ${analysisWindowDays}-day average`;
                        warning = 'Ã¢Å¡Â Ã¯Â¸Â  WARNING: iAPS TDD not found in deviceStatus. Using calculated average which may be less accurate.';
                    } else {
                        // No TDD available at all
                        console.log(`  Ã¢ÂÅ’ ERROR: Cannot calculate TDD - no iAPS data and insufficient treatment data`);
                        return null;
                    }
                    
                    // Log all TDD values for comparison
                    console.log(`  TDD Sources:`);
                    console.log(`    iAPS 2-week TDD: ${iapsTwoWeekTDD ? iapsTwoWeekTDD.toFixed(2) + 'U' : 'not found'}`);
                    console.log(`    iAPS current TDD: ${iapsTDD ? iapsTDD.toFixed(2) + 'U' : 'not found'}`);
                    console.log(`    Calculated TDD (${analysisWindowDays}-day avg): ${calculatedTDD > 0 ? calculatedTDD.toFixed(2) + 'U' : 'insufficient data'}`);
                    if (dailyTDDs.length > 0) {
                        console.log(`      Daily breakdown: ${dailyTDDs.map(t => t.toFixed(1) + 'U').join(', ')}`);
                    }
                    console.log(`    Using: ${finalTDD.toFixed(2)}U (${tddSource})`);
                    if (warning) {
                        console.log(`    ${warning}`);
                    }
                    
                    return { tdd: finalTDD, source: tddSource, warning: warning };
                };
                
                // Parse IOB from deviceStatus
                const getIOBData = () => {
                    const iobData = [];
                    
                    if (nightscoutData.deviceStatus) {
                        nightscoutData.deviceStatus.forEach(status => {
                            if (status.created_at && status.iob && typeof status.iob.totalIOB !== 'undefined') {
                                iobData.push({
                                    time: new Date(status.created_at),
                                    localTime: status.created_at,
                                    totalIOB: status.iob.totalIOB,
                                    basalIOB: status.iob.basalIOB || 0,
                                    bolusIOB: status.iob.bolusIOB || 0
                                });
                            }
                        });
                    }
                    
                    console.log(`  Parsed ${iobData.length} IOB data points`);
                    return iobData;
                };
                
                // STAGE 1: Safety Scrubber
                console.log('\n  Stage 1: Safety Scrubber (Resistant Lows)');
                
                const iobData = getIOBData();
                const basalAdjustments = {}; // Track adjustments by schedule time
                
                // Find lows with negative IOB
                nightscoutData.glucose.forEach(reading => {
                    const readingTime = new Date(reading.dateString);
                    if (readingTime < analysisStartDateTime) return;
                    
                    if (reading.sgv <= 70) {
                        // Find the nearest IOB data point (within 10 minutes)
                        let nearestIOB = null;
                        let minTimeDiff = Infinity;
                        
                        iobData.forEach(iob => {
                            const timeDiff = Math.abs(iob.time - readingTime);
                            if (timeDiff < 10 * 60 * 1000 && timeDiff < minTimeDiff) {
                                minTimeDiff = timeDiff;
                                nearestIOB = iob;
                            }
                        });
                        
                        if (nearestIOB && nearestIOB.totalIOB < 0) {
                            console.log(`    Resistant low found: ${reading.localDateTime} (${reading.sgv} mg/dL) with IOB ${nearestIOB.totalIOB.toFixed(3)}U`);
                            
                            // Find basal rate active 60-90 minutes prior
                            const seventyFiveMinutesAgo = new Date(readingTime - 75 * 60 * 1000); // Middle of 60-90 min window
                            const basalEntry = getBasalForTime(seventyFiveMinutesAgo.toISOString(), basalSchedule);
                            
                            // Track the adjustment (5% reduction)
                            if (!basalAdjustments[basalEntry.time]) {
                                basalAdjustments[basalEntry.time] = {
                                    original: basalEntry.value,
                                    reductions: []
                                };
                            }
                            
                            basalAdjustments[basalEntry.time].reductions.push({
                                lowTime: reading.localDateTime,
                                lowBG: reading.sgv,
                                iob: nearestIOB.totalIOB
                            });
                            
                            console.log(`    ->Ã¢â‚¬â„¢ Marking ${basalEntry.time} basal for 5% reduction`);
                        }
                    }
                });
                
                // Apply Stage 1 reductions to the schedule
                let modifiedBasalSchedule = [...basalSchedule];
                Object.entries(basalAdjustments).forEach(([scheduleTime, adjustment]) => {
                    const idx = modifiedBasalSchedule.findIndex(entry => entry.time === scheduleTime);
                    if (idx >= 0) {
                        const oldValue = modifiedBasalSchedule[idx].value;
                        const newValue = oldValue * 0.95; // 5% reduction
                        modifiedBasalSchedule[idx] = {
                            ...modifiedBasalSchedule[idx],
                            value: newValue
                        };
                        
                        recommendations.push({
                            detector: 'Basal Optimization - Safety Scrubber',
                            type: 'Basal Reduction',
                            reason: `Resistant low(s) despite negative IOB - basal too high`,
                            scheduleTime: scheduleTime,
                            currentValue: oldValue,
                            newValue: parseFloat(newValue.toFixed(3)),
                            adjustment: '-5%',
                            calculation: `${oldValue.toFixed(3)} * 0.95 = ${newValue.toFixed(3)}`,
                            details: `${adjustment.reductions.length} resistant low(s): ${adjustment.reductions.map(r => 
                                `${r.lowBG} mg/dL at ${r.lowTime} (IOB: ${r.iob.toFixed(2)}U)`
                            ).join(', ')}`,
                            confidence: { level: 'High', score: 95 },
                            priority: 'HIGH',
                            safetyNote: 'System removed insulin but low still occurred - definite basal excess'
                        });
                    }
                });
                
                console.log(`  Stage 1 complete: ${Object.keys(basalAdjustments).length} safety reductions applied`);
                
                // STAGE 2: Enhanced Circadian Scaler with Hourly Distribution
                console.log('\n  Stage 2: Enhanced Circadian Scaler (35% TDD Target)');
                
                const tddResult = calculateTDD();
                
                // Skip basal optimization if TDD cannot be calculated
                if (!tddResult || !tddResult.tdd) {
                    console.log(`  Ã¢Å¡Â Ã¯Â¸Â  Stage 2 skipped: TDD data unavailable`);
                    console.log(`  Note: Basal optimization requires iAPS TDD from deviceStatus or sufficient treatment history`);
                    console.log(`\nDetector 4 complete: ${recommendations.length} basal recommendations`);
                    return recommendations;
                }
                
                const tdd = tddResult.tdd;
                const tddSource = tddResult.source;
                const tddWarning = tddResult.warning;
                
                const targetTotalBasal = tdd * 0.35;
                
                // Apply safety limits (max 10% change from current total)
                let currentTotalBasal = modifiedBasalSchedule.reduce((sum, e) => sum + e.value, 0);
                const maxChange = currentTotalBasal * 0.10;
                const cappedTargetBasal = Math.max(
                    currentTotalBasal - maxChange,
                    Math.min(currentTotalBasal + maxChange, targetTotalBasal)
                );
                
                console.log(`  Current total basal: ${currentTotalBasal.toFixed(2)}U`);
                console.log(`  Target total basal (35% of TDD): ${targetTotalBasal.toFixed(2)}U`);
                if (cappedTargetBasal !== targetTotalBasal) {
                    console.log(`  Capped to 10% change: ${cappedTargetBasal.toFixed(2)}U`);
                }
                if (tddWarning) {
                    console.log(`  ${tddWarning}`);
                }
                
                // Get the distributed hourly schedule
                const distributedSchedule = distributeBasalAdjustment(modifiedBasalSchedule, cappedTargetBasal);
                
                // Analyze the pattern change
                const oldPattern = analyzeBasalPattern(modifiedBasalSchedule);
                const newPattern = analyzeBasalPattern(distributedSchedule);
                
                // Create detailed hourly recommendations
                const hourlyChanges = [];
                distributedSchedule.forEach((newEntry, idx) => {
                    const oldEntry = modifiedBasalSchedule[idx];
                    const change = newEntry.value - oldEntry.value;
                    if (Math.abs(change) > 0.001) {
                        hourlyChanges.push({
                            hour: newEntry.time,
                            oldValue: oldEntry.value,
                            newValue: newEntry.value,
                            change: change
                        });
                    }
                });
                
                // Create comprehensive recommendation
                if (Math.abs(cappedTargetBasal - currentTotalBasal) > 0.05) {
                    const percentChange = ((cappedTargetBasal - currentTotalBasal) / currentTotalBasal * 100).toFixed(1);
                    const direction = cappedTargetBasal > currentTotalBasal ? 'increase' : 'decrease';
                    
                    // Build hourly schedule display
                    let hourlyDisplay = 'Hourly Distribution:\n';
                    for (let i = 0; i < 24; i++) {
                        const old = modifiedBasalSchedule[i].value.toFixed(3);
                        const neu = distributedSchedule[i].value.toFixed(3);
                        const change = (distributedSchedule[i].value - modifiedBasalSchedule[i].value).toFixed(3);
                        const changeStr = change > 0 ? `+${change}` : change == 0 ? ' 0.000' : change;
                        hourlyDisplay += `  ${i.toString().padStart(2, '0')}:00  ${old} -> ${neu} (${changeStr})\n`;
                    }
                    
                    recommendations.push({
                        detector: 'Basal Optimization - Enhanced Circadian Scaler',
                        type: 'Basal Hourly Distribution',
                        reason: `Total basal ${direction} to reach 35% TDD target with intelligent hourly distribution`,
                        scheduleTime: 'ALL',
                        currentValue: currentTotalBasal,
                        newValue: parseFloat(cappedTargetBasal.toFixed(2)),
                        adjustment: `${percentChange > 0 ? '+' : ''}${percentChange}%`,
                        calculation: `Pattern: ${oldPattern.type} -> ${newPattern.type}`,
                        details: `TDD: ${tdd.toFixed(2)}U (${tddSource}) -> Target: ${targetTotalBasal.toFixed(2)}U (35% of TDD)\n` +
                                 `Current Total: ${currentTotalBasal.toFixed(2)}U -> New Total: ${cappedTargetBasal.toFixed(2)}U\n` +
                                 `${hourlyChanges.length} hours adjusted\n\n${hourlyDisplay}`,
                        confidence: { level: tddWarning ? 'Medium' : 'High', score: tddWarning ? 70 : 85 },
                        priority: 'MEDIUM',
                        hourlySchedule: distributedSchedule,
                        patternAnalysis: {
                            before: oldPattern,
                            after: newPattern
                        },
                        ...(tddWarning && { safetyNote: tddWarning })
                    });
                    
                    console.log(`  Stage 2 complete: ${percentChange}% ${direction} with ${newPattern.type} pattern`);
                } else {
                    console.log(`  Stage 2 complete: No adjustment needed (already close to target)`);
                }
                
                
                console.log(`\nDetector 4 complete: ${recommendations.length} basal recommendations`);
                return recommendations;
            };

            /**
             * DETECTOR 5: Regular Lows (Catch-all)
             * Priority: 5 (Lowest)
             * Pattern: Any unclaimed lows
             * Conclusion: General CR issue
             */
            const detectRegularLows = (lowProblems, nightscoutData, crSchedule, claimedEvents, processedLowIds) => {
                console.log('=== DETECTOR 5: Regular Lows (Catch-all) ===');
                const recommendations = [];
                
                lowProblems.forEach(low => {
                    const lowId = getEventId(low);
                    
                    // Skip if this low was already claimed
                    if (claimedEvents.lows.has(lowId)) {
                        console.log(`Skipping claimed low: ${low.localTime}`);
                        return;
                    }
                    
                    // Skip if this low was already processed (got a recommendation from Detectors 1-3)
                    if (processedLowIds.has(lowId)) {
                        console.log(`Skipping already processed low: ${low.localTime}`);
                        return;
                    }
                    
                    const lowTime = new Date(low.time);
                    const eightHoursAgo = new Date(lowTime - 8 * 60 * 60 * 1000);
                    const threeHoursAgo = new Date(lowTime - 3 * 60 * 60 * 1000);
                    
                    // Find the most recent meal
                    let relevantMeal = null;
                    for (let treatment of nightscoutData.treatments) {
                        if (!treatment.created_at || !treatment.carbs || treatment.carbs <= 0) continue;
                        
                        const treatmentTime = new Date(treatment.created_at);
                        if (treatmentTime <= lowTime && treatmentTime >= eightHoursAgo) {
                            if (!relevantMeal || treatmentTime > new Date(relevantMeal.localDateTime)) {
                                relevantMeal = treatment;
                            }
                        }
                    }
                    
                    // Determine CR schedule
                    let timeForCR;
                    if (relevantMeal) {
                        timeForCR = relevantMeal.localDateTime;
                    } else {
                        // Look back 3 hours
                        timeForCR = threeHoursAgo.toISOString();
                    }
                    const crEntry = getCRForTime(timeForCR, crSchedule);
                    
                    // Claim the low
                    claimedEvents.lows.add(lowId);
                    if (relevantMeal) {
                        claimedEvents.meals.add(getEventId(relevantMeal));
                    }
                    
                    const adjustmentPercent = low.bg < 55 ? 7.5 : 5;
                    const newCR = crEntry.value * (1 + adjustmentPercent / 100);
                    
                    recommendations.push({
                        detector: 'Regular Low (Catch-all)',
                        type: 'CR Weakening',
                        reason: 'Low without clear specific cause',
                        scheduleTime: crEntry.time,
                        currentValue: crEntry.value,
                        newValue: parseFloat(newCR.toFixed(2)),
                        adjustment: `+${adjustmentPercent}%`,
                        calculation: `${crEntry.value} [WARNING]Ã‚Â ${(1 + adjustmentPercent / 100).toFixed(2)} = ${newCR.toFixed(2)}`,
                        details: `Low ${low.bg} mg/dL at ${low.localTime}${relevantMeal ? `, possible meal at ${relevantMeal.localDateTime}` : ''}`,
                        confidence: { level: relevantMeal ? 'Medium' : 'Low', score: relevantMeal ? 60 : 40 },
                        priority: 'LOW',
                        events: [low]
                    });
                    
                    console.log(`[WARNING]Ã‚Â¦ Found regular low: ${low.localTime}`);
                });
                
                console.log(`Detector 5 complete: ${recommendations.length} recommendations`);
                return recommendations;
            };

            // ===== SECTION 3: ORCHESTRATION =====
            
            const runAllDetectors = (nightscoutData, crSchedule, isfSchedule, basalSchedule, analysisStartDateTime, analysisWindow) => {
                console.log('\n========== RUNNING MULTI-DETECTOR ANALYSIS ==========\n');
                
                // Initialize event claiming system
                const claimedEvents = {
                    lows: new Set(),
                    meals: new Set(),
                    corrections: new Set(),
                    highs: new Set()
                };
                
                // Track which lows got recommendations (not just claimed)
                const processedLowIds = new Set();
                
                // Step 1: Identify all low problems (like v23)
                const lowProblems = [];
                nightscoutData.glucose.forEach((reading) => {
                    const readingTime = new Date(reading.dateString);
                    if (readingTime < analysisStartDateTime) return;
                    
                    if (reading.sgv <= 70) {
                        const severity = reading.sgv < 55 ? 'severe' : 
                                       reading.sgv < 65 ? 'moderate' : 'minor';
                        lowProblems.push({
                            time: reading.dateString,
                            localTime: reading.localDateTime,
                            bg: reading.sgv,
                            severity
                        });
                    }
                });
                
                console.log(`Found ${lowProblems.length} total lows\n`);
                
                // Run detectors in priority order
                const allRecommendations = [];
                
                // Detector 1b: Transient High with Subsequent Low (Priority 1 - Safety, More Specific)
                const detector1bResults = detectTransientHighWithLow(
                    lowProblems, nightscoutData, crSchedule, claimedEvents, processedLowIds
                );
                allRecommendations.push(...detector1bResults);
                
                // Detector 1: Direct Meal-Induced Lows (Priority 1.5 - Safety, Less Specific)
                const detector1Results = detectDirectMealInducedLows(
                    lowProblems, nightscoutData, crSchedule, claimedEvents, processedLowIds
                );
                allRecommendations.push(...detector1Results);
                
                // Detector 2: Correction Overcorrection (Priority 2 - ISF)
                const detector2Results = detectCorrectionOvercorrection(
                    lowProblems, nightscoutData, isfSchedule, claimedEvents, processedLowIds
                );
                allRecommendations.push(...detector2Results);
                
                // Detector 3: Post-Meal Highs with Corrections (Priority 3 - CR weakness)
                const detector3Results = detectPostMealHighsWithCorrections(
                    lowProblems, nightscoutData, crSchedule, claimedEvents, processedLowIds
                );
                allRecommendations.push(...detector3Results);
                
                // Detector 4: Two-Stage Basal Optimization (Priority 4)
                const detector4Results = detectBasalOptimization(
                    nightscoutData, basalSchedule, analysisStartDateTime, analysisWindow
                );
                allRecommendations.push(...detector4Results);
                
                // Detector 5: Regular Lows (Priority 5 - Catch-all)
                const detector5Results = detectRegularLows(
                    lowProblems, nightscoutData, crSchedule, claimedEvents, processedLowIds
                );
                allRecommendations.push(...detector5Results);
                
                // Schedule Boundary Analysis: Identify timing mismatches
                const scheduleBoundaryResults = detectScheduleBoundaryIssues(
                    nightscoutData, crSchedule, lowProblems
                );
                allRecommendations.push(...scheduleBoundaryResults);
                
                console.log('\n========== DETECTION COMPLETE ==========');
                console.log(`Total recommendations: ${allRecommendations.length}`);
                console.log(`Claimed lows: ${claimedEvents.lows.size}/${lowProblems.length}`);
                console.log(`Claimed meals: ${claimedEvents.meals.size}`);
                console.log(`Claimed corrections: ${claimedEvents.corrections.size}`);
                console.log(`Claimed highs: ${claimedEvents.highs.size}\n`);
                
                return allRecommendations;
            };

            const aggregateRecommendations = (recommendations) => {
                // Group by schedule time and type
                const grouped = {};
                
                recommendations.forEach(rec => {
                    const key = `${rec.scheduleTime}_${rec.type}`;
                    if (!grouped[key]) {
                        grouped[key] = [];
                    }
                    grouped[key].push(rec);
                });
                
                // For each group, create aggregated recommendation
                const aggregated = Object.values(grouped).map(group => {
                    if (group.length === 1) {
                        return group[0];
                    }
                    
                    // Multiple recommendations for same schedule/type
                    // Use the one with highest confidence
                    const sorted = group.sort((a, b) => b.confidence.score - a.confidence.score);
                    const primary = sorted[0];
                    
                    return {
                        ...primary,
                        details: `${primary.details}\n\nNote: ${group.length} similar patterns detected at this schedule time.`,
                        multipleDetections: group.length
                    };
                });
                
                return aggregated;
            };

            const detectConflicts = (recommendations) => {
                // Check for conflicting recommendations at same schedule time
                const bySchedule = {};
                recommendations.forEach(rec => {
                    if (!bySchedule[rec.scheduleTime]) {
                        bySchedule[rec.scheduleTime] = [];
                    }
                    bySchedule[rec.scheduleTime].push(rec);
                });
                
                const conflicts = [];
                Object.entries(bySchedule).forEach(([scheduleTime, recs]) => {
                    if (recs.length > 1) {
                        const types = recs.map(r => r.type);
                        const hasWeakening = types.some(t => t.includes('Weakening'));
                        const hasStrengthening = types.some(t => t.includes('Strengthening'));
                        
                        if (hasWeakening && hasStrengthening) {
                            conflicts.push({
                                scheduleTime,
                                recommendations: recs,
                                type: 'opposing'
                            });
                        }
                    }
                });
                
                return conflicts;
            };

            const sortByPriority = (recommendations) => {
                const priorityOrder = { HIGH: 0, MEDIUM: 1, LOW: 2 };
                return recommendations.sort((a, b) => {
                    const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
                    if (priorityDiff !== 0) return priorityDiff;
                    // Within same priority, sort by confidence
                    return b.confidence.score - a.confidence.score;
                });
            };

            // ===== MAIN ANALYSIS FUNCTION =====
            
            const runAnalysis = async () => {
                setAnalyzing(true);
                setError(null);
                
                try {
                    console.log('Starting v24 Multi-Detector Analysis...', nightscoutData);
                    
                    if (!nightscoutData || !nightscoutData.glucose) {
                        throw new Error('No glucose data available');
                    }
                    
                    // Get analysis window boundaries
                    const analysisStartTime = nightscoutData.exportInfo?.analysisStartTime;
                    let analysisStartDateTime;
                    if (analysisStartTime) {
                        analysisStartDateTime = new Date(analysisStartTime);
                        console.log('Analysis window:', analysisStartTime, 'to now');
                    } else {
                        analysisStartDateTime = new Date(0);
                        console.log('No analysis window specified, analyzing all data');
                    }
                    
                    // Extract profile data
                    let crSchedule = [];
                    let isfSchedule = [];
                    let basalSchedule = [];
                    
                    if (nightscoutData.profile && nightscoutData.profile.length > 0) {
                        const profile = nightscoutData.profile[0];
                        if (profile.store && profile.store.default) {
                            crSchedule = profile.store.default.carbratio || [];
                            isfSchedule = profile.store.default.sens || [];
                            basalSchedule = profile.store.default.basal || [];
                        }
                    }
                    
                    console.log('CR Schedule:', crSchedule);
                    console.log('ISF Schedule:', isfSchedule);
                    console.log('Basal Schedule:', basalSchedule);
                    
                    // Run all detectors
                    const allRecommendations = runAllDetectors(
                        nightscoutData, 
                        crSchedule, 
                        isfSchedule, 
                        basalSchedule, 
                        analysisStartDateTime, 
                        analysisWindow
                    );
                    
                    // Aggregate recommendations
                    const aggregated = aggregateRecommendations(allRecommendations);
                    
                    // Detect conflicts
                    const conflicts = detectConflicts(aggregated);
                    
                    // Sort by priority
                    const sorted = sortByPriority(aggregated);
                    
                    // Build results object
                    const results = {
                        recommendations: sorted,
                        conflicts: conflicts,
                        summary: {
                            totalRecommendations: sorted.length,
                            byType: {
                                crWeakening: sorted.filter(r => r.type === 'CR Weakening').length,
                                crStrengthening: sorted.filter(r => r.type === 'CR Strengthening').length,
                                isfWeakening: sorted.filter(r => r.type === 'ISF Weakening').length,
                                isfStrengthening: sorted.filter(r => r.type === 'ISF Strengthening').length,
                                informational: sorted.filter(r => r.type === 'Informational').length
                            },
                            byPriority: {
                                high: sorted.filter(r => r.priority === 'HIGH').length,
                                medium: sorted.filter(r => r.priority === 'MEDIUM').length,
                                low: sorted.filter(r => r.priority === 'LOW').length,
                                informational: sorted.filter(r => r.priority === 'INFORMATIONAL').length
                            }
                        },
                        crSchedule,
                        isfSchedule,
                        basalSchedule
                    };
                    
                    console.log('Analysis complete:', results);
                    setAnalysisResults(results);
                    
                } catch (err) {
                    console.error('Analysis error:', err);
                    setError(err.message);
                } finally {
                    setAnalyzing(false);
                }
            };

            // ===== DATA LOADING FUNCTIONS =====
            
            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        console.log('Loaded Nightscout data:', data);
                        setNightscoutData(data);
                        setError(null);
                    } catch (err) {
                        setError('Invalid JSON file: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };

            // Helper function to try multiple authentication methods (from v22)
            const fetchNightscoutData = async (baseUrl, endpoint, params) => {
                const url = new URL(baseUrl + endpoint);
                Object.keys(params).forEach(key => {
                    if (params[key]) url.searchParams.append(key, params[key]);
                });
                
                // Try multiple authentication methods in order
                const authMethods = [
                    // Method 1: Token as URL parameter (most reliable)
                    (() => {
                        const urlCopy = new URL(url.toString());
                        if (nsConfig.token) urlCopy.searchParams.append('token', nsConfig.token);
                        return { url: urlCopy };
                    })(),
                    // Method 2: api-secret header
                    { headers: { 'api-secret': nsConfig.apiSecret } },
                    // Method 3: Bearer token header
                    { headers: { 'Authorization': `Bearer ${nsConfig.apiSecret}` } }
                ];
                
                for (const method of authMethods) {
                    try {
                        const fetchUrl = method.url || url;
                        const response = await fetch(fetchUrl.toString(), {
                            method: 'GET',
                            headers: { 'Accept': 'application/json', ...method.headers }
                        });
                        if (response.ok) return await response.json();
                    } catch (error) {
                        console.log(`Auth method failed:`, error.message);
                    }
                }
                throw new Error(`Failed to fetch ${endpoint}`);
            };

            const fetchFromNightscout = async (days = analysisWindow) => {
                setLoading(true);
                setError(null);
                setFetchStatus('[WARNING]Ã‚Â¾ Connecting to Nightscout...');
                
                try {
                    if (!nsConfig.baseUrl) throw new Error('Please enter your Nightscout URL');
                    
                    const baseUrl = nsConfig.baseUrl.replace(/\/$/, '');
                    const endTime = new Date();
                    // Collect 30 hours of data for context, but analyze only last 24 hours
                    const collectionHours = 30;
                    const analysisHours = 24;
                    const collectionStartDate = new Date(endTime.getTime() - (collectionHours * 60 * 60 * 1000));
                    const analysisStartDate = new Date(endTime.getTime() - (analysisHours * 60 * 60 * 1000));
                    const dateString = collectionStartDate.toISOString();
                    
                    setFetchStatus(`Fetching ${collectionHours}-hour data (analyzing last ${analysisHours} hours)...`);
                    
                    // Fetch all data in parallel
                    const [entries, treatments, profile, deviceStatus] = await Promise.all([
                        fetchNightscoutData(baseUrl, '/api/v1/entries.json', { 
                            count: Math.ceil(collectionHours / 24 * 600),
                            'find[dateString][$gte]': dateString 
                        }),
                        fetchNightscoutData(baseUrl, '/api/v1/treatments.json', { 
                            count: 2000,  // Match export tool's large net to capture all SMBs
                            'find[created_at][$gte]': dateString 
                        }),
                        fetchNightscoutData(baseUrl, '/api/v1/profile.json', {}).catch(() => []),
                        fetchNightscoutData(baseUrl, '/api/v1/devicestatus.json', { 
                            count: 100,  // Get recent deviceStatus entries
                            'find[created_at][$gte]': dateString 
                        }).catch(() => [])
                    ]);
                    
                    console.log('Fetched:', entries.length, 'glucose entries');
                    console.log('Fetched:', treatments.length, 'treatments');
                    console.log('Profile:', profile?.length || 0);
                    console.log('DeviceStatus:', deviceStatus?.length || 0);
                    
                    // SMART TREATMENT PRIORITIZATION (from working export tool)
                    console.log('Applying smart treatment prioritization...');
                    
                    // Step 1: Separate by priority (3-tier system)
                    const manualTreatments = treatments.filter(t => 
                        t.carbs > 0 || 
                        (t.eventType === 'Bolus' && t.insulin >= 0.1) ||
                        t.eventType === 'Correction'
                    );
                    const smbTreatments = treatments.filter(t => 
                        t.eventType === 'SMB' && t.insulin > 0
                    );
                    const otherAutomatedTreatments = treatments.filter(t => 
                        t.carbs === 0 && 
                        !['Bolus', 'Correction', 'SMB'].includes(t.eventType)
                    );
                    
                    console.log(`Manual treatments: ${manualTreatments.length} (ALL will be included)`);
                    console.log(`SMB treatments: ${smbTreatments.length} (ALL will be included)`);
                    console.log(`Other automated: ${otherAutomatedTreatments.length} (limited to 100)`);
                    
                    // Step 2: Smart combining - ALL manual + ALL SMBs + limited other automated
                    const combinedTreatments = [
                        ...manualTreatments,           // ALL manual entries
                        ...smbTreatments,              // ALL SMBs (CRITICAL!)
                        ...otherAutomatedTreatments.slice(0, 100)  // Limited other
                    ];
                    
                    console.log(`Combined treatments: ${combinedTreatments.length} total`);
                    
                    // Deduplicate glucose readings
                    const deduplicatedGlucose = [];
                    const seenTimes = new Set();
                    
                    for (const entry of entries) {
                        const timeKey = Math.floor(new Date(entry.dateString).getTime() / 60000);
                        if (!seenTimes.has(timeKey)) {
                            seenTimes.add(timeKey);
                            deduplicatedGlucose.push(entry);
                        }
                    }
                    
                    console.log('After deduplication:', deduplicatedGlucose.length, 'unique glucose entries');
                    
                    // Add localDateTime to glucose (matching export format)
                    const glucoseWithLocal = deduplicatedGlucose.map(e => {
                        const date = new Date(e.dateString);
                        const year = date.getFullYear();
                        const month = String(date.getMonth() + 1).padStart(2, '0');
                        const day = String(date.getDate()).padStart(2, '0');
                        const hours = String(date.getHours()).padStart(2, '0');
                        const minutes = String(date.getMinutes()).padStart(2, '0');
                        const seconds = String(date.getSeconds()).padStart(2, '0');
                        const localDateTimeStr = `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
                        
                        return {
                            ...e,
                            localDateTime: localDateTimeStr
                        };
                    });
                    
                    // Add localDateTime to treatments (use combinedTreatments instead of raw treatments)
                    const treatmentsWithLocal = combinedTreatments.map(t => {
                        const date = new Date(t.created_at);
                        const year = date.getFullYear();
                        const month = String(date.getMonth() + 1).padStart(2, '0');
                        const day = String(date.getDate()).padStart(2, '0');
                        const hours = String(date.getHours()).padStart(2, '0');
                        const minutes = String(date.getMinutes()).padStart(2, '0');
                        const seconds = String(date.getSeconds()).padStart(2, '0');
                        const localDateTimeStr = `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
                        
                        return {
                            ...t,
                            localDateTime: localDateTimeStr
                        };
                    });
                    
                    const exportData = {
                        exportInfo: {
                            timestamp: endTime.toISOString(),
                            collectionStartTime: collectionStartDate.toISOString(),
                            analysisStartTime: analysisStartDate.toISOString(),
                            collectionHours: collectionHours,
                            analysisHours: analysisHours,
                            dataPoints: {
                                glucose: deduplicatedGlucose.length,
                                treatments: combinedTreatments.length,
                                deviceStatus: deviceStatus?.length || 0
                            }
                        },
                        glucose: glucoseWithLocal,
                        treatments: treatmentsWithLocal,
                        profile: profile,
                        deviceStatus: deviceStatus || []
                    };
                    
                    console.log('Nightscout data prepared:', exportData);
                    setNightscoutData(exportData);
                    setFetchStatus('[WARNING]Ã‚Â¦ Data loaded successfully!');
                    
                } catch (err) {
                    console.error('Fetch error:', err);
                    setError('Failed to fetch from Nightscout: ' + err.message);
                    setFetchStatus('');
                } finally {
                    setLoading(false);
                }
            };

            // ===== SECTION 4: UI RENDERING =====
            
            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-6">
                    <div className="max-w-6xl mx-auto">
                        {/* Header */}
                        <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                            <div className="flex items-center gap-3 mb-2">
                                <Activity />
                                <h1 className="text-3xl font-bold text-gray-800">
                                    iAPS Parameter Optimizer
                                </h1>
                                <span className="px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm font-semibold">
                                    v24 Multi-Detector + 1b
                                </span>
                            </div>
                            <p className="text-gray-600">
                                Advanced multi-detector system for CR and ISF optimization
                            </p>
                        </div>

                        {/* Data Source Selection */}
                        <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                            <h2 className="text-xl font-semibold mb-4 flex items-center gap-2">
                                <Server />
                                Data Source
                            </h2>
                            
                            <div className="grid md:grid-cols-2 gap-6">
                                {/* File Upload */}
                                <div className="border-2 border-dashed border-gray-300 rounded-lg p-6 hover:border-blue-500 transition-colors">
                                    <h3 className="font-semibold mb-2">Upload JSON File</h3>
                                    <p className="text-sm text-gray-600 mb-4">
                                        Upload Nightscout export data
                                    </p>
                                    <input
                                        type="file"
                                        accept=".json"
                                        onChange={handleFileUpload}
                                        className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
                                    />
                                </div>

                                {/* Nightscout Fetch */}
                                <div className="border-2 border-gray-300 rounded-lg p-6">
                                    <h3 className="font-semibold mb-2">Fetch from Nightscout</h3>
                                    
                                    <div className="space-y-3 mb-4">
                                        <input
                                            type="text"
                                            placeholder="Nightscout URL"
                                            value={nsConfig.baseUrl}
                                            onChange={(e) => updateNsConfig({...nsConfig, baseUrl: e.target.value})}
                                            className="w-full px-3 py-2 border rounded-lg text-sm"
                                        />
                                        
                                        <input
                                            type="text"
                                            placeholder="API Secret"
                                            value={nsConfig.apiSecret}
                                            onChange={(e) => updateNsConfig({...nsConfig, apiSecret: e.target.value})}
                                            className="w-full px-3 py-2 border rounded-lg text-sm"
                                        />
                                        
                                        <input
                                            type="text"
                                            placeholder="Token (optional)"
                                            value={nsConfig.token}
                                            onChange={(e) => updateNsConfig({...nsConfig, token: e.target.value})}
                                            className="w-full px-3 py-2 border rounded-lg text-sm"
                                        />
                                        
                                        <select
                                            value={analysisWindow}
                                            onChange={(e) => setAnalysisWindow(Number(e.target.value))}
                                            className="w-full px-3 py-2 border rounded-lg text-sm"
                                        >
                                            <option value={1}>Last 24 hours</option>
                                            <option value={2}>Last 48 hours</option>
                                            <option value={3}>Last 3 days</option>
                                            <option value={7}>Last 7 days</option>
                                        </select>
                                    </div>
                                    
                                    <button
                                        onClick={fetchFromNightscout}
                                        disabled={loading}
                                        className="w-full bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold hover:bg-blue-700 disabled:bg-gray-400"
                                    >
                                        {loading ? 'Fetching...' : 'Fetch Data'}
                                    </button>
                                    
                                    {fetchStatus && (
                                        <p className="text-sm text-gray-600 mt-2">{fetchStatus}</p>
                                    )}
                                </div>
                            </div>
                        </div>

                        {/* Data Status */}
                        {nightscoutData && (
                            <div className="bg-green-50 border border-green-200 rounded-lg p-4 mb-6">
                                <p className="text-green-800">
                                    [WARNING]Ã‚Â¬Ã¢â€ â€˜ Data loaded: {nightscoutData.glucose?.length || 0} glucose readings, 
                                    {' '}{nightscoutData.treatments?.length || 0} treatments
                                </p>
                            </div>
                        )}

                        {/* Error Display */}
                        {error && (
                            <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
                                <p className="text-red-800">{error}</p>
                            </div>
                        )}

                        {/* Analysis Button */}
                        {nightscoutData && (
                            <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                                <button
                                    onClick={runAnalysis}
                                    disabled={analyzing}
                                    className="w-full bg-indigo-600 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:bg-indigo-700 disabled:bg-gray-400"
                                >
                                    {analyzing ? 'Analyzing...' : 'Run Multi-Detector Analysis'}
                                </button>
                            </div>
                        )}

                        {/* Results */}
                        {analysisResults && (
                            <>
                                {/* Summary */}
                                <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                                    <h2 className="text-2xl font-bold mb-4">Analysis Summary</h2>
                                    <div className="grid md:grid-cols-3 gap-4">
                                        <div className="bg-blue-50 p-4 rounded-lg">
                                            <div className="text-3xl font-bold text-blue-600">
                                                {analysisResults.summary.totalRecommendations}
                                            </div>
                                            <div className="text-sm text-gray-600">Total Recommendations</div>
                                        </div>
                                        <div className="bg-red-50 p-4 rounded-lg">
                                            <div className="text-3xl font-bold text-red-600">
                                                {analysisResults.summary.byPriority.high}
                                            </div>
                                            <div className="text-sm text-gray-600">High Priority (Safety)</div>
                                        </div>
                                        <div className="bg-green-50 p-4 rounded-lg">
                                            <div className="text-3xl font-bold text-green-600">
                                                {analysisResults.summary.byType.crWeakening}
                                            </div>
                                            <div className="text-sm text-gray-600">CR Weakening</div>
                                        </div>
                                    </div>
                                </div>

                                {/* Conflicts Warning */}
                                {analysisResults.conflicts && analysisResults.conflicts.length > 0 && (
                                    <div className="bg-yellow-50 border-2 border-yellow-400 rounded-lg p-6 mb-6">
                                        <h3 className="text-lg font-bold text-yellow-800 mb-2">
                                            [WARNING]Ã‚Â Conflicting Recommendations Detected
                                        </h3>
                                        <p className="text-yellow-700 mb-4">
                                            Multiple patterns detected at the same schedule time. Review carefully.
                                        </p>
                                        {analysisResults.conflicts.map((conflict, idx) => (
                                            <div key={idx} className="bg-white p-3 rounded mb-2">
                                                <strong>Schedule {conflict.scheduleTime}:</strong>
                                                <ul className="list-disc list-inside mt-1">
                                                    {conflict.recommendations.map((rec, ridx) => (
                                                        <li key={ridx}>{rec.type} ({rec.detector})</li>
                                                    ))}
                                                </ul>
                                            </div>
                                        ))}
                                    </div>
                                )}

                                {/* Recommendations */}
                                <div className="space-y-4">
                                    {analysisResults.recommendations.map((rec, idx) => (
                                        <div key={idx} className="bg-white rounded-lg shadow-lg p-6">
                                            <div className="flex justify-between items-start mb-4">
                                                <div>
                                                    <div className="flex items-center gap-3 mb-2">
                                                        <h3 className="text-xl font-bold text-gray-800">
                                                            {rec.type} @ {rec.scheduleTime}
                                                        </h3>
                                                        <ConfidenceBadge 
                                                            level={rec.confidence.level} 
                                                            score={rec.confidence.score} 
                                                        />
                                                        <span className={`px-2 py-1 rounded text-xs font-bold ${
                                                            rec.priority === 'HIGH' ? 'bg-red-100 text-red-800' :
                                                            rec.priority === 'MEDIUM' ? 'bg-yellow-100 text-yellow-800' :
                                                            rec.priority === 'INFORMATIONAL' ? 'bg-blue-100 text-blue-800' :
                                                            'bg-gray-100 text-gray-800'
                                                        }`}>
                                                            {rec.priority}
                                                        </span>
                                                    </div>
                                                    <p className="text-sm text-gray-500 mb-1">
                                                        Detected by: {rec.detector}
                                                    </p>
                                                    <p className="text-gray-600">{rec.reason}</p>
                                                </div>
                                                <div className="text-right">
                                                    <div className="text-2xl font-bold text-indigo-600">
                                                        {rec.adjustment}
                                                    </div>
                                                    <div className="text-sm text-gray-500">
                                                        {rec.currentValue} [WARNING]Ã‚Â¢ {rec.newValue}
                                                    </div>
                                                </div>
                                            </div>

                                            <div className="bg-gray-50 rounded-lg p-4 mb-4">
                                                <p className="text-sm text-gray-700 whitespace-pre-line">
                                                    {rec.details}
                                                </p>
                                            </div>

                                            {rec.safetyNote && (
                                                <div className="bg-red-50 border border-red-200 rounded-lg p-3 mb-4">
                                                    <p className="text-sm text-red-800">
                                                        <strong>[WARNING]Ã‚Â Safety Note:</strong> {rec.safetyNote}
                                                    </p>
                                                </div>
                                            )}

                                            <div className="text-sm text-gray-500">
                                                <strong>Calculation:</strong> {rec.calculation}
                                            </div>

                                            {rec.multipleDetections && (
                                                <div className="mt-3 text-sm text-blue-600">
                                                    [WARNING]Ã‚Â {rec.multipleDetections} similar patterns detected
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>

                                {/* CR Schedule Reference */}
                                <div className="bg-white rounded-lg shadow-lg p-6 mt-6">
                                    <h3 className="text-lg font-semibold mb-3">Current CR Schedule</h3>
                                    <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                                        {analysisResults.crSchedule.map((entry, idx) => (
                                            <div key={idx} className="bg-gray-50 p-3 rounded">
                                                <div className="font-semibold">{entry.time}</div>
                                                <div className="text-sm text-gray-600">{entry.value} g/U</div>
                                            </div>
                                        ))}
                                    </div>
                                </div>

                                {/* ISF Schedule Reference */}
                                <div className="bg-white rounded-lg shadow-lg p-6 mt-6">
                                    <h3 className="text-lg font-semibold mb-3">Current ISF Schedule</h3>
                                    <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                                        {analysisResults.isfSchedule.map((entry, idx) => (
                                            <div key={idx} className="bg-gray-50 p-3 rounded">
                                                <div className="font-semibold">{entry.time}</div>
                                                <div className="text-sm text-gray-600">{entry.value} mg/dL per U</div>
                                            </div>
                                        ))}
                                    </div>
                                </div>

                                {/* Basal Schedule Analysis */}
                                <div className="bg-white rounded-lg shadow-lg p-6 mt-6">
                                    <h3 className="text-lg font-semibold mb-3">Basal Schedule Analysis</h3>
                                    
                                    {(() => {
                                        const basalRec = analysisResults.recommendations.find(r => 
                                            r.type === 'Basal Hourly Distribution'
                                        );
                                        
                                        if (basalRec && basalRec.hourlySchedule) {
                                            return (
                                                <div>
                                                    <div className="mb-4 p-3 bg-blue-50 rounded">
                                                        <p className="text-sm">Pattern: {basalRec.patternAnalysis.before.type} Ã¢â€ â€™ {basalRec.patternAnalysis.after.type}</p>
                                                        <p className="text-sm">Total: {basalRec.currentValue.toFixed(2)} Ã¢â€ â€™ {basalRec.newValue.toFixed(2)} U/day</p>
                                                    </div>
                                                    
                                                    {basalRec.safetyNote && (
                                                        <div className="mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded">
                                                            <p className="text-sm text-yellow-800">{basalRec.safetyNote}</p>
                                                        </div>
                                                    )}
                                                    
                                                    <div className="grid grid-cols-6 gap-2 text-xs">
                                                        {basalRec.hourlySchedule.map((entry, idx) => {
                                                            const current = analysisResults.basalSchedule[idx];
                                                            const changed = Math.abs(entry.value - current.value) > 0.001;
                                                            return (
                                                                <div key={idx} className={`p-2 rounded ${changed ? 'bg-yellow-50 border border-yellow-200' : 'bg-gray-50'}`}>
                                                                    <div className="font-semibold">{entry.time}</div>
                                                                    <div className={changed ? 'text-red-500 line-through' : ''}>{current.value.toFixed(3)}</div>
                                                                    {changed && <div className="text-green-600">{entry.value.toFixed(3)}</div>}
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                </div>
                                            );
                                        } else {
                                            // Show current schedule only
                                            const totalBasal = analysisResults.basalSchedule.reduce((sum, e) => sum + e.value, 0);
                                            return (
                                                <div>
                                                    <div className="mb-4 p-3 bg-green-50 rounded">
                                                        <p className="text-sm text-green-800">Ã¢Å“â€œ No basal adjustment recommended - current schedule is well-optimized</p>
                                                        <p className="text-sm text-gray-600">Total: {totalBasal.toFixed(2)} U/day</p>
                                                    </div>
                                                    <div className="grid grid-cols-6 gap-2 text-xs">
                                                        {analysisResults.basalSchedule.map((entry, idx) => (
                                                            <div key={idx} className="bg-gray-50 p-2 rounded">
                                                                <div className="font-semibold">{`${idx.toString().padStart(2, '0')}:00`}</div>
                                                                <div className="text-gray-600">{entry.value.toFixed(3)} U/hr</div>
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            );
                                        }
                                    })()}
                                </div>
                            </>
                        )}
                    </div>
                </div>
            );
        };

        // Render the app
        ReactDOM.render(<IAPSOptimizer />, document.getElementById('root'));
    </script>
</body>
</html>

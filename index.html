
                
                // Group by hour
                const byHour = {};
                for (let h = 0; h < 24; h++) byHour[h] = [];
                
                cleanRecords.forEach(r => {
                    byHour[r.hour].push({
                        deviation: r.deviation,
                        time: r.time,
                        bg: r.bg,
                        bolusiob: r.bolusiob
                    });
                });
                
                // Calculate hourly stats
                const hourlyStats = {};
                for (let h = 0; h < 24; h++) {
                    const deviations = byHour[h].map(r => r.deviation);
                    hourlyStats[h] = {
                        median: deviations.length >= 2 ? median(deviations) : null,
                        mean: deviations.length > 0 ? deviations.reduce((a, b) => a + b, 0) / deviations.length : null,
                        count: deviations.length,
                        values: deviations,
                        samples: byHour[h]
                    };
                }
                
                return {
                    totalCleanRecords: cleanRecords.length,
                    totalRecords: records.length,
                    hourlyStats,
                    cleanRecords
                };
            }
            
            // =========================================================================
            // CIRCADIAN PERIOD POOLING
            // =========================================================================
            
            /**
             * Pool clean window data by circadian period.
             * 
             * @param {Object} cleanResult - Result from analyzeCleanWindows
             * @param {Number} minSampleSize - Minimum samples required for a period
             * @returns {Object} Analysis results per period
             */
            function poolByCircadianPeriod(cleanResult, minSampleSize = 10) {
                const periodAnalysis = {};
                
                CIRCADIAN_PERIODS.forEach(period => {
                    const pooledDeviations = [];
                    const hoursCovered = [];
                    
                    for (let h = period.startHour; h < period.endHour; h++) {
                        const hourData = cleanResult.hourlyStats[h];
                        if (hourData && hourData.values.length > 0) {
                            pooledDeviations.push(...hourData.values);
                            hoursCovered.push({ hour: h, count: hourData.count });
                        }
                    }
                    
                    const medianDev = pooledDeviations.length >= minSampleSize ? median(pooledDeviations) : null;
                    const hasSufficientData = pooledDeviations.length >= minSampleSize;
                    
                    // Determine signal
                    let signal = null;
                    if (hasSufficientData) {
                        if (medianDev > 5) signal = 'HIGH';      // Basal too weak
                        else if (medianDev < -5) signal = 'LOW'; // Basal too strong
                        else signal = 'NEUTRAL';
                    }
                    
                    periodAnalysis[period.name] = {
                        period: period,
                        pooledCount: pooledDeviations.length,
                        medianDeviation: medianDev,
                        meanDeviation: pooledDeviations.length > 0 
                            ? pooledDeviations.reduce((a, b) => a + b, 0) / pooledDeviations.length 
                            : null,
                        hoursCovered,
                        hasSufficientData,
                        signal,
                        values: pooledDeviations
                    };
                });
                
                return periodAnalysis;
            }
            
            // =========================================================================
            // SIGNAL-BASED ADJUSTMENTS
            // =========================================================================
            
            /**
             * Calculate signal-based adjustments for each period.
             * 
             * @param {Object} periodAnalysis - Result from poolByCircadianPeriod
             * @param {Array} basalSchedule - Current basal schedule
             * @param {Array} isfSchedule - ISF schedule
             * @param {Number} dampingFactor - Damping factor (0.3-0.7)
             * @returns {Array} Recommendations per period
             */
            function calculateSignalAdjustments(periodAnalysis, basalSchedule, isfSchedule, dampingFactor = 0.4) {
                const recommendations = [];
                
                CIRCADIAN_PERIODS.forEach(period => {
                    const analysis = periodAnalysis[period.name];
                    const midHour = Math.floor((period.startHour + period.endHour) / 2);
                    const currentRate = getScheduleValueForHour(basalSchedule, midHour);
                    const periodISF = getScheduleValueForHour(isfSchedule, midHour);
                    const periodHours = period.endHour - period.startHour;
                    
                    let signalAdjustment = 0;
                    let reason = null;
                    
                    if (analysis.hasSufficientData && analysis.signal !== 'NEUTRAL') {
                        const rawAdjustment = (analysis.medianDeviation / periodISF) * dampingFactor;
                        signalAdjustment = Math.max(-0.15, Math.min(0.15, rawAdjustment));
                        signalAdjustment = roundToIncrement(signalAdjustment);
                        
                        // Minimum adjustment rule
                        if (Math.abs(signalAdjustment) < PUMP_INCREMENT && Math.abs(analysis.medianDeviation) > 5) {
                            signalAdjustment = analysis.medianDeviation > 0 ? PUMP_INCREMENT : -PUMP_INCREMENT;
                        }
                        
                        if (Math.abs(signalAdjustment) >= PUMP_INCREMENT) {
                            reason = `Dev ${analysis.medianDeviation.toFixed(1)} / ISF ${periodISF} x ${dampingFactor}`;
                        }
                    }
                    
                    // Signal-only rate (before target scaling)
                    let signalOnlyRate = currentRate + signalAdjustment;
                    signalOnlyRate = Math.max(PUMP_INCREMENT, signalOnlyRate);
                    
                    recommendations.push({
                        period,
                        analysis,
                        currentRate,
                        signalAdjustment,
                        signalOnlyRate,
                        reason,
                        periodHours,
                        periodISF
                    });
                });
                
                return recommendations;
            }
            
            // =========================================================================
            // DIRECTION-AWARE INCREMENT DISTRIBUTION
            // =========================================================================
            
            /**
             * Distribute increments to hit target, prioritizing periods where adjustment helps.
             * Respects protected hours (safety hours) which cannot receive increases.
             * 
             * @param {Array} hourlySchedule - 24-element array of hourly rates
             * @param {Array} recommendations - Signal recommendations from calculateSignalAdjustments
             * @param {Number} targetTotal - Target total daily basal
             * @param {Set} protectedHours - Set of hour strings (e.g., "00:00") that cannot receive increases
             * @returns {Object} Distribution results
             */
            function distributeIncrements(hourlySchedule, recommendations, targetTotal, protectedHours = new Set()) {
                const schedule = [...hourlySchedule]; // Copy
                const currentTotal = schedule.reduce((sum, r) => sum + r, 0);
                const difference = targetTotal - currentTotal;
                const incrementsNeeded = Math.round(difference / PUMP_INCREMENT);
                
                if (incrementsNeeded === 0) {
                    return {
                        schedule,
                        incrementsNeeded: 0,
                        appliedHours: [],
                        direction: 'none',
                        finalTotal: currentTotal
                    };
                }
                
                const isDecrease = incrementsNeeded < 0;
                const isIncrease = !isDecrease;
                
                // Log protection status
                if (protectedHours.size > 0 && isIncrease) {
                    console.log(`    Signal Distribution: Protecting ${protectedHours.size} safety hours from increases`);
                    console.log(`    Protected hours: ${Array.from(protectedHours).sort().join(', ')}`);
                }
                
                // Build period info with signal direction
                const periodInfo = recommendations.map(rec => ({
                    period: rec.period,
                    signalValue: rec.analysis.medianDeviation || 0,
                    signalStrength: Math.abs(rec.analysis.medianDeviation || 0),
                    startHour: rec.period.startHour,
                    hours: [],
                    matchesDirection: isDecrease 
                        ? (rec.analysis.medianDeviation || 0) < 0  // Decrease matches negative
                        : (rec.analysis.medianDeviation || 0) > 0  // Increase matches positive
                }));
                
                // Build spread-ordered hours within each period, excluding protected hours for increases
                periodInfo.forEach(p => {
                    const hours = [];
                    for (let h = p.period.startHour; h < p.period.endHour; h++) {
                        // For increases, skip protected hours
                        if (isIncrease) {
                            const hourStr = `${h.toString().padStart(2, '0')}:00`;
                            if (protectedHours.has(hourStr)) continue;
                        }
                        hours.push(h);
                    }
                    // Interleave: even indices first, then odd (spread order)
                    const evens = hours.filter((_, i) => i % 2 === 0);
                    const odds = hours.filter((_, i) => i % 2 === 1);
                    p.hours = [...evens, ...odds];
                });
                
                // Separate into matching and non-matching groups
                const matching = periodInfo.filter(p => p.matchesDirection);
                const nonMatching = periodInfo.filter(p => !p.matchesDirection);
                
                // Sort each group by signal strength
                const sortByStrength = (a, b) => {
                    const strengthDiff = b.signalStrength - a.signalStrength;
                    if (Math.abs(strengthDiff) > 0.1) return strengthDiff;
                    return a.startHour - b.startHour;
                };
                matching.sort(sortByStrength);
                nonMatching.sort(sortByStrength);
                
                // Build spread order: exhaust matching first, then non-matching
                const buildGroupOrder = (periods) => {
                    const maxHours = Math.max(...periods.map(p => p.hours.length), 0);
                    const order = [];
                    for (let pass = 0; pass < maxHours; pass++) {
                        for (const p of periods) {
                            if (pass < p.hours.length) {
                                order.push(p.hours[pass]);
                            }
                        }
                    }
                    return order;
                };
                
                const matchingOrder = buildGroupOrder(matching);
                const nonMatchingOrder = buildGroupOrder(nonMatching);
                const spreadOrder = [...matchingOrder, ...nonMatchingOrder];
                
                // Apply increments
                let remaining = Math.abs(incrementsNeeded);
                const delta = isDecrease ? -PUMP_INCREMENT : PUMP_INCREMENT;
                const appliedHours = [];
                
                for (const hour of spreadOrder) {
                    if (remaining <= 0) break;
                    const newRate = schedule[hour] + delta;
                    if (newRate >= PUMP_INCREMENT) {
                        schedule[hour] = roundToIncrement(newRate);
                        remaining--;
                        const period = getPeriodForHour(hour);
                        appliedHours.push({
                            hour,
                            period: period.name,
                            delta,
                            newRate: schedule[hour]
                        });
                    }
                }
                
                return {
                    schedule,
                    incrementsNeeded,
                    appliedHours,
                    direction: isDecrease ? 'decrease' : 'increase',
                    matchingPeriods: matching.map(p => p.period.name),
                    nonMatchingPeriods: nonMatching.map(p => p.period.name),
                    finalTotal: schedule.reduce((sum, r) => sum + r, 0)
                };
            }
            
            // =========================================================================
            // MAIN ENTRY POINT
            // =========================================================================
            
            /**
             * Main analysis function. Call this from v24.
             * 
             * @param {Object} options
             * @param {Array} options.deviceStatus - Nightscout deviceStatus records
             * @param {Array} options.profile - Nightscout profile array
             * @param {Array} options.safetyAdjustedSchedule - 24-element array from v24's safety reductions
             * @param {Number} options.tdd - 2-week TDD
             * @param {Number} options.targetAnchor - Target % of TDD (default: 35)
             * @param {Number} options.dampingFactor - Signal damping (default: 0.4)
             * @param {Number} options.minSampleSize - Min samples per period (default: 10)
             * @param {Number} options.analysisWindowDays - Days to analyze (default: 7)
             * @param {Set} options.protectedHours - Hours that cannot receive increases (safety hours)
             * @returns {Object} Complete analysis results
             */
            function analyze(options) {
                const {
                    deviceStatus,
                    profile,
                    safetyAdjustedSchedule,
                    tdd,
                    targetAnchor = 35,
                    dampingFactor = 0.4,
                    minSampleSize = 10,
                    analysisWindowDays = 7,
                    protectedHours = new Set()
                } = options;
                
                // Extract schedules from profile
                const profileData = profile?.[0];
                const store = profileData?.store?.default || profileData?.store?.[Object.keys(profileData?.store || {})[0]];
                const basalSchedule = store?.basal || [];
                const isfSchedule = store?.sens || [];
                
                // Determine analysis start date
                const now = new Date();
                const analysisStartDate = new Date(now - analysisWindowDays * 24 * 60 * 60 * 1000);
                
                // Calculate target total
                const targetTotal = tdd * (targetAnchor / 100);
                const currentTotal = safetyAdjustedSchedule.reduce((sum, r) => sum + (r.value || r), 0);
                
                // Step 1: Analyze clean windows
                const cleanResult = analyzeCleanWindows(deviceStatus, analysisStartDate);
                
                // Step 2: Pool by circadian period
                const periodAnalysis = poolByCircadianPeriod(cleanResult, minSampleSize);
                
                // Step 3: Calculate signal adjustments
                const recommendations = calculateSignalAdjustments(
                    periodAnalysis, 
                    basalSchedule, 
                    isfSchedule, 
                    dampingFactor
                );
                
                // Step 4: Build signal-only hourly schedule from safety-adjusted baseline
                const signalHourlySchedule = [];
                for (let h = 0; h < 24; h++) {
                    const period = getPeriodForHour(h);
                    const rec = recommendations.find(r => r.period.name === period.name);
                    const safetyRate = typeof safetyAdjustedSchedule[h] === 'object' 
                        ? safetyAdjustedSchedule[h].value 
                        : safetyAdjustedSchedule[h];
                    
                    // Apply signal adjustment to safety-adjusted rate
                    if (rec && rec.signalAdjustment !== 0) {
                        signalHourlySchedule[h] = Math.max(PUMP_INCREMENT, roundToIncrement(safetyRate + rec.signalAdjustment));
                    } else {
                        signalHourlySchedule[h] = safetyRate;
                    }
                }
                
                const signalOnlyTotal = signalHourlySchedule.reduce((sum, r) => sum + r, 0);
                const signalOnlyAnchor = (signalOnlyTotal / tdd) * 100;
                
                // Step 5: Distribute increments to hit target (with safety hour protection)
                const distribution = distributeIncrements(signalHourlySchedule, recommendations, targetTotal, protectedHours);
                
                const finalTotal = distribution.finalTotal;
                const finalAnchor = (finalTotal / tdd) * 100;
                
                // Build final schedule as objects with time property
                const finalSchedule = distribution.schedule.map((value, idx) => ({
                    time: `${idx.toString().padStart(2, '0')}:00`,
                    value: value
                }));
                
                return {
                    finalSchedule,
                    
                    signalAnalysis: {
                        cleanWindows: {
                            total: cleanResult.totalCleanRecords,
                            byHour: cleanResult.hourlyStats
                        },
                        periods: recommendations.map(rec => ({
                            name: rec.period.name,
                            emoji: rec.period.emoji,
                            hours: `${rec.period.startHour.toString().padStart(2, '0')}-${rec.period.endHour.toString().padStart(2, '0')}`,
                            cleanWindowCount: rec.analysis.pooledCount,
                            medianDeviation: rec.analysis.medianDeviation,
                            signal: rec.analysis.signal,
                            hasSufficientData: rec.analysis.hasSufficientData,
                            isf: rec.periodISF,
                            currentRate: rec.currentRate,
                            signalAdjustment: rec.signalAdjustment,
                            signalOnlyRate: rec.signalOnlyRate
                        })),
                        signalOnlyTotal,
                        signalOnlyAnchor
                    },
                    
                    incrementDistribution: {
                        incrementsNeeded: distribution.incrementsNeeded,
                        direction: distribution.direction,
                        appliedHours: distribution.appliedHours,
                        matchingPeriods: distribution.matchingPeriods,
                        nonMatchingPeriods: distribution.nonMatchingPeriods
                    },
                    
                    totals: {
                        safetyAdjusted: currentTotal,
                        signalBased: signalOnlyTotal,
                        final: finalTotal,
                        tdd: tdd,
                        targetPercent: targetAnchor,
                        signalPercent: signalOnlyAnchor,
                        finalPercent: finalAnchor
                    },
                    
                    // For v24 compatibility
                    hourlySchedule: finalSchedule,
                    hourlyDisplayData: finalSchedule.map((entry, idx) => {
                        const safetyRate = typeof safetyAdjustedSchedule[idx] === 'object'
                            ? safetyAdjustedSchedule[idx].value
                            : safetyAdjustedSchedule[idx];
                        const originalRate = getScheduleValueForHour(basalSchedule, idx);
                        
                        return {
                            hour: entry.time,
                            oldValue: originalRate.toFixed(3),
                            newValue: entry.value.toFixed(3),
                            change: (entry.value - originalRate).toFixed(3),
                            hasChange: Math.abs(entry.value - originalRate) > 0.001,
                            safetyValue: safetyRate.toFixed(3),
                            isSignalChange: distribution.appliedHours.some(a => a.hour === idx)
                        };
                    })
                };
            }
            
            // =========================================================================
            // PUBLIC API
            // =========================================================================
            
            return {
                // Constants
                CIRCADIAN_PERIODS,
                PUMP_INCREMENT,
                
                // Individual functions (for testing/debugging)
                analyzeCleanWindows,
                poolByCircadianPeriod,
                calculateSignalAdjustments,
                distributeIncrements,
                
                // Helper functions
                getPeriodForHour,
                getScheduleValueForHour,
                roundToIncrement,
                median,
                
                // Main entry point
                analyze
            };
        })();

        const IAPSOptimizer = () => {
            const [nightscoutData, setNightscoutData] = useState(null);
            const [analysisResults, setAnalysisResults] = useState(null);
            const [analyzing, setAnalyzing] = useState(false);
            const [error, setError] = useState(null);
            const [loading, setLoading] = useState(false);
            const [fetchStatus, setFetchStatus] = useState('');
            const [analysisWindow, setAnalysisWindow] = useState(1);
            const [basalSignalWindow, setBasalSignalWindow] = useState(7);
            const [basalTDDPercent, setBasalTDDPercent] = useState(35);
            
            // Google Sheets Logging State
            const [sheetsWebAppUrl, setSheetsWebAppUrl] = useState(() => {
                try {
                    return localStorage.getItem('googleSheetsWebAppUrl') || 'https://script.google.com/macros/s/AKfycbzFj05CKepvJJx9l-HYTeNkihHKm6vLxb2zJsC0z2X1KFuEeGl-nxgkwYUfzLetgm09/exec';
                } catch (e) { return 'https://script.google.com/macros/s/AKfycbzFj05CKepvJJx9l-HYTeNkihHKm6vLxb2zJsC0z2X1KFuEeGl-nxgkwYUfzLetgm09/exec'; }
            });
            const [loggingNotes, setLoggingNotes] = useState('');
            const [logStatus, setLogStatus] = useState('idle'); // idle, logging, success, error
            const [logMessage, setLogMessage] = useState('');
            
            // Trend Analysis State
            const [trendData, setTrendData] = useState(null);
            const [trendLoading, setTrendLoading] = useState(false);
            const [trendError, setTrendError] = useState(null);
            const [showTrend, setShowTrend] = useState(false);
            const [optimalTDDRecommendation, setOptimalTDDRecommendation] = useState(null);
            
            // Claude Review State
            const [copyStatus, setCopyStatus] = useState('idle'); // idle, copied
            
            // Save sheets URL to localStorage when it changes
            const updateSheetsUrl = (url) => {
                setSheetsWebAppUrl(url);
                try {
                    localStorage.setItem('googleSheetsWebAppUrl', url);
                } catch (e) {}
            };
            
            const [nsConfig, setNsConfig] = useState(() => {
                try {
                    const saved = localStorage.getItem('nightscoutConfig');
                    if (saved) return JSON.parse(saved);
                } catch (e) {}
                return { 
                    baseUrl: 'https://bmac.us.nightscoutpro.com', 
                    apiSecret: 'uFhaZjS2jLaz', 
                    token: 'cockpit-cdbc465a76b45661' 
                };
            });

            const updateNsConfig = (newConfig) => {
                setNsConfig(newConfig);
                try {
                    localStorage.setItem('nightscoutConfig', JSON.stringify(newConfig));
                } catch (e) {}
            };

            // =========================================================================
            // GOOGLE SHEETS LOGGING FUNCTIONS
            // =========================================================================
            
            const logToGoogleSheets = async () => {
                if (!sheetsWebAppUrl) {
                    setLogStatus('error');
                    setLogMessage('Please configure Google Sheets URL first');
                    return;
                }
                
                // Find the signal analysis from recommendations
                const signalRec = analysisResults?.recommendations?.find(r => r.signalAnalysis);
                if (!signalRec) {
                    setLogStatus('error');
                    setLogMessage('No signal analysis data to log');
                    return;
                }
                
                setLogStatus('logging');
                setLogMessage('Logging to Google Sheets...');
                
                // Build payload
                const getPeriodDev = (name) => {
                    const period = signalRec.signalAnalysis.periods.find(p => p.name === name);
                    return period?.medianDeviation !== null && period?.medianDeviation !== undefined 
                        ? period.medianDeviation.toFixed(1) 
                        : '';
                };
                
                const payload = {
                    timestamp: new Date().toISOString(),
                    analysisWindow: basalSignalWindow,
                    tdd: signalRec.signalTotals?.tdd?.toFixed(1) || '',
                    signalPercent: signalRec.signalTotals?.signalPercent?.toFixed(1) || signalRec.signalAnalysis?.signalOnlyAnchor?.toFixed(1) || '',
                    targetPercent: basalTDDPercent,
                    gap: signalRec.signalTotals?.signalPercent 
                        ? (signalRec.signalTotals.signalPercent - basalTDDPercent).toFixed(1) 
                        : (signalRec.signalAnalysis?.signalOnlyAnchor 
                            ? (signalRec.signalAnalysis.signalOnlyAnchor - basalTDDPercent).toFixed(1) 
                            : ''),
                    finalPercent: signalRec.signalTotals?.finalPercent?.toFixed(1) || '',
                    cleanWindows: signalRec.signalAnalysis?.cleanWindows?.total || '',
                    deepSleepDev: getPeriodDev('Deep Sleep'),
                    dawnDev: getPeriodDev('Dawn'),
                    morningDev: getPeriodDev('Morning'),
                    afternoonDev: getPeriodDev('Afternoon'),
                    eveningDev: getPeriodDev('Evening'),
                    sleepOnsetDev: getPeriodDev('Sleep Onset'),
                    incrementsApplied: signalRec.incrementDistribution?.incrementsNeeded || 0,
                    direction: signalRec.incrementDistribution?.direction || 'none',
                    notes: loggingNotes
                };
                
                try {
                    // POST with no-cors for Apps Script compatibility
                    await fetch(sheetsWebAppUrl, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    // no-cors means we can't read response, show optimistic success
                    setLogStatus('success');
                    setLogMessage('Logged successfully!');
                    setLoggingNotes(''); // Clear notes after logging
                    
                    // Reset status after 3 seconds
                    setTimeout(() => {
                        setLogStatus('idle');
                        setLogMessage('');
                    }, 3000);
                    
                } catch (error) {
                    console.error('Failed to log:', error);
                    setLogStatus('error');
                    setLogMessage('Failed to log: ' + error.message);
                }
            };
            
            // =========================================================================
            // TREND ANALYSIS FUNCTIONS
            // =========================================================================
            
            const fetchTrendData = async () => {
                if (!sheetsWebAppUrl) {
                    setTrendError('Please configure Google Sheets URL first');
                    return;
                }
                
                setTrendLoading(true);
                setTrendError(null);
                setShowTrend(true);
                
                try {
                    const response = await fetch(sheetsWebAppUrl);
                    const result = await response.json();
                    
                    console.log('Trend data received:', result);
                    
                    if (result.success && result.entries) {
                        console.log('Entries:', result.entries);
                        setTrendData(result.entries);
                        
                        // ALWAYS call analyzeOptimalTDDPercent - it handles insufficient data
                        // and calculates basic stats (avgGap, daySpan) even with few entries
                        const recommendation = analyzeOptimalTDDPercent(result.entries);
                        console.log('Recommendation:', recommendation);
                        setOptimalTDDRecommendation(recommendation);
                    } else {
                        setTrendError(result.error || 'Failed to fetch trend data');
                    }
                } catch (error) {
                    console.error('Failed to fetch trend:', error);
                    setTrendError('Failed to fetch: ' + error.message);
                } finally {
                    setTrendLoading(false);
                }
            };
            
            const analyzeOptimalTDDPercent = (loggedData) => {
                console.log('=== analyzeOptimalTDDPercent CALLED ===');
                console.log('Input data length:', loggedData?.length);
                
                // Parse values - handle different column name formats including Google Sheets headers
                const parseVal = (entry, ...keys) => {
                    // Normalize a key for comparison (trim, lowercase, remove extra spaces)
                    const normalizeKey = (k) => k.toLowerCase().trim().replace(/\s+/g, ' ');
                    
                    // Build all possible key variations from the requested keys ONLY
                    const allKeys = new Set();
                    for (const key of keys) {
                        allKeys.add(key);
                        allKeys.add(key.toLowerCase());
                        allKeys.add(key.trim());
                    }
                    // NOTE: Do NOT add unrelated keys like 'Timestamp' here!
                    // That causes parseFloat("2025-12-01...") = 2025 to be returned
                    
                    // Try to find a matching key in the entry
                    const entryKeys = Object.keys(entry);
                    for (const entryKey of entryKeys) {
                        const normalizedEntryKey = normalizeKey(entryKey);
                        for (const targetKey of allKeys) {
                            if (normalizeKey(targetKey) === normalizedEntryKey) {
                                const val = parseFloat(entry[entryKey]);
                                if (!isNaN(val)) return val;
                            }
                        }
                    }
                    return null;
                };
                
                const getTimestamp = (entry) => {
                    return entry.timestamp || entry.Timestamp || entry.TIMESTAMP || null;
                };
                
                // Debug: log what we're working with
                if (loggedData.length > 0) {
                    console.log('analyzeOptimalTDDPercent: First entry keys:', Object.keys(loggedData[0]));
                    console.log('analyzeOptimalTDDPercent: First entry:', loggedData[0]);
                }
                
                console.log('=== Checking each entry for valid signal/target ===');
                const validEntries = loggedData.filter((entry, idx) => {
                    // Include all possible key formats for Google Sheets compatibility
                    // Apps Script converts "Signal %" to "signal_Percent"
                    const signal = parseVal(entry, 'Signal %', 'signal_%', 'signal_percent', 'signalPercent', 'signal_Percent');
                    const target = parseVal(entry, 'Target %', 'target_%', 'target_percent', 'targetPercent', 'target_Percent');
                    console.log(`analyzeOptimalTDDPercent: Entry ${idx} - signal: ${signal}, target: ${target}, valid: ${signal !== null && target !== null}`);
                    return signal !== null && target !== null;
                });
                console.log('validEntries count:', validEntries.length);
                
                // Calculate basic stats even with insufficient data
                let avgGap = null;
                let daySpan = null;
                
                if (validEntries.length > 0) {
                    // Calculate gaps (signal% - target%)
                    const gaps = validEntries.map((entry, idx) => {
                        const signal = parseVal(entry, 'Signal %', 'signal_%', 'signal_percent', 'signalPercent', 'signal_Percent');
                        const target = parseVal(entry, 'Target %', 'target_%', 'target_percent', 'targetPercent', 'target_Percent');
                        const gap = signal - target;
                        console.log(`analyzeOptimalTDDPercent: Entry ${idx} - signal: ${signal}, target: ${target}, gap: ${gap}`);
                        return gap;
                    });
                    console.log('analyzeOptimalTDDPercent: All gaps:', gaps);
                    avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
                    console.log('analyzeOptimalTDDPercent: avgGap calculated:', avgGap);
                    
                    // Calculate date range
                    const timestamps = validEntries.map(e => new Date(getTimestamp(e))).filter(d => !isNaN(d));
                    if (timestamps.length > 0) {
                        const firstDate = new Date(Math.min(...timestamps));
                        const lastDate = new Date(Math.max(...timestamps));
                        daySpan = Math.max(1, Math.ceil((lastDate - firstDate) / (1000 * 60 * 60 * 24)));
                    }
                }
                
                if (validEntries.length < 14) {
                    console.log('=== RETURNING INSUFFICIENT_DATA ===');
                    console.log('validEntries.length:', validEntries.length);
                    console.log('avgGap:', avgGap);
                    console.log('daySpan:', daySpan);
                    return {
                        recommendation: 'INSUFFICIENT_DATA',
                        message: `Need ${14 - validEntries.length} more valid entries`,
                        entriesNeeded: 14 - validEntries.length,
                        avgGap: avgGap,
                        daySpan: daySpan,
                        entriesAnalyzed: validEntries.length
                    };
                }
                
                // Calculate gaps (signal% - target%) - for full analysis
                const gaps = validEntries.map(entry => {
                    const signal = parseVal(entry, 'Signal %', 'signal_%', 'signal_percent', 'signalPercent', 'signal_Percent');
                    const target = parseVal(entry, 'Target %', 'target_%', 'target_percent', 'targetPercent', 'target_Percent');
                    return signal - target;
                });
                
                avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
                
                // Check recent trend (last 7 vs first 7)
                const recentGaps = gaps.slice(-7);
                const olderGaps = gaps.slice(0, 7);
                const recentAvg = recentGaps.reduce((a, b) => a + b, 0) / recentGaps.length;
                const olderAvg = olderGaps.reduce((a, b) => a + b, 0) / olderGaps.length;
                
                // Determine trend direction
                let trendDirection = 'stable';
                if (Math.abs(recentAvg) < Math.abs(olderAvg) - 0.5) {
                    trendDirection = 'converging';
                } else if (Math.abs(recentAvg) > Math.abs(olderAvg) + 0.5) {
                    trendDirection = 'diverging';
                }
                
                // Recalculate daySpan for full dataset (more accurate)
                const fullTimestamps = validEntries.map(e => new Date(getTimestamp(e))).filter(d => !isNaN(d));
                if (fullTimestamps.length > 1) {
                    const firstDate = new Date(Math.min(...fullTimestamps));
                    const lastDate = new Date(Math.max(...fullTimestamps));
                    daySpan = Math.max(1, Math.ceil((lastDate - firstDate) / (1000 * 60 * 60 * 24)));
                }
                
                // Determine recommendation
                const currentTarget = basalTDDPercent;
                
                if (Math.abs(avgGap) < 0.5) {
                    return {
                        recommendation: 'OPTIMAL',
                        message: `Your ${currentTarget}% target is well-calibrated. Signals consistently align within Â±0.5%.`,
                        suggestedTarget: currentTarget,
                        avgGap: avgGap,
                        trendDirection: trendDirection,
                        entriesAnalyzed: validEntries.length,
                        daySpan: daySpan,
                        confidence: 'HIGH'
                    };
                }
                
                if (avgGap > 1.0) {
                    // Signals consistently suggest MORE basal needed
                    const suggested = Math.min(45, Math.round(currentTarget + avgGap));
                    return {
                        recommendation: 'INCREASE',
                        message: `Signals consistently run +${avgGap.toFixed(1)}% above your ${currentTarget}% target. This suggests your basal needs are higher than the current anchor.`,
                        suggestedTarget: suggested,
                        avgGap: avgGap,
                        trendDirection: trendDirection,
                        entriesAnalyzed: validEntries.length,
                        daySpan: daySpan,
                        confidence: trendDirection === 'converging' ? 'HIGH' : (trendDirection === 'stable' ? 'MEDIUM' : 'LOW')
                    };
                }
                
                if (avgGap < -1.0) {
                    // Signals consistently suggest LESS basal needed
                    const suggested = Math.max(25, Math.round(currentTarget + avgGap));
                    return {
                        recommendation: 'DECREASE',
                        message: `Signals consistently run ${avgGap.toFixed(1)}% below your ${currentTarget}% target. This suggests your basal needs are lower than the current anchor.`,
                        suggestedTarget: suggested,
                        avgGap: avgGap,
                        trendDirection: trendDirection,
                        entriesAnalyzed: validEntries.length,
                        daySpan: daySpan,
                        confidence: trendDirection === 'converging' ? 'HIGH' : (trendDirection === 'stable' ? 'MEDIUM' : 'LOW')
                    };
                }
                
                return {
                    recommendation: 'MONITOR',
                    message: `Gap of ${avgGap >= 0 ? '+' : ''}${avgGap.toFixed(1)}% is within acceptable range but worth monitoring.`,
                    suggestedTarget: currentTarget,
                    avgGap: avgGap,
                    trendDirection: trendDirection,
                    entriesAnalyzed: validEntries.length,
                    daySpan: daySpan,
                    confidence: 'MEDIUM'
                };
            };
            
            // =========================================================================
            // CLAUDE REVIEW COPY FUNCTION
            // =========================================================================
            
            const formatForClaudeReview = () => {
                if (!analysisResults) return '';
                
                const now = new Date();
                const dateStr = now.toLocaleDateString('en-US', { 
                    weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
                });
                
                let output = `## iAPS Parameter Optimizer Analysis\n`;
                output += `**Date:** ${dateStr}\n`;
                output += `**Analysis Window:** ${analysisWindow} day(s) for CR/ISF, ${basalSignalWindow} days for Basal\n`;
                output += `**Basal TDD Target:** ${basalTDDPercent}%\n\n`;
                
                // Summary
                output += `---\n## Summary\n`;
                output += `- **Total Recommendations:** ${analysisResults.summary.totalRecommendations}\n`;
                output += `- **High Priority (Safety):** ${analysisResults.summary.byPriority.high}\n`;
                output += `- **Medium Priority:** ${analysisResults.summary.byPriority.medium}\n`;
                output += `- **Low Priority:** ${analysisResults.summary.byPriority.low}\n`;
                if (analysisResults.summary.byPriority.informational) {
                    output += `- **Informational:** ${analysisResults.summary.byPriority.informational}\n`;
                }
                output += `\n`;
                
                // Current Schedules
                output += `---\n## Current Schedules\n\n`;
                
                output += `### CR Schedule (g/U)\n`;
                analysisResults.crSchedule.forEach(entry => {
                    output += `- ${entry.time}: ${entry.value}\n`;
                });
                output += `\n`;
                
                output += `### ISF Schedule (mg/dL per U)\n`;
                analysisResults.isfSchedule.forEach(entry => {
                    output += `- ${entry.time}: ${entry.value}\n`;
                });
                output += `\n`;
                
                output += `### Basal Schedule (U/hr)\n`;
                const basalTotal = analysisResults.basalSchedule.reduce((sum, e) => sum + e.value, 0);
                analysisResults.basalSchedule.forEach(entry => {
                    output += `- ${entry.time}: ${entry.value}\n`;
                });
                output += `- **Total:** ${basalTotal.toFixed(2)} U/day\n\n`;
                
                // Signal Analysis (if basal recommendation exists)
                const basalRec = analysisResults.recommendations.find(r => r.signalAnalysis);
                if (basalRec && basalRec.signalAnalysis) {
                    output += `---\n## Signal Analysis (${basalRec.signalAnalysis.cleanWindows.total} clean windows)\n\n`;
                    output += `| Period | Hours | Windows | Median Dev | Signal |\n`;
                    output += `|--------|-------|---------|------------|--------|\n`;
                    basalRec.signalAnalysis.periods.forEach(p => {
                        const dev = p.medianDeviation !== null ? `${p.medianDeviation >= 0 ? '+' : ''}${p.medianDeviation.toFixed(1)}` : 'N/A';
                        const signal = p.signal || (p.hasSufficientData ? 'NEUTRAL' : 'Insufficient');
                        output += `| ${p.emoji} ${p.name} | ${p.hours} | ${p.cleanWindowCount} | ${dev} | ${signal} |\n`;
                    });
                    output += `\n`;
                    output += `- **Signals Suggest:** ${basalRec.signalAnalysis.signalOnlyAnchor.toFixed(1)}% of TDD\n`;
                    output += `- **Current Target:** ${basalTDDPercent}%\n\n`;
                }
                
                // Recommendations by Parameter Type
                output += `---\n## Recommendations by Parameter\n\n`;
                
                analysisResults.groupedRecommendations.forEach(group => {
                    output += `### ${group.title}\n\n`;
                    
                    group.recommendations.forEach((rec, idx) => {
                        output += `**${idx + 1}. ${rec.type}**`;
                        if (rec.scheduleTime && rec.scheduleTime !== 'ALL') {
                            output += ` @ ${rec.scheduleTime}`;
                        }
                        output += `\n`;
                        output += `- **Change:** ${rec.currentValue} -> ${rec.newValue} (${rec.adjustment})\n`;
                        output += `- **Priority:** ${rec.priority}\n`;
                        output += `- **Certainty:** ${rec.confidence.score}%\n`;
                        output += `- **Detector:** ${rec.detector}\n`;
                        output += `- **Reason:** ${rec.reason}\n`;
                        if (rec.safetyNote) {
                            output += `- **Safety Note:** ${rec.safetyNote}\n`;
                        }
                        output += `\n`;
                    });
                });
                
                // Trend Data (if available)
                if (optimalTDDRecommendation) {
                    output += `---\n## Trend Analysis\n\n`;
                    output += `- **Entries Analyzed:** ${optimalTDDRecommendation.entriesAnalyzed || 'N/A'}\n`;
                    output += `- **Days Tracked:** ${optimalTDDRecommendation.daySpan || 'N/A'}\n`;
                    output += `- **Avg Gap from Target:** ${optimalTDDRecommendation.avgGap !== undefined ? (optimalTDDRecommendation.avgGap >= 0 ? '+' : '') + optimalTDDRecommendation.avgGap.toFixed(1) + '%' : 'N/A'}\n`;
                    if (optimalTDDRecommendation.recommendation && optimalTDDRecommendation.recommendation !== 'INSUFFICIENT_DATA') {
                        output += `- **Recommendation:** ${optimalTDDRecommendation.recommendation}\n`;
                        output += `- **Message:** ${optimalTDDRecommendation.message}\n`;
                    }
                    output += `\n`;
                }
                
                // Request for Claude
                output += `---\n## Request\n\n`;
                output += `Please review these iAPS parameter recommendations and provide:\n`;
                output += `1. Any concerns about the suggested changes\n`;
                output += `2. Patterns I might be missing\n`;
                output += `3. Priority order for implementing changes\n`;
                output += `4. Any additional optimizations to consider\n`;
                output += `5. Safety considerations I should be aware of\n`;
                
                return output;
            };
            
            const copyForClaudeReview = async () => {
                const text = formatForClaudeReview();
                if (!text) {
                    alert('No analysis results to copy. Run analysis first.');
                    return;
                }
                
                try {
                    await navigator.clipboard.writeText(text);
                    setCopyStatus('copied');
                    setTimeout(() => setCopyStatus('idle'), 2000);
                } catch (err) {
                    console.error('Failed to copy:', err);
                    // Fallback for older browsers
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    setCopyStatus('copied');
                    setTimeout(() => setCopyStatus('idle'), 2000);
                }
            };
            
            // =========================================================================
            // LIGHTWEIGHT CANVAS CHART COMPONENT
            // =========================================================================
            const TrendChart = ({ data, targetPercent }) => {
                const canvasRef = useRef(null);
                
                useEffect(() => {
                    if (!canvasRef.current || !data || data.length === 0) return;
                    
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d');
                    const width = canvas.width;
                    const height = canvas.height;
                    
                    // Clear canvas
                    ctx.clearRect(0, 0, width, height);
                    
                    // Padding
                    const padding = { top: 20, right: 20, bottom: 40, left: 50 };
                    const chartWidth = width - padding.left - padding.right;
                    const chartHeight = height - padding.top - padding.bottom;
                    
                    // Parse data - handle multiple column name formats from different sources
                    const parseValue = (entry, ...keys) => {
                        // Normalize a key for comparison
                        const normalizeKey = (k) => k.toLowerCase().trim().replace(/\s+/g, ' ');
                        
                        // Build all possible key variations
                        const allKeys = new Set();
                        for (const key of keys) {
                            allKeys.add(key);
                            allKeys.add(key.toLowerCase());
                            allKeys.add(key.replace(/_/g, ' '));
                        }
                        // Also add the exact Google Sheets column names
                        allKeys.add('Signal %');
                        allKeys.add('Target %');
                        allKeys.add('Final %');
                        allKeys.add('Gap');
                        
                        // Try to find a matching key in the entry
                        const entryKeys = Object.keys(entry);
                        for (const entryKey of entryKeys) {
                            const normalizedEntryKey = normalizeKey(entryKey);
                            for (const targetKey of allKeys) {
                                if (normalizeKey(targetKey) === normalizedEntryKey) {
                                    const val = parseFloat(entry[entryKey]);
                                    if (!isNaN(val)) return val;
                                }
                            }
                        }
                        return null;
                    };
                    
                    // Debug: log first entry keys
                    if (data.length > 0) {
                        console.log('Chart: First entry keys:', Object.keys(data[0]));
                        console.log('Chart: First entry:', data[0]);
                    }
                    
                    const points = data.map((entry, idx) => {
                        const signalVal = parseValue(entry, 'Signal %', 'signal_%', 'signal_percent', 'signalPercent', 'Signal%', 'signal_Percent');
                        const targetVal = parseValue(entry, 'Target %', 'target_%', 'target_percent', 'targetPercent', 'Target%', 'target_Percent') || targetPercent;
                        console.log(`Chart: Entry ${idx} - signal: ${signalVal}, target: ${targetVal}`);
                        return {
                            x: idx,
                            signalPercent: signalVal,
                            targetPercent: targetVal,
                            timestamp: entry.timestamp || entry.Timestamp
                        };
                    }).filter(p => p.signalPercent !== null);
                    
                    console.log('Chart: Points after filter:', points.length, points);
                    
                    if (points.length === 0) {
                        // Draw "No data" message
                        ctx.fillStyle = '#6b7280';
                        ctx.font = '14px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText('No valid signal data found', width / 2, height / 2);
                        return;
                    }
                    
                    // Calculate Y-axis range
                    const allValues = points.flatMap(p => [p.signalPercent, p.targetPercent]);
                    const minY = Math.floor(Math.min(...allValues) - 2);
                    const maxY = Math.ceil(Math.max(...allValues) + 2);
                    const yRange = maxY - minY;
                    
                    // Scale functions - center single point
                    const xScale = (idx) => {
                        if (points.length === 1) {
                            return padding.left + chartWidth / 2; // Center single point
                        }
                        return padding.left + (idx / (points.length - 1)) * chartWidth;
                    };
                    const yScale = (val) => padding.top + chartHeight - ((val - minY) / yRange) * chartHeight;
                    
                    // Draw grid lines
                    ctx.strokeStyle = '#e5e7eb';
                    ctx.lineWidth = 1;
                    for (let y = minY; y <= maxY; y += 2) {
                        const yPos = yScale(y);
                        ctx.beginPath();
                        ctx.moveTo(padding.left, yPos);
                        ctx.lineTo(width - padding.right, yPos);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#6b7280';
                        ctx.font = '11px sans-serif';
                        ctx.textAlign = 'right';
                        ctx.fillText(`${y}%`, padding.left - 5, yPos + 4);
                    }
                    
                    // Draw target line (dashed)
                    ctx.strokeStyle = '#9ca3af';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(padding.left, yScale(targetPercent));
                    ctx.lineTo(width - padding.right, yScale(targetPercent));
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Draw signal line
                    ctx.strokeStyle = '#4f46e5';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    points.forEach((point, idx) => {
                        const x = xScale(idx);
                        const y = yScale(point.signalPercent);
                        if (idx === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    ctx.stroke();
                    
                    // Draw data points (larger for fewer entries)
                    const pointRadius = points.length <= 3 ? 6 : 4;
                    ctx.fillStyle = '#4f46e5';
                    points.forEach((point, idx) => {
                        const x = xScale(idx);
                        const y = yScale(point.signalPercent);
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add value label for few entries
                        if (points.length <= 5) {
                            ctx.fillStyle = '#4f46e5';
                            ctx.font = 'bold 11px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText(`${point.signalPercent.toFixed(1)}%`, x, y - pointRadius - 5);
                            ctx.fillStyle = '#4f46e5'; // Reset for next point
                        }
                    });
                    
                    // X-axis date labels
                    ctx.fillStyle = '#6b7280';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    const formatDate = (ts) => {
                        if (!ts) return '';
                        const d = new Date(ts);
                        return `${d.getMonth() + 1}/${d.getDate()}`;
                    };
                    if (points.length > 0) {
                        ctx.fillText(formatDate(points[0].timestamp), xScale(0), height - 10);
                        if (points.length > 1) {
                            ctx.fillText(formatDate(points[points.length - 1].timestamp), xScale(points.length - 1), height - 10);
                        }
                        if (points.length > 2) {
                            ctx.fillText(formatDate(points[Math.floor(points.length / 2)].timestamp), xScale(Math.floor(points.length / 2)), height - 10);
                        }
                    }
                    
                    // Legend
                    ctx.font = '11px sans-serif';
                    ctx.textAlign = 'left';
                    ctx.fillStyle = '#4f46e5';
                    ctx.fillRect(padding.left, height - 25, 15, 3);
                    ctx.fillText('Signal %', padding.left + 20, height - 21);
                    ctx.fillStyle = '#9ca3af';
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(padding.left + 100, height - 23);
                    ctx.lineTo(padding.left + 115, height - 23);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.fillText('Target %', padding.left + 120, height - 21);
                    
                }, [data, targetPercent]);
                
                return (
                    <canvas 
                        ref={canvasRef} 
                        width={600} 
                        height={250} 
                        className="w-full max-w-2xl border border-gray-200 rounded bg-white"
                    />
                );
            };

            // ===== SECTION 1: HELPER FUNCTIONS (Keep from v23) =====
            
            // Format time for human-readable display
            // Converts "2025-11-24T17:31:42" to "5:31 PM"
            const formatTimeForDisplay = (timeStr) => {
                if (!timeStr) return '';
                const dt = new Date(timeStr);
                return dt.toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    minute: '2-digit',
                    hour12: true 
                });
            };
            
            // Find which CR schedule entry applies to a given time
            const getCRForTime = (timeStr, crSchedule) => {
                const dt = new Date(timeStr);
                const hours = dt.getHours();
                const minutes = dt.getMinutes();
                const timeInMinutes = hours * 60 + minutes;
                
                // Convert schedule to minutes
                const scheduleInMinutes = crSchedule.map(entry => {
                    const [h, m] = entry.time.split(':').map(Number);
                    return { minutes: h * 60 + m, value: entry.value, time: entry.time };
                }).sort((a, b) => a.minutes - b.minutes);
                
                // Find the applicable schedule entry
                let applicable = scheduleInMinutes[0];
                for (let entry of scheduleInMinutes) {
                    if (timeInMinutes >= entry.minutes) {
                        applicable = entry;
                    } else {
                        break;
                    }
                }
                
                return applicable;
            };

            // Find which ISF schedule entry applies to a given time
            const getISFForTime = (timeStr, isfSchedule) => {
                const dt = new Date(timeStr);
                const hours = dt.getHours();
                const minutes = dt.getMinutes();
                const timeInMinutes = hours * 60 + minutes;
                
                // Convert schedule to minutes
                const scheduleInMinutes = isfSchedule.map(entry => {
                    const [h, m] = entry.time.split(':').map(Number);
                    return { minutes: h * 60 + m, value: entry.value, time: entry.time };
                }).sort((a, b) => a.minutes - b.minutes);
                
                // Find the applicable schedule entry
                let applicable = scheduleInMinutes[0];
                for (let entry of scheduleInMinutes) {
                    if (timeInMinutes >= entry.minutes) {
                        applicable = entry;
                    } else {
                        break;
                    }
                }
                
                return applicable;
            };

            // Find which basal rate applies to a given time
            const getBasalForTime = (timeStr, basalSchedule) => {
                const dt = new Date(timeStr);
                const hours = dt.getHours();
                const minutes = dt.getMinutes();
                const timeInMinutes = hours * 60 + minutes;
                
                // Convert schedule to minutes
                const scheduleInMinutes = basalSchedule.map(entry => {
                    const [h, m] = entry.time.split(':').map(Number);
                    return { minutes: h * 60 + m, value: entry.value, time: entry.time };
                }).sort((a, b) => a.minutes - b.minutes);
                
                // Find the applicable schedule entry
                let applicable = scheduleInMinutes[0];
                for (let entry of scheduleInMinutes) {
                    if (timeInMinutes >= entry.minutes) {
                        applicable = entry;
                    } else {
                        break;
                    }
                }
                
                return applicable;
            };

            const calculateRecencyWeight = (timestamp, analysisWindowDays) => {
                const now = new Date();
                const eventTime = new Date(timestamp);
                const ageHours = (now - eventTime) / (1000 * 60 * 60);
                const windowHours = analysisWindowDays * 24;
                
                const decayFactor = 0.3;
                const weight = Math.exp(-decayFactor * (ageHours / windowHours));
                
                return weight;
            };

            // Helper function to get IOB at a specific time
            const getIOBAtTime = (deviceStatus, targetTime) => {
                if (!deviceStatus || deviceStatus.length === 0) return null;
                
                const targetTimestamp = new Date(targetTime).getTime();
                let closestIOB = null;
                let minTimeDiff = Infinity;
                
                deviceStatus.forEach(status => {
                    if (status.created_at && status.iob && typeof status.iob === 'number') {
                        const statusTime = new Date(status.created_at).getTime();
                        const timeDiff = Math.abs(statusTime - targetTimestamp);
                        
                        // Within 10 minutes
                        if (timeDiff < 10 * 60 * 1000 && timeDiff < minTimeDiff) {
                            minTimeDiff = timeDiff;
                            closestIOB = status.iob;
                        }
                    }
                });
                
                return closestIOB;
            };

            // Helper function to check if an insulin treatment is a true correction
            // Keep from v23 - this works correctly
            const isTrueCorrection = (treatment, allTreatments) => {
                // If it has carbs, it's definitely not a correction-only entry
                if (treatment.carbs && treatment.carbs > 0) return false;
                
                // If no insulin, not relevant
                if (!treatment.insulin || treatment.insulin <= 0) return false;
                
                // SMBs require context checking (ENHANCED)
                if (treatment.eventType && treatment.eventType.includes('SMB')) {
                    const smbTime = new Date(treatment.created_at);
                    const oneHourAgo = new Date(smbTime - 1 * 60 * 60 * 1000);
                    
                    // Check for recent meals (within 1 hour)
                    const recentMeals = allTreatments.filter(t => {
                        if (!t.carbs || t.carbs <= 0) return false;
                        if (!t.created_at) return false;
                        const mealTime = new Date(t.created_at);
                        return mealTime >= oneHourAgo && mealTime <= smbTime;
                    });
                    
                    // If recent meal exists, SMB is likely meal coverage
                    if (recentMeals.length > 0) {
                        return false; // NOT a true correction
                    }
                    
                    // No recent meal = true correction
                    return true;
                }
                
                // For boluses, check if there's a carb entry within 2 minutes before/after
                const treatmentTime = new Date(treatment.created_at).getTime();
                const twoMinutes = 2 * 60 * 1000;
                
                const hasNearbyCarbs = allTreatments.some(t => {
                    if (!t.carbs || t.carbs <= 0) return false;
                    if (!t.created_at) return false;
                    
                    const carbTime = new Date(t.created_at).getTime();
                    const timeDiff = Math.abs(carbTime - treatmentTime);
                    
                    // If carb entry within 2 minutes, this insulin is part of a meal
                    return timeDiff <= twoMinutes;
                });
                
                // If nearby carbs found, this is a meal bolus, not a correction
                return !hasNearbyCarbs;
            };

            // ===== NEW HELPER FUNCTIONS FOR EVENT CLAIMING =====
            
            // Create unique identifiers for events
            const getEventId = (event) => {
                return event.localDateTime || event.localTime || event.dateString || event.time || event.created_at;
            };

            // Helper to convert schedule time to minutes for sorting
            const scheduleTimeToMinutes = (timeStr) => {
                if (!timeStr || timeStr === 'ALL') return -1;
                const [h, m] = timeStr.split(':').map(Number);
                return h * 60 + (m || 0);
            };

            // ===== SECTION 2: THE 5 DETECTORS =====
            
            /**
             * HELPER: Detect Schedule Boundary Issues
             * Identifies meals that use the "wrong" CR due to schedule timing
             * and cause subsequent problems
             */
            const detectScheduleBoundaryIssues = (nightscoutData, crSchedule, lowProblems) => {
                console.log('\n=== Schedule Boundary Analysis ===');
                const issues = [];
                
                // For each meal, check if it's using a schedule that might be inappropriate
                nightscoutData.treatments.forEach(meal => {
                    if (!meal.created_at || !meal.carbs || meal.carbs <= 0) return;
                    
                    const mealTime = new Date(meal.created_at);
                    const crEntry = getCRForTime(meal.localDateTime, crSchedule);
                    
                    // Find the next schedule entry
                    const mealMinutes = mealTime.getHours() * 60 + mealTime.getMinutes();
                    const nextCREntry = crSchedule.find(entry => {
                        const [h, m] = entry.time.split(':').map(Number);
                        const entryMinutes = h * 60 + m;
                        return entryMinutes > mealMinutes;
                    });
                    
                    if (!nextCREntry || crEntry.time === nextCREntry.time) return;
                    
                    // Calculate time until next boundary
                    const [nextH, nextM] = nextCREntry.time.split(':').map(Number);
                    const nextMinutes = nextH * 60 + nextM;
                    const minutesUntilBoundary = nextMinutes - mealMinutes;
                    
                    // CONSTRAINT 1: Only recommend if meal is <120 min before boundary
                    // (Close enough to be affected by timing)
                    if (minutesUntilBoundary <= 0 || minutesUntilBoundary >= 120) {
                        return; // Too far from boundary or past it
                    }
                    
                    // Check if current CR is significantly stronger (lower value = more insulin per carb)
                    const crDifference = ((nextCREntry.value - crEntry.value) / crEntry.value) * 100;
                    
                    if (crDifference > 20) { // Next CR is >20% weaker
                        console.log(`  Potential boundary issue: ${meal.localDateTime}`);
                        console.log(`    Using ${crEntry.time} CR (${crEntry.value}) but ${nextCREntry.time} CR (${nextCREntry.value}) is ${crDifference.toFixed(1)}% weaker`);
                        console.log(`    ${minutesUntilBoundary} min before boundary`);
                        
                        // Check if there was a low within 4 hours after this meal
                        const fourHoursAfter = new Date(mealTime.getTime() + 4 * 60 * 60 * 1000);
                        const hadSubsequentLow = lowProblems.some(low => {
                            const lowTime = new Date(low.time);
                            return lowTime > mealTime && lowTime <= fourHoursAfter;
                        });
                        
                        if (hadSubsequentLow) {
                            // CONSTRAINT 2: Check if moving boundary would maintain Ã¢â°Â¥2 hour gap
                            // Calculate suggested new boundary time (round to 30-min intervals)
                            const suggestedHour = mealTime.getHours();
                            const suggestedMin = mealTime.getMinutes() < 30 ? 0 : 30;
                            const suggestedBoundaryMinutes = suggestedHour * 60 + suggestedMin;
                            
                            // Find the previous schedule entry
                            const [currentH, currentM] = crEntry.time.split(':').map(Number);
                            const currentMinutes = currentH * 60 + currentM;
                            
                            // Calculate gap between suggested boundary and current schedule
                            const gapMinutes = suggestedBoundaryMinutes - currentMinutes;
                            
                            console.log(`    Suggested boundary: ${suggestedHour.toString().padStart(2, '0')}:${suggestedMin.toString().padStart(2, '0')}`);
                            console.log(`    Gap with ${crEntry.time}: ${gapMinutes} minutes`);
                            
                            if (gapMinutes < 120) {
                                console.log(`    -> Skipping: Would create ${gapMinutes}-min gap (need Ã¢â°Â¥120 min)`);
                                return; // Gap too small - schedules would be too close
                            }
                            
                            console.log(`    -> Subsequent low detected - boundary adjustment recommended`);
                            
                            issues.push({
                                meal: meal,
                                mealTime: meal.localDateTime,
                                currentSchedule: crEntry.time,
                                currentCR: crEntry.value,
                                nextSchedule: nextCREntry.time,
                                nextCR: nextCREntry.value,
                                minutesBeforeBoundary: minutesUntilBoundary,
                                crDifference: crDifference,
                                hadSubsequentLow: true,
                                suggestedBoundary: `${suggestedHour.toString().padStart(2, '0')}:${suggestedMin.toString().padStart(2, '0')}`,
                                gapMinutes: gapMinutes
                            });
                        }
                    }
                });
                
                // Generate recommendations for schedule boundary adjustments
                const recommendations = [];
                issues.forEach(issue => {
                    // Use the pre-validated suggested boundary
                    const suggestedBoundary = issue.suggestedBoundary;
                    
                    recommendations.push({
                        detector: 'Schedule Boundary Optimization',
                        type: 'Schedule Boundary Adjustment',
                        reason: `Meal using strong ${issue.currentSchedule} CR (${issue.currentCR} g/U) caused subsequent low. Moving boundary earlier would use weaker ${issue.nextSchedule} CR (${issue.nextCR} g/U).`,
                        scheduleTime: issue.nextSchedule,
                        currentValue: issue.nextCR,
                        newValue: issue.nextCR, // Value stays same, timing changes
                        adjustment: `Move boundary: ${issue.nextSchedule}  ->  ${suggestedBoundary}`,
                        calculation: `Meal at ${formatTimeForDisplay(issue.meal.created_at)} is ${issue.minutesBeforeBoundary} min before ${issue.nextSchedule} boundary. Used ${issue.currentCR} g/U (${issue.crDifference.toFixed(0)}% stronger) instead of ${issue.nextCR} g/U. Moving maintains ${issue.gapMinutes}-min gap with ${issue.currentSchedule}.`,
                        details: `Meal at ${formatTimeForDisplay(issue.meal.created_at)} (${issue.meal.carbs}g) used ${issue.currentSchedule} CR (${issue.currentCR} g/U) but occurred ${issue.minutesBeforeBoundary} minutes before ${issue.nextSchedule} boundary. This schedule is ${issue.crDifference.toFixed(0)}% stronger than the ${issue.nextSchedule} CR (${issue.nextCR} g/U), causing subsequent low. Recommend moving ${issue.nextSchedule} boundary to ${suggestedBoundary} (maintains ${Math.floor(issue.gapMinutes / 60)}h ${issue.gapMinutes % 60}min gap with ${issue.currentSchedule} schedule).`,
                        confidence: { level: 'High', score: 85 },
                        priority: 'MEDIUM',
                        events: [issue.meal],
                        safetyNote: `Schedule boundary mismatch - meal using too-strong CR due to timing`,
                        suggestedBoundary: suggestedBoundary
                    });
                });
                
                console.log(`Schedule Boundary Analysis complete: ${recommendations.length} boundary adjustments recommended\n`);
                return recommendations;
            };
            
            /**
             * DETECTOR 1: Direct Meal-Induced Lows
             * Priority: 1.5 (Safety - Less Specific Pattern)
             * Pattern: Meal -> Low (1-4 hours later) with NO high >180 in between
             * Conclusion: CR too strong (too much upfront insulin)
             */
            const detectDirectMealInducedLows = (lowProblems, nightscoutData, crSchedule, claimedEvents, processedLowIds) => {
                console.log('=== DETECTOR 1: Direct Meal-Induced Lows ===');
                const recommendations = [];
                
                lowProblems.forEach(low => {
                    const lowId = getEventId(low);
                    console.log(`\nProcessing low at ${low.localTime} (${low.bg} mg/dL)`);
                    
                    const lowTime = new Date(low.time);  // Use UTC timestamp
                    const fourHoursAgo = new Date(lowTime - 4 * 60 * 60 * 1000);
                    const twentyMinutesAgo = new Date(lowTime - 20 * 60 * 1000);
                    
                    // Find meals in 20 minutes to 4 hours lookback window
                    const recentMeals = nightscoutData.treatments.filter(t => {
                        if (!t.created_at || !t.carbs || t.carbs <= 0) return false;
                        const tTime = new Date(t.created_at);  // Use UTC timestamp
                        return tTime >= fourHoursAgo && tTime <= twentyMinutesAgo;
                    });
                    
                    console.log(`  Found ${recentMeals.length} meals in lookback window`);
                    recentMeals.forEach(m => {
                        console.log(`    - ${m.localDateTime}: ${m.carbs}g`);
                    });
                    
                    if (recentMeals.length === 0) {
                        console.log(`  X No meals found`);
                        return;
                    }
                    
                    // Get the most recent meal
                    const relevantMeal = recentMeals.reduce((latest, meal) => {
                        const latestTime = new Date(latest.created_at);
                        const mealTime = new Date(meal.created_at);
                        return mealTime > latestTime ? meal : latest;
                    });
                    
                    const mealId = getEventId(relevantMeal);
                    if (claimedEvents.meals.has(mealId)) {
                        console.log(`  X Meal already claimed: ${relevantMeal.localDateTime}`);
                        return;
                    }
                    
                    // Check if BG went >180 between meal and low
                    const mealTime = new Date(relevantMeal.created_at);
                    const bgBetweenMealAndLow = nightscoutData.glucose.filter(reading => {
                        const rTime = new Date(reading.dateString);
                        return rTime > mealTime && rTime < lowTime;
                    });
                    
                    const hadHigh = bgBetweenMealAndLow.some(r => r.sgv > 180);
                    console.log(`  High >180 between meal and low: ${hadHigh ? 'YES' : 'NO'}`);
                    
                    if (hadHigh) {
                        console.log(`  X Had high - leaving for Detector 3`);
                        return; // This is a pattern for Detector 3, not Detector 1
                    }
                    
                    // SAFETY CHECK: Skip if meal was given during existing low
                    const bgAtMealTime = nightscoutData.glucose.find(reading => {
                        const rTime = new Date(reading.dateString);
                        const timeDiff = Math.abs(rTime - mealTime);
                        return timeDiff < 10 * 60 * 1000; // Within 10 minutes
                    });
                    
                    if (bgAtMealTime && bgAtMealTime.sgv < 80) {
                        console.log(`  ! SAFETY: Meal given during low (${bgAtMealTime.sgv} mg/dL) - skipping attribution`);
                        console.log(`  -> Low not caused by this meal's CR - meal eaten during unsafe conditions`);
                        return; // Don't attribute low to this meal
                    }
                    
                    // This is a direct meal-induced low!
                    // CRITICAL: Use MEAL TIME for schedule, not low time
                    const crEntry = getCRForTime(relevantMeal.localDateTime, crSchedule);
                    
                    // Claim the meal (but NOT the low - allow multiple attributions)
                    claimedEvents.meals.add(mealId);
                    
                    // Calculate adjustment based on severity
                    const lowSeverity = low.bg < 55 ? 'severe' : low.bg < 65 ? 'moderate' : 'minor';
                    const adjustmentPercent = lowSeverity === 'severe' ? 10 : 
                                            lowSeverity === 'moderate' ? 7.5 : 5;
                    
                    const newCR = crEntry.value * (1 + adjustmentPercent / 100);
                    
                    recommendations.push({
                        detector: 'Direct Meal-Induced Low',
                        type: 'CR Weakening',
                        reason: 'Meal caused low without causing high (CR too strong)',
                        scheduleTime: crEntry.time,
                        currentValue: crEntry.value,
                        newValue: parseFloat(newCR.toFixed(1)),
                        adjustment: `+${adjustmentPercent}%`,
                        calculation: `${crEntry.value} x ${(1 + adjustmentPercent / 100).toFixed(2)} = ${newCR.toFixed(1)}`,
                        details: `Meal at ${formatTimeForDisplay(relevantMeal.localDateTime)} (${relevantMeal.carbs}g)\n ->  Low ${low.bg} mg/dL at ${formatTimeForDisplay(low.time)}\n\nBG stayed < 180 between meal and low.`,
                        confidence: { level: 'High', score: 90 },
                        priority: 'HIGH',
                        events: [relevantMeal, low],
                        safetyNote: 'Meal insulin causing direct lows - immediate weakening needed'
                    });
                    
                    // Track that this low was processed
                    processedLowIds.add(lowId);
                    
                    console.log(`  OK DETECTED: ${relevantMeal.localDateTime} -> ${low.localTime}`);
                });
                
                console.log(`Detector 1 complete: ${recommendations.length} recommendations\n`);
                return recommendations;
            };

            /**
             * DETECTOR 1b: Transient High with Subsequent Low
             * Priority: 1 (Safety First - More Specific Pattern)
             * Pattern: Meal -> Brief High >180 (<60 min) -> Low (within 3 hours)
             * Conclusion: CR too strong (too much upfront insulin caused brief spike then crash)
             */
            const detectTransientHighWithLow = (lowProblems, nightscoutData, crSchedule, claimedEvents, processedLowIds) => {
                console.log('=== DETECTOR 1b: Transient High with Subsequent Low ===');
                const recommendations = [];
                
                lowProblems.forEach(low => {
                    const lowId = getEventId(low);
                    
                    // Skip if already processed by previous iterations
                    if (processedLowIds.has(lowId)) {
                        console.log(`  Skipping already processed low: ${low.localTime}`);
                        return;
                    }
                    
                    console.log(`\nDetector 1b: Checking low at ${low.localTime} (${low.bg} mg/dL)`);
                    
                    const lowTime = new Date(low.localTime);
                    const fourHoursAgo = new Date(lowTime - 4 * 60 * 60 * 1000);
                    const twentyMinutesAgo = new Date(lowTime - 20 * 60 * 1000);
                    
                    // STEP 1: Find meals in 20min-4hr lookback window
                    const recentMeals = nightscoutData.treatments.filter(t => {
                        if (!t.created_at || !t.carbs || t.carbs <= 0) return false;
                        const tTime = new Date(t.created_at);
                        return tTime >= fourHoursAgo && tTime <= twentyMinutesAgo;
                    });
                    
                    console.log(`  Found ${recentMeals.length} meals in lookback window`);
                    if (recentMeals.length === 0) {
                        console.log(`  X No meals found`);
                        return;
                    }
                    
                    // STEP 2: Check EACH meal for transient high pattern
                    // (Don't just pick most recent - find the meal that actually caused the transient high)
                    let bestMatch = null;
                    let bestMatchScore = 0;
                    
                    for (const meal of recentMeals) {
                        const mealId = getEventId(meal);
                        if (claimedEvents.meals.has(mealId)) {
                            console.log(`  Skipping claimed meal: ${meal.created_at}`);
                            continue;
                        }
                        
                        console.log(`  Checking meal: ${meal.created_at} (${meal.carbs}g)`);
                        
                        // Find BG readings between this meal and the low
                        const mealTime = new Date(meal.created_at);
                        const bgBetweenMealAndLow = nightscoutData.glucose.filter(reading => {
                            const rTime = new Date(reading.dateString);
                            return rTime > mealTime && rTime < lowTime;
                        });
                        
                        console.log(`    BG readings after meal: ${bgBetweenMealAndLow.length}`);
                        
                        // Check for high readings >180
                        const highReadings = bgBetweenMealAndLow.filter(r => r.sgv > 180);
                        console.log(`    High readings >180: ${highReadings.length}`);
                        
                        if (highReadings.length === 0) {
                            console.log(`    X No high after this meal`);
                            continue; // No high after this meal
                        }
                        
                        // Calculate high duration
                        const firstHigh = highReadings[0];
                        const lastHigh = highReadings[highReadings.length - 1];
                        const firstHighTime = new Date(firstHigh.dateString);
                        const lastHighTime = new Date(lastHigh.dateString);
                        const highDurationMinutes = (lastHighTime - firstHighTime) / (1000 * 60);
                        const peakBG = Math.max(...highReadings.map(r => r.sgv));
                        
                        console.log(`    High duration: ${highDurationMinutes.toFixed(1)} min, peak: ${peakBG} mg/dL`);
                        
                        // Check if high was TRANSIENT (<60 minutes)
                        const HIGH_DURATION_THRESHOLD = 60;
                        if (highDurationMinutes >= HIGH_DURATION_THRESHOLD) {
                            console.log(`    X High too sustained (${highDurationMinutes.toFixed(1)} min >= ${HIGH_DURATION_THRESHOLD} min)`);
                            continue; // Sustained high - not transient
                        }
                        
                        // Check if low occurred within 3 hours of high ending
                        const timeFromHighToLowHours = (lowTime - lastHighTime) / (1000 * 60 * 60);
                        console.log(`    Time from high to low: ${timeFromHighToLowHours.toFixed(1)} hours`);
                        
                        const TIME_TO_LOW_THRESHOLD = 3;
                        if (timeFromHighToLowHours > TIME_TO_LOW_THRESHOLD) {
                            console.log(`    X Low too delayed (${timeFromHighToLowHours.toFixed(1)} hrs > ${TIME_TO_LOW_THRESHOLD} hrs)`);
                            continue; // Low too far after high
                        }
                        
                        // Check for corrections between high and low
                        const correctionsDuringPeriod = nightscoutData.treatments.filter(t => {
                            if (!isTrueCorrection(t, nightscoutData.treatments)) return false;
                            const tTime = new Date(t.created_at);
                            return tTime >= firstHighTime && tTime <= lowTime;
                        });
                        
                        console.log(`    Corrections during period: ${correctionsDuringPeriod.length}`);
                        
                        if (correctionsDuringPeriod.length > 0) {
                            console.log(`    X Corrections were given - not pure meal effect`);
                            continue; // Corrections given - not pure meal effect
                        }
                        
                        // This meal has the transient high pattern!
                        // Score it based on peak BG and how close the timing is
                        const score = peakBG + (100 / (timeFromHighToLowHours + 0.1)); // Higher peak + shorter time = higher score
                        console.log(`    OK MATCH! Score: ${score.toFixed(1)}`);
                        
                        if (score > bestMatchScore) {
                            bestMatch = {
                                meal: meal,
                                mealId: mealId,
                                highReadings: highReadings,
                                firstHigh: firstHigh,
                                lastHigh: lastHigh,
                                firstHighTime: firstHighTime,
                                lastHighTime: lastHighTime,
                                highDurationMinutes: highDurationMinutes,
                                peakBG: peakBG,
                                timeFromHighToLowHours: timeFromHighToLowHours
                            };
                            bestMatchScore = score;
                        }
                    }
                    
                    // If no meal matched the transient high pattern, skip this low
                    if (!bestMatch) {
                        console.log(`  X No meal with transient high pattern found`);
                        return;
                    }
                    
                    console.log(`  OK Best match: ${bestMatch.meal.created_at} (${bestMatch.meal.carbs}g) with score ${bestMatchScore.toFixed(1)}`);
                    
                    // STEP 3: TRANSIENT HIGH DETECTED!
                    console.log(`  ** TRANSIENT HIGH DETECTED!`);
                    console.log(`  -> Brief spike (${bestMatch.highDurationMinutes.toFixed(1)} min) -> crash (${bestMatch.timeFromHighToLowHours.toFixed(1)} hrs)`);
                    console.log(`  -> Excessive insulin dosing`);
                    
                    // Use MEAL TIME for CR schedule
                    const crEntry = getCRForTime(bestMatch.meal.created_at, crSchedule);
                    
                    // Claim the events
                    claimedEvents.meals.add(bestMatch.mealId);
                    bestMatch.highReadings.forEach(h => {
                        claimedEvents.highs.add(getEventId(h));
                    });
                    
                    // Calculate adjustment based on severity
                    // More severe if: higher peak, shorter duration to crash, lower low
                    let adjustmentPercent;
                    if (low.bg < 55 || bestMatch.peakBG > 220) {
                        adjustmentPercent = 10; // Severe
                    } else if (low.bg < 65 || bestMatch.peakBG > 200) {
                        adjustmentPercent = 7.5; // Moderate
                    } else {
                        adjustmentPercent = 5; // Minor
                    }
                    
                    const newCR = crEntry.value * (1 + adjustmentPercent / 100);
                    
                    recommendations.push({
                        detector: 'Transient High with Subsequent Low',
                        type: 'CR Weakening',
                        reason: 'Meal caused brief spike then crashed to low (too much insulin)',
                        scheduleTime: crEntry.time,
                        currentValue: crEntry.value,
                        newValue: parseFloat(newCR.toFixed(1)),
                        adjustment: `+${adjustmentPercent}%`,
                        calculation: `${crEntry.value} x ${(1 + adjustmentPercent / 100).toFixed(2)} = ${newCR.toFixed(1)}`,
                        details: `Meal at ${formatTimeForDisplay(bestMatch.meal.created_at)} (${bestMatch.meal.carbs}g)\n ->  Brief high ${bestMatch.peakBG} mg/dL (${bestMatch.highDurationMinutes.toFixed(0)} min)\n ->  Low ${low.bg} mg/dL at ${formatTimeForDisplay(low.time)} (${bestMatch.timeFromHighToLowHours.toFixed(1)}h later)\n\nPeak-to-crash pattern indicates excessive insulin.`,
                        confidence: { level: 'High', score: 90 },
                        priority: 'HIGH',
                        events: [bestMatch.meal, bestMatch.firstHigh, bestMatch.lastHigh, low],
                        safetyNote: 'Transient spike followed by crash - too much upfront insulin causing both high and low'
                    });
                    
                    // Track that this low was processed
                    processedLowIds.add(lowId);
                    
                    console.log(`  OK DETECTED: ${bestMatch.meal.localDateTime} -> ${low.localTime}`);
                });
                
                console.log(`Detector 1b complete: ${recommendations.length} recommendations\n`);
                return recommendations;
            };

            /**
             * DETECTOR 2: Correction Overcorrection
             * Priority: 2 (ISF Issue)
             * Pattern: High >180 -> Corrections (within 1hr) -> Low (1-3 hours later)
             * Conclusion: ISF too strong (corrections too aggressive)
             */
            const detectCorrectionOvercorrection = (lowProblems, nightscoutData, isfSchedule, claimedEvents, processedLowIds) => {
                console.log('=== DETECTOR 2: Correction Overcorrection ===');
                const recommendations = [];
                
                lowProblems.forEach(low => {
                    const lowId = getEventId(low);
                    
                    // NOTE: We intentionally do NOT skip lows in processedLowIds here.
                    // This allows us to detect stacking scenarios where BOTH:
                    // - Detector 1 found: Meal -> Low (CR too strong)
                    // - Detector 2 finds: Corrections -> Same Low (ISF too strong)
                    // Both recommendations may be valid if meal + corrections stacked.
                    
                    console.log(`\nDetector 2: Checking low at ${low.localTime} (${low.bg} mg/dL)`);
                    
                    const lowTime = new Date(low.time);  // Use UTC timestamp
                    const threeHoursAgo = new Date(lowTime - 3 * 60 * 60 * 1000);
                    const oneHourAgo = new Date(lowTime - 1 * 60 * 60 * 1000);
                    
                    console.log(`  Looking for treatments between ${oneHourAgo.toISOString()} and ${lowTime.toISOString()}`);
                    
                    // First, find ALL treatments with insulin in the window (before filtering)
                    const allInsulinInWindow = nightscoutData.treatments.filter(t => {
                        if (!t.created_at) return false;
                        const tTime = new Date(t.created_at);  // Use UTC timestamp
                        if (tTime < oneHourAgo || tTime > lowTime) return false;
                        return t.insulin && t.insulin > 0;
                    });
                    
                    console.log(`  Found ${allInsulinInWindow.length} total treatments with insulin in window`);
                    allInsulinInWindow.forEach(t => {
                        const isCorrection = isTrueCorrection(t, nightscoutData.treatments);
                        console.log(`    ${t.localDateTime}: ${t.insulin}U, eventType: ${t.eventType || 'none'}, carbs: ${t.carbs || 0}, isCorrection: ${isCorrection}`);
                    });
                    
                    // Find corrections in 1-3 hour lookback window
                    const recentCorrections = nightscoutData.treatments.filter(t => {
                        if (!t.created_at || !t.insulin || t.insulin <= 0) return false;
                        const tTime = new Date(t.created_at);
                        if (tTime < oneHourAgo || tTime > lowTime) return false;
                        
                        // Allow using corrections even if claimed by other detectors (for stacking scenarios)
                        // const correctionId = getEventId(t);
                        // if (claimedEvents.corrections.has(correctionId)) return false;
                        
                        return isTrueCorrection(t, nightscoutData.treatments);
                    });
                    
                    if (recentCorrections.length === 0) {
                        console.log(`  X No corrections found (after filtering)`);
                        return; // No corrections
                    }
                    
                    // CRITICAL: Find the high that these corrections were addressing
                    // Look back up to 6 hours from earliest correction
                    const earliestCorrectionTime = new Date(
                        Math.min(...recentCorrections.map(c => new Date(c.created_at)))
                    );
                    const sixHoursBeforeCorrection = new Date(earliestCorrectionTime - 6 * 60 * 60 * 1000);
                    
                    const bgBeforeCorrections = nightscoutData.glucose.filter(reading => {
                        const rTime = new Date(reading.dateString);
                        return rTime >= sixHoursBeforeCorrection && rTime <= earliestCorrectionTime;
                    });
                    
                    // Check if ANY high >180 occurred within 3 hours BEFORE corrections
                    const threeHoursBeforeCorrection = new Date(earliestCorrectionTime - 3 * 60 * 60 * 1000);
                    const highReadings = bgBeforeCorrections.filter(r => {
                        const rTime = new Date(r.dateString);
                        return r.sgv > 180 && rTime >= threeHoursBeforeCorrection && rTime <= earliestCorrectionTime;
                    });
                    
                    if (highReadings.length === 0) {
                        console.log(`Skipping - no high within 3hrs before corrections`);
                        return; // No high within 3 hours before corrections
                    }
                    
                    // Find the last high reading for reporting
                    const lastHighReading = highReadings.reduce((latest, r) => {
                        const latestTime = new Date(latest.dateString);
                        const rTime = new Date(r.dateString);
                        return rTime > latestTime ? r : latest;
                    });
                    
                    // Check for new meal with significant carbs between corrections and low
                    const mealsBetweenCorrectionAndLow = nightscoutData.treatments.filter(t => {
                        if (!t.created_at || !t.carbs || t.carbs < 15) return false;
                        const tTime = new Date(t.created_at);
                        return tTime > earliestCorrectionTime && tTime < lowTime;
                    });
                    
                    // Don't skip if meal found - flag as potential stacking scenario
                    const hasStacking = mealsBetweenCorrectionAndLow.length > 0;
                    
                    // This is correction overcorrection (possibly with stacking)!
                    // CRITICAL: Use CORRECTION TIME for ISF schedule, not low time
                    const isfEntry = getISFForTime(earliestCorrectionTime.toISOString(), isfSchedule);
                    
                    // Claim corrections and highs (but NOT lows - allow multiple attributions)
                    recentCorrections.forEach(c => {
                        claimedEvents.corrections.add(getEventId(c));
                    });
                    highReadings.forEach(h => {
                        claimedEvents.highs.add(getEventId(h));
                    });
                    
                    const totalCorrectionInsulin = recentCorrections.reduce((sum, c) => sum + c.insulin, 0);
                    // AGGRESSIVE adjustment for ISF Weakening (fixing lows - safety priority)
                    // Same logic as CR Weakening: lows are dangerous, fix quickly
                    const adjustmentPercent = low.bg < 55 ? 10 : low.bg < 65 ? 7.5 : 5;
                    const newISF = isfEntry.value * (1 + adjustmentPercent / 100);
                    
                    let reason = 'Corrections too aggressive for high (ISF too strong)';
                    let confidence = { level: 'Medium', score: 70 };
                    let details = `High ${lastHighReading.sgv} mg/dL at ${formatTimeForDisplay(lastHighReading.dateString)}\n ->  ${recentCorrections.length} correction${recentCorrections.length > 1 ? 's' : ''} (${totalCorrectionInsulin.toFixed(2)}U)\n ->  Low ${low.bg} mg/dL at ${formatTimeForDisplay(low.time)}`;
                    
                    if (hasStacking) {
                        reason += ' - possible insulin stacking with meal';
                        confidence = { level: 'Medium', score: 60 };
                        details += `\n\nNote: ${mealsBetweenCorrectionAndLow.length} meal(s) between corrections and low may have contributed.`;
                    }
                    
                    recommendations.push({
                        detector: 'Correction Overcorrection',
                        type: 'ISF Weakening',
                        reason: reason,
                        scheduleTime: isfEntry.time,
                        currentValue: isfEntry.value,
                        newValue: parseFloat(newISF.toFixed(1)),
                        adjustment: `+${adjustmentPercent}%`,
                        calculation: `${isfEntry.value} x ${(1 + adjustmentPercent / 100).toFixed(2)} = ${newISF.toFixed(1)}`,
                        details: details,
                        confidence: confidence,
                        priority: low.bg < 65 ? 'HIGH' : 'MEDIUM',  // Safety priority for dangerous lows
                        events: [lastHighReading, ...recentCorrections, low],
                        safetyNote: hasStacking ? 'Corrections + meal insulin stacking - ISF may be too strong' : 'Corrections causing lows - ISF too strong'
                    });
                    
                    // Track that this low was processed
                    processedLowIds.add(lowId);
                    
                    console.log(`OK Found correction overcorrection: High at ${lastHighReading.localDateTime} -> Low at ${low.localTime}${hasStacking ? ' (with stacking)' : ''}`);
                });
                
                console.log(`Detector 2 complete: ${recommendations.length} recommendations`);
                return recommendations;
            };

            /**
             * DETECTOR 2b: Correction Ineffectiveness
             * Priority: 2.5 (Optimization - ISF too weak)
             * Pattern: Sustained BG above target + Corrections delivered + BG didn't reach target + No low
             * Conclusion: ISF too weak (corrections not achieving predicted drop)
             * Focus: Overnight in 2-hour segments (22-00, 00-02, 02-04, 04-06, 06-07) and pre-breakfast (07-08)
             */
            const detectCorrectionIneffectiveness = (nightscoutData, isfSchedule, claimedEvents, analysisStartDateTime) => {
                console.log('=== DETECTOR 2b: Correction Ineffectiveness ===');
                const recommendations = [];
                
                // Get iAPS target from profile
                let iapsTarget = 100; // Default fallback
                if (nightscoutData.profile && nightscoutData.profile.length > 0) {
                    const profile = nightscoutData.profile[0];
                    if (profile.store && profile.store.default) {
                        // Try target_low and target_high, use average
                        const targetLow = profile.store.default.target_low?.[0]?.value;
                        const targetHigh = profile.store.default.target_high?.[0]?.value;
                        if (targetLow && targetHigh) {
                            iapsTarget = (targetLow + targetHigh) / 2;
                        } else if (targetLow) {
                            iapsTarget = targetLow;
                        } else if (targetHigh) {
                            iapsTarget = targetHigh;
                        }
                    }
                }
                
                // Also check deviceStatus for dynamic target
                if (nightscoutData.deviceStatus && nightscoutData.deviceStatus.length > 0) {
                    for (const status of nightscoutData.deviceStatus.slice(0, 5)) {
                        if (status.openaps?.suggested?.bg) {
                            // This is the current target iAPS is using
                            const dynamicTarget = status.openaps.suggested.targetBG || status.openaps.suggested.target_bg;
                            if (dynamicTarget) {
                                iapsTarget = dynamicTarget;
                                break;
                            }
                        }
                    }
                }
                
                console.log(`  iAPS target: ${iapsTarget} mg/dL`);
                
                // Define 2-hour analysis segments (each evaluated independently)
                const analysisSegments = [
                    { name: 'Late Evening', startHour: 22, endHour: 24, label: '22:00-00:00' },
                    { name: 'Early Night', startHour: 0, endHour: 2, label: '00:00-02:00' },
                    { name: 'Mid Night', startHour: 2, endHour: 4, label: '02:00-04:00' },
                    { name: 'Late Night', startHour: 4, endHour: 6, label: '04:00-06:00' },
                    { name: 'Early Morning', startHour: 6, endHour: 7, label: '06:00-07:00' },
                    { name: 'Pre-Breakfast', startHour: 7, endHour: 8, label: '07:00-08:00' }
                ];
                
                // Helper to check if an hour falls within a segment
                const isInSegment = (hour, startHour, endHour) => {
                    if (endHour === 24) endHour = 24; // Handle 22-24 as 22-00
                    return hour >= startHour && hour < endHour;
                };
                
                // Helper to get a unique key for each segment instance
                const getSegmentKey = (readingTime, segment) => {
                    const hour = readingTime.getHours();
                    const date = new Date(readingTime);
                    
                    // For segments after midnight (0-7), use the previous day as the "night of" reference
                    // So 2 AM on Nov 24 is "night of Nov 23"
                    if (segment.startHour < 22 && hour < 12) {
                        date.setDate(date.getDate() - 1);
                    }
                    
                    const nightOfDate = date.toISOString().split('T')[0];
                    return `${nightOfDate}_${segment.label}`;
                };
                
                // Group glucose readings by segment
                const segmentAnalysis = {};
                
                nightscoutData.glucose.forEach(reading => {
                    const readingTime = new Date(reading.dateString);
                    if (readingTime < analysisStartDateTime) return;
                    
                    const hour = readingTime.getHours();
                    
                    analysisSegments.forEach(segment => {
                        if (isInSegment(hour, segment.startHour, segment.endHour)) {
                            const key = getSegmentKey(readingTime, segment);
                            if (!segmentAnalysis[key]) {
                                segmentAnalysis[key] = {
                                    segment: segment,
                                    key: key,
                                    readings: [],
                                    corrections: [],
                                    hasLow: false
                                };
                            }
                            segmentAnalysis[key].readings.push(reading);
                            
                            // Check for lows
                            if (reading.sgv <= 70) {
                                segmentAnalysis[key].hasLow = true;
                            }
                        }
                    });
                });
                
                // Add corrections to each segment
                nightscoutData.treatments.forEach(t => {
                    if (!isTrueCorrection(t, nightscoutData.treatments)) return;
                    
                    const tTime = new Date(t.created_at);
                    if (tTime < analysisStartDateTime) return;
                    
                    const hour = tTime.getHours();
                    
                    analysisSegments.forEach(segment => {
                        if (isInSegment(hour, segment.startHour, segment.endHour)) {
                            const key = getSegmentKey(tTime, segment);
                            if (segmentAnalysis[key]) {
                                segmentAnalysis[key].corrections.push(t);
                            }
                        }
                    });
                });
                
                // Analyze each segment independently
                Object.values(segmentAnalysis).forEach(analysis => {
                    const { segment, key, readings, corrections, hasLow } = analysis;
                    
                    console.log(`\n  Analyzing ${segment.name} (${segment.label}) - ${key}:`);
                    console.log(`    Readings: ${readings.length}, Corrections: ${corrections.length}, Has Low: ${hasLow}`);
                    
                    // Skip if had a low (not safe to strengthen THIS segment)
                    if (hasLow) {
                        console.log(`    -> Skipping: Low occurred in this segment`);
                        return;
                    }
                    
                    // Check for treatment rebound pattern (unannounced carb treatment)
                    // Pattern: Low followed by rapid rise (>2 mg/dL/min) to >130
                    let hadTreatmentRebound = false;
                    for (let i = 0; i < readings.length - 1; i++) {
                        const reading = readings[i];
                        if (reading.sgv >= 70) continue; // Not a low
                        
                        // Look for rapid rise in next 30 minutes (next ~6 readings at 5-min intervals)
                        const nextReadings = readings.slice(i + 1, Math.min(i + 7, readings.length));
                        if (nextReadings.length === 0) continue;
                        
                        const peakAfterLow = Math.max(...nextReadings.map(r => r.sgv));
                        const minutesElapsed = nextReadings.length * 5; // Approximate
                        const riseRate = (peakAfterLow - reading.sgv) / minutesElapsed; // mg/dL per minute
                        
                        // Fast rise (>2 mg/dL/min) to >130 suggests carb treatment
                        if (riseRate > 2 && peakAfterLow > 130) {
                            hadTreatmentRebound = true;
                            console.log(`    -> Treatment rebound detected: Low ${reading.sgv} -> Peak ${peakAfterLow} (${riseRate.toFixed(1)} mg/dL/min)`);
                            break;
                        }
                    }
                    
                    if (hadTreatmentRebound) {
                        console.log(`    -> Skipping: High BG likely from treating low, not weak ISF`);
                        return;
                    }
                    
                    // Skip if no corrections (nothing to evaluate)
                    if (corrections.length === 0) {
                        console.log(`    -> Skipping: No corrections in segment`);
                        return;
                    }
                    
                    // Skip if not enough readings (need at least 20 min of data)
                    if (readings.length < 4) {
                        console.log(`    -> Skipping: Insufficient readings`);
                        return;
                    }
                    
                    // Calculate time spent above target
                    const aboveTarget = readings.filter(r => r.sgv > iapsTarget);
                    const aboveTargetPercent = (aboveTarget.length / readings.length) * 100;
                    const avgBG = readings.reduce((sum, r) => sum + r.sgv, 0) / readings.length;
                    const avgAboveTarget = avgBG - iapsTarget;
                    
                    console.log(`    Above target (${iapsTarget}): ${aboveTargetPercent.toFixed(0)}% of time`);
                    console.log(`    Avg BG: ${avgBG.toFixed(0)} mg/dL (${avgAboveTarget.toFixed(0)} above target)`);
                    
                    // Threshold: >60% of time above target with corrections delivered
                    if (aboveTargetPercent < 60) {
                        console.log(`    -> Skipping: Not sustained above target`);
                        return;
                    }
                    
                    // Smart threshold: consider both how far above target AND correction effort
                    // Skip only if: avgAboveTarget < 5, OR (avgAboveTarget < 10 AND corrections < 3)
                    // This catches cases where many corrections still couldn't reach target
                    if (avgAboveTarget < 5) {
                        console.log(`    -> Skipping: Average only ${avgAboveTarget.toFixed(0)} above target (too close)`);
                        return;
                    }
                    
                    if (avgAboveTarget < 10 && corrections.length < 3) {
                        console.log(`    -> Skipping: Average ${avgAboveTarget.toFixed(0)} above target with only ${corrections.length} corrections (insufficient signal)`);
                        return;
                    }
                    
                    // Calculate total correction insulin in segment
                    const totalCorrectionInsulin = corrections.reduce((sum, c) => sum + (c.insulin || 0), 0);
                    
                    // This is a correction ineffectiveness pattern!
                    console.log(`    -> DETECTED: Corrections ineffective (${corrections.length} corrections couldn't reach target)`);
                    
                    // Get ISF for this time segment
                    const segmentMidpointHour = (segment.startHour + segment.endHour) / 2;
                    const isfTime = `${Math.floor(segmentMidpointHour).toString().padStart(2, '0')}:00`;
                    const isfEntry = getISFForTime(`2000-01-01T${isfTime}:00`, isfSchedule);
                    
                    // Conservative strengthening (1-3% based on how far above target)
                    let adjustmentPercent;
                    if (avgAboveTarget > 40) {
                        adjustmentPercent = 3;
                    } else if (avgAboveTarget > 25) {
                        adjustmentPercent = 2;
                    } else {
                        adjustmentPercent = 1;
                    }
                    
                    const newISF = isfEntry.value * (1 - adjustmentPercent / 100);
                    
                    // Build details with target callout if >95
                    let details = `${segment.name} (${segment.label}): BG averaged ${avgBG.toFixed(0)} mg/dL, staying above ${iapsTarget} target ${aboveTargetPercent.toFixed(0)}% of the time despite ${corrections.length} corrections (${totalCorrectionInsulin.toFixed(2)}U total).`;
                    
                    let targetNote = null;
                    if (iapsTarget > 95) {
                        targetNote = `Your iAPS target is ${iapsTarget} mg/dL. Consider lowering to 90-95 for tighter overnight control before strengthening ISF.`;
                    }
                    
                    recommendations.push({
                        detector: 'Correction Ineffectiveness',
                        type: 'ISF Strengthening',
                        reason: `${segment.name} corrections not reaching target (ISF too weak)`,
                        scheduleTime: isfEntry.time,
                        currentValue: isfEntry.value,
                        newValue: parseFloat(newISF.toFixed(1)),
                        adjustment: `-${adjustmentPercent}%`,
                        calculation: `${isfEntry.value} x ${(1 - adjustmentPercent / 100).toFixed(2)} = ${newISF.toFixed(1)}`,
                        details: details,
                        confidence: { level: 'Medium', score: 70 },
                        priority: 'MEDIUM',
                        events: corrections,
                        ...(targetNote && { safetyNote: targetNote }),
                        segmentAnalysis: {
                            segment: segment.name,
                            timeRange: segment.label,
                            avgBG: avgBG,
                            aboveTargetPercent: aboveTargetPercent,
                            iapsTarget: iapsTarget,
                            correctionsCount: corrections.length,
                            totalInsulin: totalCorrectionInsulin
                        }
                    });
                });
                
                console.log(`\nDetector 2b complete: ${recommendations.length} recommendations`);
                return recommendations;
            };

            /**
             * DETECTOR 3: Post-Meal Highs with Corrections
             * Priority: 3 (CR Weakness)
             * Pattern: Meal -> High >180 -> Corrections (with or without subsequent low)
             * Conclusion: CR too weak (not enough upfront insulin)
             */
            const detectPostMealHighsWithCorrections = (lowProblems, nightscoutData, crSchedule, claimedEvents, processedLowIds) => {
                console.log('=== DETECTOR 3: Post-Meal Highs with Corrections ===');
                const recommendations = [];
                
                // PASS 1: Traditional pattern - Meal -> High -> Corrections -> Low
                lowProblems.forEach(low => {
                    const lowId = getEventId(low);
                    
                    // NOTE: We intentionally do NOT skip lows in processedLowIds here.
                    // This allows detection of complex stacking scenarios.
                    
                    const lowTime = new Date(low.time);
                    const fourHoursAgo = new Date(lowTime - 4 * 60 * 60 * 1000);
                    const twoHoursAgo = new Date(lowTime - 2 * 60 * 60 * 1000);
                    
                    // Find corrections in 2-4 hour lookback window
                    const recentCorrections = nightscoutData.treatments.filter(t => {
                        if (!t.created_at || !t.insulin || t.insulin <= 0) return false;
                        const tTime = new Date(t.created_at);
                        if (tTime < twoHoursAgo || tTime > lowTime) return false;
                        
                        const correctionId = getEventId(t);
                        if (claimedEvents.corrections.has(correctionId)) return false;
                        
                        return isTrueCorrection(t, nightscoutData.treatments);
                    });
                    
                    if (recentCorrections.length === 0) return; // No corrections
                    
                    // Find the high that these corrections were addressing
                    const earliestCorrectionTime = new Date(
                        Math.min(...recentCorrections.map(c => new Date(c.created_at)))
                    );
                    const sixHoursBeforeCorrection = new Date(earliestCorrectionTime - 6 * 60 * 60 * 1000);
                    
                    const bgBeforeCorrections = nightscoutData.glucose.filter(reading => {
                        const rTime = new Date(reading.dateString);
                        return rTime >= sixHoursBeforeCorrection && rTime <= earliestCorrectionTime;
                    });
                    
                    // Was there a high >180?
                    const highReadings = bgBeforeCorrections.filter(r => r.sgv > 180);
                    if (highReadings.length === 0) return; // No high
                    
                    // Check if high occurred within 3 hours before corrections
                    const threeHoursBeforeCorrection = new Date(earliestCorrectionTime - 3 * 60 * 60 * 1000);
                    const recentHighReadings = highReadings.filter(r => {
                        const rTime = new Date(r.dateString);
                        return rTime >= threeHoursBeforeCorrection;
                    });
                    
                    if (recentHighReadings.length === 0) {
                        console.log(`Skipping - no high within 3hrs before corrections`);
                        return;
                    }
                    
                    // Find the last high reading from recent highs
                    const lastHighReading = recentHighReadings.reduce((latest, r) => {
                        const latestTime = new Date(latest.localDateTime);
                        const rTime = new Date(r.dateString);
                        return rTime > latestTime ? r : latest;
                    });
                    
                    // Find the meal that caused the high
                    // Look back 1-4 hours BEFORE the high started
                    const earliestHighReading = highReadings.reduce((earliest, r) => {
                        const earliestTime = new Date(earliest.localDateTime);
                        const rTime = new Date(r.dateString);
                        return rTime < earliestTime ? r : earliest;
                    });
                    
                    const highStartTime = new Date(earliestHighReading.localDateTime);
                    const fourHoursBeforeHigh = new Date(highStartTime - 4 * 60 * 60 * 1000);
                    const oneHourBeforeHigh = new Date(highStartTime - 1 * 60 * 60 * 1000);
                    
                    // Find meals in this window
                    const potentialMeals = nightscoutData.treatments.filter(t => {
                        if (!t.created_at || !t.carbs || t.carbs <= 0) return false;
                        const tTime = new Date(t.created_at);
                        return tTime >= oneHourBeforeHigh && tTime <= highStartTime;
                    });
                    
                    if (potentialMeals.length === 0) return; // No meal found
                    
                    // Get the most recent meal before the high
                    const relevantMeal = potentialMeals.reduce((latest, meal) => {
                        const latestTime = new Date(latest.localDateTime);
                        const mealTime = new Date(meal.created_at);
                        return mealTime > latestTime ? meal : latest;
                    });
                    
                    const mealId = getEventId(relevantMeal);
                    if (claimedEvents.meals.has(mealId)) {
                        console.log(`Skipping - meal already claimed: ${relevantMeal.localDateTime}`);
                        return;
                    }
                    
                    // SAFETY CHECK: Check if this is a rebound high (not weak CR)
                    const mealTime = new Date(relevantMeal.created_at);
                    
                    // SURGICAL FIX: Get CR entry FIRST (needed for safety calculations)
                    const crEntry = getCRForTime(relevantMeal.localDateTime, crSchedule);
                    
                    if (!crEntry) {
                        console.log(`  ! Could not determine CR schedule for meal at ${relevantMeal.localDateTime} - skipping`);
                        return;
                    }
                    
                    // ===== SIGNAL 1: Meal during low (SIMPLEST, MOST RELIABLE) =====
                    const bgAtMealTime = nightscoutData.glucose.find(reading => {
                        const rTime = new Date(reading.dateString);
                        const timeDiff = Math.abs(rTime - mealTime);
                        return timeDiff < 10 * 60 * 1000;
                    });
                    const mealDuringLow = bgAtMealTime && bgAtMealTime.sgv < 80;
                    
                    // ===== SIGNAL 2: Underdosing with IOB check (ONLY if BG wasn't low) =====
                    let isSafetyReduction = false;
                    const peakBG = Math.max(...highReadings.map(r => r.sgv));
                    
                    if (!mealDuringLow && relevantMeal.carbs > 0) {
                        const expectedBolus = relevantMeal.carbs / crEntry.value;
                        const actualBolus = relevantMeal.insulin || 0;
                        const percentGiven = (actualBolus / expectedBolus) * 100;
                        
                        if (percentGiven < 70) {
                            // Get IOB at meal time
                            const iobAtMealTime = getIOBAtTime(nightscoutData.deviceStatus, mealTime);
                            
                            if (iobAtMealTime && iobAtMealTime > 1.0) {
                                // High IOB explains the reduction - not safety
                                console.log(`  -> High IOB (${iobAtMealTime.toFixed(2)}U) explains underdosing`);
                                isSafetyReduction = false;
                            } else {
                                // Low/no IOB but still underdosed - safety reduction
                                console.log(`  -> Underdosed (${percentGiven.toFixed(0)}%) with low IOB (${iobAtMealTime?.toFixed(2) || 0}U) - safety reduction`);
                                isSafetyReduction = true;
                            }
                        }
                    }
                    
                    // ===== If EITHER signal present, check for severe low + rebound =====
                    if (mealDuringLow || isSafetyReduction) {
                        // Check if severe low occurred within 2 hours after meal
                        const twoHoursAfterMeal = new Date(mealTime.getTime() + 2 * 60 * 60 * 1000);
                        const severeLowReadings = nightscoutData.glucose.filter(reading => {
                            const rTime = new Date(reading.dateString);
                            return rTime > mealTime && rTime <= twoHoursAfterMeal && reading.sgv < 55;
                        });
                        
                        if (severeLowReadings.length > 0) {
                            const lowestReading = severeLowReadings.reduce((min, r) => r.sgv < min.sgv ? r : min);
                            
                            if (mealDuringLow) {
                                console.log(`  ! REBOUND HIGH: Meal during low (${bgAtMealTime.sgv}) -> severe low (${lowestReading.sgv}) -> spike (${peakBG})`);
                            } else {
                                console.log(`  ! REBOUND HIGH: Safety underdosing -> severe low (${lowestReading.sgv}) -> spike (${peakBG})`);
                            }
                            console.log(`  -> High from hypoglycemia treatment/rebound, not weak CR`);
                            
                            // Create informational flag instead of CR strengthening
                            recommendations.push({
                                detector: 'Rebound High Detection (Pass 1)',
                                type: 'Informational',
                                pattern: 'Severe Hypoglycemia with Rebound',
                                scheduleTime: crEntry.time,
                                currentValue: crEntry.value,
                                newValue: crEntry.value, // No change recommended
                                adjustment: 'None',
                                reason: 'High is physiological rebound from severe hypoglycemia, not weak CR',
                                calculation: 'N/A',
                                details: `Meal at ${formatTimeForDisplay(relevantMeal.created_at)} (${relevantMeal.carbs}g) ${mealDuringLow ? `during low (${bgAtMealTime.sgv} mg/dL)` : 'with safety underdosing'}  ->  Severe low ${lowestReading.sgv} mg/dL at ${formatTimeForDisplay(lowestReading.dateString)}  ->  Rebound spike to ${peakBG} mg/dL.\n\nPattern indicates need for:\n1. Better meal timing (avoid eating during lows)\n2. Adequate low treatment (~15g fast carbs)\n3. Monitor for rebounds after severe lows\n\nThis high is NOT due to weak CR - it's a physiological response to severe hypoglycemia.`,
                                confidence: { level: 'High', score: 95 },
                                priority: 'INFORMATIONAL',
                                events: [relevantMeal, lowestReading, ...highReadings],
                                safetyNote: 'Rebound high from severe hypoglycemia - no CR adjustment needed'
                            });
                            
                            return; // Skip CR strengthening recommendation
                        }
                    }
                    
                    // This is a post-meal high with corrections leading to low!
                    // CRITICAL: Use MEAL TIME for CR schedule, not low time
                    
                    // Claim the events
                    claimedEvents.meals.add(mealId);
                    recentCorrections.forEach(c => {
                        claimedEvents.corrections.add(getEventId(c));
                    });
                    highReadings.forEach(h => {
                        claimedEvents.highs.add(getEventId(h));
                    });
                    
                    const totalCorrectionInsulin = recentCorrections.reduce((sum, c) => sum + c.insulin, 0);
                    
                    // Calculate adjustment based on high severity (CONSERVATIVE: 1-3% for highs)
                    // Highs are less dangerous than lows, so we adjust slowly and let changes compound daily
                    const adjustmentPercent = peakBG > 250 ? 3 : peakBG > 220 ? 2 : 1;
                    const newCR = crEntry.value * (1 - adjustmentPercent / 100);
                    
                    recommendations.push({
                        detector: 'Post-Meal High with Corrections',
                        type: 'CR Strengthening',
                        reason: 'Meal caused high requiring corrections (CR too weak)',
                        scheduleTime: crEntry.time,
                        currentValue: crEntry.value,
                        newValue: parseFloat(newCR.toFixed(1)),
                        adjustment: `-${adjustmentPercent}%`,
                        calculation: `${crEntry.value} x ${(1 - adjustmentPercent / 100).toFixed(2)} = ${newCR.toFixed(1)}`,
                        details: `Meal at ${formatTimeForDisplay(relevantMeal.created_at)} (${relevantMeal.carbs}g)\n ->  High ${peakBG} mg/dL at ${formatTimeForDisplay(lastHighReading.dateString)}\n ->  ${recentCorrections.length} correction${recentCorrections.length > 1 ? 's' : ''} (${totalCorrectionInsulin.toFixed(2)}U)\n ->  Low ${low.bg} mg/dL at ${formatTimeForDisplay(low.time)}`,
                        confidence: { level: 'High', score: 90 },
                        priority: 'MEDIUM',
                        events: [relevantMeal, earliestHighReading, ...recentCorrections, low],
                        safetyNote: 'Meal causing high - strengthen CR but monitor for stacking'
                    });
                    
                    // Track that this low was processed
                    processedLowIds.add(lowId);
                    
                    console.log(`OK Found post-meal high with corrections -> low: ${relevantMeal.localDateTime}`);
                });
                
                // PASS 2: NEW - Meal -> High -> Corrections (NO low required)
                // Look through all unclaimed meals that caused highs requiring corrections
                const meals = nightscoutData.treatments.filter(t => 
                    t.localDateTime && t.carbs && t.carbs > 0 && !claimedEvents.meals.has(getEventId(t))
                );
                
                meals.forEach(meal => {
                    console.log(`\nPass 2: Checking meal ${meal.localDateTime} (${meal.carbs}g)`);
                    
                    const mealTime = new Date(meal.created_at);
                    const threeHoursAfter = new Date(mealTime.getTime() + 3 * 60 * 60 * 1000);
                    const oneHourAfter = new Date(mealTime.getTime() + 1 * 60 * 60 * 1000);
                    
                    // Find BG readings 1-3 hours after meal
                    const postMealReadings = nightscoutData.glucose.filter(reading => {
                        const rTime = new Date(reading.dateString);
                        return rTime >= oneHourAfter && rTime <= threeHoursAfter;
                    });
                    
                    console.log(`  Post-meal readings: ${postMealReadings.length}`);
                    
                    if (postMealReadings.length === 0) {
                        console.log(`  X No post-meal readings`);
                        return;
                    }
                    
                    // Was there a high >180?
                    const highReadings = postMealReadings.filter(r => r.sgv > 180);
                    console.log(`  High readings >180: ${highReadings.length}`);
                    
                    if (highReadings.length === 0) {
                        console.log(`  X No high >180`);
                        return; // No high
                    }
                    
                    const peakReading = highReadings.reduce((max, r) => r.sgv > max.sgv ? r : max);
                    const peakTime = new Date(peakReading.localDateTime);
                    const peakBG = Math.max(...highReadings.map(r => r.sgv));
                    
                    console.log(`  Peak: ${peakBG} mg/dL at ${peakReading.localDateTime}`);
                    
                    // Check if ANY corrections were given for this high (claimed or unclaimed)
                    const allCorrections = nightscoutData.treatments.filter(t => {
                        if (!isTrueCorrection(t, nightscoutData.treatments)) return false;
                        const tTime = new Date(t.created_at);
                        return tTime >= peakTime && tTime <= threeHoursAfter;
                    });
                    
                    const unclaimedCorrections = allCorrections.filter(c => 
                        !claimedEvents.corrections.has(getEventId(c))
                    );
                    
                    console.log(`  Total corrections found: ${allCorrections.length}`);
                    console.log(`  Unclaimed corrections: ${unclaimedCorrections.length}`);
                    console.log(`  Claimed corrections: ${allCorrections.length - unclaimedCorrections.length}`);
                    
                    // SURGICAL FIX: Get CR entry FIRST (needed for safety calculations)
                    const crEntry = getCRForTime(meal.localDateTime, crSchedule);
                    
                    if (!crEntry) {
                        console.log(`  ! Could not determine CR schedule for meal at ${meal.localDateTime} - skipping`);
                        return;
                    }
                    
                    // SAFETY CHECK: Check if this is a rebound high (not weak CR)
                    // ===== SIGNAL 1: Meal during low (SIMPLEST, MOST RELIABLE) =====
                    const bgAtMealTime = nightscoutData.glucose.find(reading => {
                        const rTime = new Date(reading.dateString);
                        const timeDiff = Math.abs(rTime - mealTime);
                        return timeDiff < 10 * 60 * 1000;
                    });
                    const mealDuringLow = bgAtMealTime && bgAtMealTime.sgv < 80;
                    
                    // ===== SIGNAL 2: Underdosing with IOB check (ONLY if BG wasn't low) =====
                    let isSafetyReduction = false;
                    
                    if (!mealDuringLow && meal.carbs > 0) {
                        const expectedBolus = meal.carbs / crEntry.value;
                        const actualBolus = meal.insulin || 0;
                        const percentGiven = (actualBolus / expectedBolus) * 100;
                        
                        if (percentGiven < 70) {
                            // Get IOB at meal time
                            const iobAtMealTime = getIOBAtTime(nightscoutData.deviceStatus, mealTime);
                            
                            if (iobAtMealTime && iobAtMealTime > 1.0) {
                                // High IOB explains the reduction - not safety
                                console.log(`  -> High IOB (${iobAtMealTime.toFixed(2)}U) explains underdosing`);
                                isSafetyReduction = false;
                            } else {
                                // Low/no IOB but still underdosed - safety reduction
                                console.log(`  -> Underdosed (${percentGiven.toFixed(0)}%) with low IOB (${iobAtMealTime?.toFixed(2) || 0}U) - safety reduction`);
                                isSafetyReduction = true;
                            }
                        }
                    }
                    
                    // ===== If EITHER signal present, check for severe low + rebound =====
                    if (mealDuringLow || isSafetyReduction) {
                        // Check if severe low occurred within 2 hours after meal
                        const twoHoursAfterMeal = new Date(mealTime.getTime() + 2 * 60 * 60 * 1000);
                        const severeLowReadings = nightscoutData.glucose.filter(reading => {
                            const rTime = new Date(reading.dateString);
                            return rTime > mealTime && rTime <= twoHoursAfterMeal && reading.sgv < 55;
                        });
                        
                        if (severeLowReadings.length > 0) {
                            const lowestReading = severeLowReadings.reduce((min, r) => r.sgv < min.sgv ? r : min);
                            
                            if (mealDuringLow) {
                                console.log(`  ! REBOUND HIGH: Meal during low (${bgAtMealTime.sgv}) -> severe low (${lowestReading.sgv}) -> spike (${peakBG})`);
                            } else {
                                console.log(`  ! REBOUND HIGH: Safety underdosing -> severe low (${lowestReading.sgv}) -> spike (${peakBG})`);
                            }
                            console.log(`  -> High from hypoglycemia treatment/rebound, not weak CR`);
                            
                            // Create informational flag instead of CR strengthening
                            recommendations.push({
                                detector: 'Rebound High Detection (Pass 2)',
                                type: 'Informational',
                                pattern: 'Severe Hypoglycemia with Rebound',
                                scheduleTime: crEntry.time,
                                currentValue: crEntry.value,
                                newValue: crEntry.value, // No change recommended
                                adjustment: 'None',
                                reason: 'High is physiological rebound from severe hypoglycemia, not weak CR',
                                calculation: 'N/A',
                                details: `Meal at ${formatTimeForDisplay(meal.created_at)} (${meal.carbs}g) ${mealDuringLow ? `during low (${bgAtMealTime.sgv} mg/dL)` : 'with safety underdosing'}  ->  Severe low ${lowestReading.sgv} mg/dL at ${formatTimeForDisplay(lowestReading.dateString)}  ->  Rebound spike to ${peakBG} mg/dL.\n\nPattern indicates need for:\n1. Better meal timing (avoid eating during lows)\n2. Adequate low treatment (~15g fast carbs)\n3. Monitor for rebounds after severe lows\n\nThis high is NOT due to weak CR - it's a physiological response to severe hypoglycemia.`,
                                confidence: { level: 'High', score: 95 },
                                priority: 'INFORMATIONAL',
                                events: [meal, lowestReading, ...highReadings],
                                safetyNote: 'Rebound high from severe hypoglycemia - no CR adjustment needed'
                            });
                            
                            console.log(`  -> Skipping CR strengthening - rebound high detected`);
                            return; // Skip CR strengthening recommendation
                        }
                    }
                    
                    // Create recommendation if meal caused high >180 (regardless of corrections)
                    // CONSERVATIVE: 1-3% for highs - less dangerous than lows, compound daily
                    const adjustmentPercent = peakBG > 250 ? 3 : peakBG > 220 ? 2 : 1;
                    const newCR = crEntry.value * (1 - adjustmentPercent / 100);
                    
                    // Claim the events
                    claimedEvents.meals.add(getEventId(meal));
                    highReadings.forEach(h => claimedEvents.highs.add(getEventId(h)));
                    // Only claim unclaimed corrections to avoid conflicts with Detector 2
                    unclaimedCorrections.forEach(c => claimedEvents.corrections.add(getEventId(c)));
                    
                    // Build details and confidence based on correction status
                    let details, confidence, reason;
                    if (allCorrections.length > 0) {
                        const totalCorrectionInsulin = allCorrections.reduce((sum, c) => sum + c.insulin, 0);
                        details = `Meal at ${formatTimeForDisplay(meal.created_at)} (${meal.carbs}g)\n ->  High ${peakBG} mg/dL at ${formatTimeForDisplay(peakReading.dateString)}\n ->  ${allCorrections.length} correction${allCorrections.length > 1 ? 's' : ''} (${totalCorrectionInsulin.toFixed(2)}U) given\n\nHigh requiring corrections indicates insufficient upfront insulin.`;
                        confidence = { level: 'High', score: 85 };
                        reason = 'Meal caused high requiring corrections (CR too weak)';
                    } else {
                        details = `Meal at ${formatTimeForDisplay(meal.created_at)} (${meal.carbs}g)\n ->  High ${peakBG} mg/dL at ${formatTimeForDisplay(peakReading.dateString)}\n\nHigh indicates insufficient upfront insulin.`;
                        confidence = { level: 'Medium', score: 70 };
                        reason = 'Meal caused high (CR too weak)';
                    }
                    
                    recommendations.push({
                        detector: 'Post-Meal High (Pass 2)',
                        type: 'CR Strengthening',
                        reason: reason,
                        scheduleTime: crEntry.time,
                        currentValue: crEntry.value,
                        newValue: parseFloat(newCR.toFixed(1)),
                        adjustment: `-${adjustmentPercent}%`,
                        calculation: `${crEntry.value} x ${(1 - adjustmentPercent / 100).toFixed(2)} = ${newCR.toFixed(1)}`,
                        details: details,
                        confidence: confidence,
                        priority: 'MEDIUM',
                        events: allCorrections.length > 0 ? [meal, peakReading, ...allCorrections] : [meal, peakReading],
                        safetyNote: 'Meal causing high - strengthen CR'
                    });
                    
                    console.log(`OK Found post-meal high: ${meal.localDateTime} -> ${peakBG} mg/dL (${allCorrections.length} corrections)`);
                });
                
                console.log(`Detector 3 complete: ${recommendations.length} recommendations\n`);
                return recommendations;
            };

            // Helper function to analyze basal pattern
            const analyzeBasalPattern = (schedule) => {
                // Check if uniform (all rates the same)
                const firstRate = schedule[0].value;
                const isUniform = schedule.every(entry => Math.abs(entry.value - firstRate) < 0.01);
                
                if (isUniform) {
                    return { type: 'UNIFORM', baseRate: firstRate };
                }
                
                // Check for alternating pattern (two rates alternating)
                const uniqueRates = [...new Set(schedule.map(e => e.value.toFixed(3)))];
                if (uniqueRates.length === 2) {
                    let isAlternating = true;
                    for (let i = 0; i < schedule.length - 2; i++) {
                        if (Math.abs(schedule[i].value - schedule[i + 2].value) > 0.01) {
                            isAlternating = false;
                            break;
                        }
                    }
                    if (isAlternating) {
                        return { 
                            type: 'ALTERNATING', 
                            rate1: parseFloat(uniqueRates[0]), 
                            rate2: parseFloat(uniqueRates[1])
                        };
                    }
                }
                
                // Otherwise it's a complex pattern - use blocks
                return { type: 'BLOCKS' };
            };

            // Helper to round to pump increment
            const roundToPumpIncrement = (value, increment = 0.05) => {
                return Math.round(value / increment) * increment;
            };

            // Distribute basal adjustment across 24 hours using discrete increments
            // Strategy: First exhaust highest-rate hours, then distribute remainder across 4-hour blocks
            // protectedHours: Set of hour strings (e.g., "00:00") that should NOT receive increases (safety hours)
            const distributeBasalAdjustment = (currentSchedule, targetTotalDaily, protectedHours = new Set()) => {
                const PUMP_INCREMENT = 0.05;
                const currentTotal = currentSchedule.reduce((sum, entry) => sum + entry.value, 0);
                const difference = targetTotalDaily - currentTotal;
                
                // Calculate increments needed (positive = increase, negative = decrease)
                const incrementsNeeded = Math.round(difference / PUMP_INCREMENT);
                
                const isIncrease = incrementsNeeded > 0;
                
                // Log protection status
                if (protectedHours.size > 0 && isIncrease) {
                    console.log(`    TDD Distribution: Protecting ${protectedHours.size} safety hours from increases`);
                    console.log(`    Protected hours: ${Array.from(protectedHours).sort().join(', ')}`);
                }
                
                if (incrementsNeeded === 0) {
                    return currentSchedule.map((entry, idx) => ({
                        ...entry,
                        time: `${idx.toString().padStart(2, '0')}:00`
                    }));
                }
                
                // Start with a copy of current schedule
                const result = currentSchedule.map((entry, idx) => ({
                    ...entry,
                    value: entry.value,
                    time: `${idx.toString().padStart(2, '0')}:00`,
                    hour: idx
                }));
                
                const isReduction = incrementsNeeded < 0;
                const absIncrements = Math.abs(incrementsNeeded);
                const incrementValue = isReduction ? -PUMP_INCREMENT : PUMP_INCREMENT;
                
                // Define 4-hour blocks for remainder distribution
                const blocks = [
                    { name: '00-04', hours: [0, 1, 2, 3] },
                    { name: '04-08', hours: [4, 5, 6, 7] },
                    { name: '08-12', hours: [8, 9, 10, 11] },
                    { name: '12-16', hours: [12, 13, 14, 15] },
                    { name: '16-20', hours: [16, 17, 18, 19] },
                    { name: '20-24', hours: [20, 21, 22, 23] }
                ];
                
                let incrementsRemaining = absIncrements;
                
                // PHASE 1: Apply increments to outlier hours (rates different from median)
                // Find the median rate
                const sortedRates = result.map(e => e.value).sort((a, b) => a - b);
                const medianRate = sortedRates[Math.floor(sortedRates.length / 2)];
                
                // Find hours with non-median rates (outliers)
                // For increases: exclude protected hours from consideration
                const outlierHours = result.filter(e => {
                    const hourStr = `${e.hour.toString().padStart(2, '0')}:00`;
                    
                    // For increases, skip protected hours entirely
                    if (isIncrease && protectedHours.has(hourStr)) {
                        return false;
                    }
                    
                    return isReduction ? e.value > medianRate + 0.001 : e.value < medianRate - 0.001;
                });
                
                // Sort outliers by how far they are from median
                outlierHours.sort((a, b) => {
                    if (isReduction) {
                        return b.value - a.value; // Highest first
                    } else {
                        return a.value - b.value; // Lowest first
                    }
                });
                
                // Apply increments to outliers first (one per outlier hour)
                for (const outlier of outlierHours) {
                    if (incrementsRemaining <= 0) break;
                    
                    const entry = result[outlier.hour];
                    const newValue = entry.value + incrementValue;
                    
                    if (newValue >= PUMP_INCREMENT) {
                        entry.value = roundToPumpIncrement(newValue);
                        incrementsRemaining--;
                    }
                }
                
                // PHASE 2: Distribute remaining increments across 4-hour blocks
                // EXCLUDE blocks where all hours were adjusted in Phase 1
                // For increases: also exclude protected hours
                if (incrementsRemaining > 0) {
                    // Track which blocks had all their hours adjusted
                    const adjustedHours = new Set(outlierHours.map(o => o.hour));
                    
                    // Filter to blocks that still have unadjusted, eligible hours
                    const eligibleBlocks = blocks.filter(block => {
                        const unadjustedInBlock = block.hours.filter(h => {
                            if (adjustedHours.has(h)) return false;
                            
                            // For increases, also exclude protected hours
                            if (isIncrease) {
                                const hourStr = `${h.toString().padStart(2, '0')}:00`;
                                if (protectedHours.has(hourStr)) return false;
                            }
                            
                            return true;
                        });
                        return unadjustedInBlock.length > 0;
                    }).map(block => {
                        const blockHours = block.hours.map(h => result[h]);
                        const avgRate = blockHours.reduce((sum, e) => sum + e.value, 0) / blockHours.length;
                        return { ...block, avgRate };
                    });
                    
                    // Sort eligible blocks: for reductions, highest avg first; for increases, lowest first
                    eligibleBlocks.sort((a, b) => {
                        if (isReduction) {
                            return b.avgRate - a.avgRate;
                        } else {
                            return a.avgRate - b.avgRate;
                        }
                    });
                    
                    let blockIdx = 0;
                    while (incrementsRemaining > 0 && eligibleBlocks.length > 0) {
                        const targetBlock = eligibleBlocks[blockIdx % eligibleBlocks.length];
                        
                        // Compute spread order for block: [0,1,2,3] -> [0,2,1,3]
                        // This distributes changes across the block instead of concentrating at start
                        const sortedBlockHours = [...targetBlock.hours].sort((a, b) => a - b);
                        const spreadOrder = [
                            ...sortedBlockHours.filter((_, i) => i % 2 === 0),  // positions 0, 2, 4...
                            ...sortedBlockHours.filter((_, i) => i % 2 === 1)   // positions 1, 3, 5...
                        ];
                        
                        // Filter to available hour indices, maintaining spread order
                        const availableHourIndices = spreadOrder.filter(h => {
                            if (adjustedHours.has(h)) return false;
                            
                            // For increases, also exclude protected hours
                            if (isIncrease) {
                                const hourStr = `${h.toString().padStart(2, '0')}:00`;
                                if (protectedHours.has(hourStr)) return false;
                            }
                            
                            return true;
                        });
                        
                        if (availableHourIndices.length === 0) {
                            blockIdx++;
                            continue;
                        }
                        
                        // Get the target entry from result using spread order
                        const targetHour = result[availableHourIndices[0]];
                        const newValue = targetHour.value + incrementValue;
                        
                        if (newValue >= PUMP_INCREMENT) {
                            result[targetHour.hour].value = roundToPumpIncrement(newValue);
                            adjustedHours.add(targetHour.hour);
                            incrementsRemaining--;
                        }
                        
                        blockIdx++;
                        // Safety: prevent infinite loop
                        if (blockIdx > absIncrements + 24) break;
                    }
                }
                
                // Clean up and return
                return result.map(entry => {
                    const { hour, ...clean } = entry;
                    return clean;
                });
            };


            /**
             * DETECTOR 4: Unified Basal Optimization
             * Combines IOB-based safety reductions with 35% TDD optimization into ONE recommendation
             * Flow: Original  ->  Safety Adjusted  ->  TDD Optimized  ->  Final
             */
            const detectBasalOptimization = (nightscoutData, basalSchedule, analysisStartDateTime, analysisWindow, claimedEvents, basalTDDPercent = 35, basalSignalWindow = 7) => {
                console.log('=== DETECTOR 4: Unified Basal Optimization ===');
                console.log(`  Basal TDD Target: ${basalTDDPercent}%`);
                const recommendations = [];
                const PUMP_INCREMENT = 0.05; // U/hr - minimum pump adjustment
                
                // Helper to round to pump increment
                const roundToPumpIncrement = (value) => {
                    return Math.round(value / PUMP_INCREMENT) * PUMP_INCREMENT;
                };
                
                // Calculate TDD (Total Daily Dose)
                const calculateTDD = () => {
                    let iapsTDD = null;
                    let iapsTwoWeekTDD = null;
                    
                    if (nightscoutData.deviceStatus && nightscoutData.deviceStatus.length > 0) {
                        for (let i = 0; i < Math.min(5, nightscoutData.deviceStatus.length); i++) {
                            const status = nightscoutData.deviceStatus[i];
                            if (status.openaps && status.openaps.enacted && status.openaps.enacted.reason) {
                                const reason = status.openaps.enacted.reason;
                                const twoWeekMatch = reason.match(/2week TDD (\d+\.?\d*)/);
                                const currentMatch = reason.match(/TDD (\d+\.?\d*)/);
                                
                                if (twoWeekMatch) iapsTwoWeekTDD = parseFloat(twoWeekMatch[1]);
                                if (currentMatch && !iapsTDD) iapsTDD = parseFloat(currentMatch[1]);
                                if (iapsTwoWeekTDD) break;
                            }
                        }
                    }
                    
                    // Fallback calculation
                    const now = new Date();
                    const analysisWindowDays = analysisWindow || 1;
                    const dailyTDDs = [];
                    let totalBasalPerDay = basalSchedule.reduce((sum, e) => sum + e.value, 0);
                    
                    for (let day = 0; day < analysisWindowDays; day++) {
                        const dayEnd = new Date(now - (day * 24 * 60 * 60 * 1000));
                        const dayStart = new Date(dayEnd - 24 * 60 * 60 * 1000);
                        
                        let dayBolus = 0;
                        nightscoutData.treatments.forEach(t => {
                            if (!t.created_at || !t.insulin || t.insulin <= 0) return;
                            const tTime = new Date(t.created_at);
                            if (tTime >= dayStart && tTime < dayEnd) dayBolus += t.insulin;
                        });
                        
                        const dayTDD = dayBolus + totalBasalPerDay;
                        if (dayTDD > 0) dailyTDDs.push(dayTDD);
                    }
                    
                    const calculatedTDD = dailyTDDs.length > 0 
                        ? dailyTDDs.reduce((sum, tdd) => sum + tdd, 0) / dailyTDDs.length : 0;
                    
                    if (iapsTwoWeekTDD) return { tdd: iapsTwoWeekTDD, source: 'iAPS 2-week average', warning: null };
                    if (iapsTDD) return { tdd: iapsTDD, source: 'iAPS current', warning: 'Using iAPS current TDD (2-week average not found)' };
                    if (calculatedTDD > 0) return { tdd: calculatedTDD, source: `calculated ${analysisWindowDays}-day average`, warning: 'Ã¢Å¡ Ã¯Â¸Â iAPS TDD not found. Using calculated average.' };
                    return null;
                };
                
                // Get IOB data
                const getIOBData = () => {
                    const iobData = [];
                    if (nightscoutData.deviceStatus) {
                        nightscoutData.deviceStatus.forEach(status => {
                            if (status.created_at && status.openaps && status.openaps.iob && typeof status.openaps.iob.iob !== 'undefined') {
                                iobData.push({
                                    time: new Date(status.created_at),
                                    localTime: status.created_at,
                                    totalIOB: status.openaps.iob.iob
                                });
                            }
                        });
                    }
                    console.log(`  Ã¢Åâ¦ Parsed ${iobData.length} IOB data points`);
                    return iobData;
                };
                
                const iobData = getIOBData();
                
                // ============================================================
                // STEP 1: Calculate IOB-based safety reductions (if any)
                // ============================================================
                console.log('\n  Step 1: Checking for IOB-based Safety Reductions');
                
                // Find resistant lows (lows with negative IOB)
                const resistantLows = [];
                nightscoutData.glucose.forEach(reading => {
                    const readingTime = new Date(reading.dateString);
                    if (readingTime < analysisStartDateTime) return;
                    
                    if (reading.sgv <= 70) {
                        let nearestIOB = null;
                        let minTimeDiff = Infinity;
                        
                        iobData.forEach(iob => {
                            const timeDiff = Math.abs(iob.time - readingTime);
                            if (timeDiff < 10 * 60 * 1000 && timeDiff < minTimeDiff) {
                                minTimeDiff = timeDiff;
                                nearestIOB = iob;
                            }
                        });
                        
                        if (nearestIOB && nearestIOB.totalIOB < 0) {
                            console.log(`    Resistant low: ${reading.localDateTime} (${reading.sgv} mg/dL) IOB: ${nearestIOB.totalIOB.toFixed(3)}U`);
                            resistantLows.push({ reading, iob: nearestIOB.totalIOB, iobTime: nearestIOB.time });
                            claimedEvents.lows.add(reading.localDateTime);
                        }
                    }
                });
                
                // Group lows within 30 minutes into event windows
                const eventWindows = [];
                resistantLows.forEach(low => {
                    const lowTime = new Date(low.reading.dateString);
                    let foundWindow = false;
                    for (const window of eventWindows) {
                        const windowStart = new Date(window.lows[0].reading.dateString);
                        if (Math.abs(lowTime - windowStart) / 60000 <= 30) {
                            window.lows.push(low);
                            foundWindow = true;
                            break;
                        }
                    }
                    if (!foundWindow) eventWindows.push({ lows: [low] });
                });
                
                // Calculate safety reductions for each hour
                const safetyHourlyReductions = {}; // hour -> total reduction
                let safetyEventSummary = null;
                
                if (resistantLows.length > 0) {
                    console.log(`  Found ${resistantLows.length} resistant lows in ${eventWindows.length} event window(s)`);
                    
                    eventWindows.forEach((window, windowIdx) => {
                        const peakNegativeIOB = Math.min(...window.lows.map(l => l.iob));
                        const peakLow = window.lows.find(l => l.iob === peakNegativeIOB);
                        const peakTime = peakLow.iobTime;
                        
                        // Find when IOB first went negative
                        const windowLowTimes = window.lows.map(l => new Date(l.reading.dateString));
                        const earliestLowTime = new Date(Math.min(...windowLowTimes));
                        
                        const iobBeforeLow = iobData.filter(iob => iob.time <= earliestLowTime).sort((a, b) => b.time - a.time);
                        let firstNegativeIOBTime = peakTime;
                        for (const iob of iobBeforeLow) {
                            if (iob.totalIOB >= 0) break;
                            firstNegativeIOBTime = iob.time;
                        }
                        
                        // Calculate contributing window: 4 hours before first negative  ->  peak time
                        const windowStartTime = new Date(firstNegativeIOBTime.getTime() - 4 * 60 * 60 * 1000);
                        const windowEndTime = peakTime;
                        
                        // Build hours array
                        const startHour = windowStartTime.getHours();
                        const endHour = windowEndTime.getHours();
                        const hoursArray = [];
                        let currentHour = startHour;
                        for (let i = 0; i < 24; i++) {
                            hoursArray.push(`${currentHour.toString().padStart(2, '0')}:00`);
                            if (currentHour === endHour) break;
                            currentHour = (currentHour + 1) % 24;
                        }
                        
                        const totalHours = hoursArray.length;
                        const reductionPerHour = Math.abs(peakNegativeIOB) / totalHours;
                        const roundedReduction = Math.min(roundToPumpIncrement(reductionPerHour), 0.10);
                        
                        console.log(`    Window ${windowIdx + 1}: peak IOB ${peakNegativeIOB.toFixed(3)}U  ->  ${roundedReduction.toFixed(2)} U/hr  x  ${totalHours} hrs`);
                        
                        hoursArray.forEach(hourStr => {
                            safetyHourlyReductions[hourStr] = (safetyHourlyReductions[hourStr] || 0) + roundedReduction;
                        });
                        
                        if (!safetyEventSummary) {
                            safetyEventSummary = { totalLows: 0, peakNegativeIOB: 0, affectedHours: new Set() };
                        }
                        safetyEventSummary.totalLows += window.lows.length;
                        safetyEventSummary.peakNegativeIOB = Math.min(safetyEventSummary.peakNegativeIOB, peakNegativeIOB);
                        hoursArray.forEach(h => safetyEventSummary.affectedHours.add(h));
                    });
                } else {
                    console.log(`  No resistant lows found`);
                }
                
                // ============================================================
                // STEP 2: Apply safety reductions to create intermediate schedule
                // ============================================================
                console.log('\n  Step 2: Applying Safety Reductions');
                
                const safetyAdjustedSchedule = basalSchedule.map((entry, idx) => ({
                    ...entry,
                    value: entry.value,
                    time: entry.time || `${idx.toString().padStart(2, '0')}:00`
                }));
                
                let totalSafetyReduction = 0;
                Object.entries(safetyHourlyReductions).forEach(([hourStr, reduction]) => {
                    const idx = safetyAdjustedSchedule.findIndex(e => e.time === hourStr);
                    if (idx >= 0) {
                        const oldValue = safetyAdjustedSchedule[idx].value;
                        const newValue = Math.max(PUMP_INCREMENT, roundToPumpIncrement(oldValue - reduction));
                        safetyAdjustedSchedule[idx].value = newValue;
                        totalSafetyReduction += (oldValue - newValue);
                        console.log(`    ${hourStr}: ${oldValue.toFixed(3)}  ->  ${newValue.toFixed(3)}`);
                    }
                });
                
                const originalTotal = basalSchedule.reduce((sum, e) => sum + e.value, 0);
                const safetyAdjustedTotal = safetyAdjustedSchedule.reduce((sum, e) => sum + e.value, 0);
                console.log(`  Safety adjustment: ${originalTotal.toFixed(2)}U  ->  ${safetyAdjustedTotal.toFixed(2)}U (-${totalSafetyReduction.toFixed(2)}U/day)`);
                
                // ============================================================
                // STEP 3: Apply 35% TDD optimization
                // ============================================================
                console.log('\n  Step 3: Applying 35% TDD Optimization');
                
                const tddResult = calculateTDD();
                
                if (!tddResult || !tddResult.tdd) {
                    console.log(`  TDD unavailable - skipping TDD optimization`);
                    
                    // If we have safety reductions only, create recommendation for those
                    if (Object.keys(safetyHourlyReductions).length > 0) {
                        const hourlyDisplayData = [];
                        for (let i = 0; i < 24; i++) {
                            const hourStr = `${i.toString().padStart(2, '0')}:00`;
                            const original = basalSchedule[i].value;
                            const final = safetyAdjustedSchedule[i].value;
                            hourlyDisplayData.push({
                                hour: hourStr,
                                oldValue: original.toFixed(3),
                                newValue: final.toFixed(3),
                                change: (final - original).toFixed(3),
                                hasChange: Math.abs(final - original) > 0.001,
                                isSafetyChange: safetyHourlyReductions[hourStr] !== undefined
                            });
                        }
                        
                        recommendations.push({
                            detector: 'Unified Basal Optimization',
                            type: 'Basal Optimization',
                            reason: `Safety reductions for ${safetyEventSummary.totalLows} resistant low(s)`,
                            scheduleTime: 'ALL',
                            currentValue: parseFloat(originalTotal.toFixed(2)),
                            newValue: parseFloat(safetyAdjustedTotal.toFixed(2)),
                            adjustment: `-${totalSafetyReduction.toFixed(2)} U/day`,
                            calculation: `Original: ${originalTotal.toFixed(2)}U  ->  Final: ${safetyAdjustedTotal.toFixed(2)}U`,
                            details: `**Safety Reductions**\n${safetyEventSummary.totalLows} resistant low(s) with peak IOB ${safetyEventSummary.peakNegativeIOB.toFixed(2)}U\nHours: ${Array.from(safetyEventSummary.affectedHours).sort().join(', ')}\n\n**TDD optimization skipped** (data unavailable)`,
                            hourlyDisplayData: hourlyDisplayData,
                            confidence: { level: 'High', score: 90 },
                            priority: 'HIGH',
                            hourlySchedule: safetyAdjustedSchedule,
                            safetyNote: `System withheld ${Math.abs(safetyEventSummary.peakNegativeIOB).toFixed(2)}U but lows still occurred`
                        });
                    }
                    
                    console.log(`\nDetector 4 complete: ${recommendations.length} recommendation(s)`);
                    return recommendations;
                }
                
                const tdd = tddResult.tdd;
                const tddSource = tddResult.source;
                const tddWarning = tddResult.warning;
                const targetTotalBasal = tdd * (basalTDDPercent / 100);
                
                // 10% max change from safety-adjusted baseline (KEPT from v24)
                const maxChange = safetyAdjustedTotal * 0.10;
                const cappedTargetBasal = Math.max(
                    safetyAdjustedTotal - maxChange,
                    Math.min(safetyAdjustedTotal + maxChange, targetTotalBasal)
                );
                
                // Calculate actual target percent after capping
                const actualTargetPercent = (cappedTargetBasal / tdd) * 100;
                
                console.log(`  TDD: ${tdd.toFixed(2)}U (${tddSource})`);
                console.log(`  Target: ${targetTotalBasal.toFixed(2)}U (${basalTDDPercent}% TDD)`);
                console.log(`  Capped: ${cappedTargetBasal.toFixed(2)}U (${actualTargetPercent.toFixed(1)}% TDD after 10% cap)`);
                
                // Run signal-based analysis (replaces simple TDD scaling)
                const safetyHoursSet = new Set(Object.keys(safetyHourlyReductions));
                
                console.log('\n  Running Signal-Based Analysis...');
                const signalResult = BasalSignalModule.analyze({
                    deviceStatus: nightscoutData.deviceStatus,
                    profile: nightscoutData.profile,
                    safetyAdjustedSchedule: safetyAdjustedSchedule,
                    tdd: tdd,
                    targetAnchor: actualTargetPercent,  // Use capped target
                    dampingFactor: 0.4,
                    minSampleSize: 10,
                    analysisWindowDays: basalSignalWindow,  // Use basal-specific window
                    protectedHours: safetyHoursSet
                });
                
                console.log('  Signal Analysis Results:');
                console.log(`    Clean windows: ${signalResult.signalAnalysis.cleanWindows.total}`);
                console.log(`    Signals suggest: ${signalResult.totals.signalPercent.toFixed(1)}% of TDD`);
                console.log(`    Target: ${actualTargetPercent.toFixed(1)}% of TDD`);
                console.log(`    Increments distributed: ${signalResult.incrementDistribution.incrementsNeeded}`);
                console.log(`    Direction: ${signalResult.incrementDistribution.direction}`);
                if (signalResult.incrementDistribution.appliedHours.length > 0) {
                    console.log(`    Applied to: ${signalResult.incrementDistribution.appliedHours.map(a => `${a.hour}:00 (${a.period})`).join(', ')}`);
                }
                
                const finalSchedule = signalResult.finalSchedule;
                const finalTotal = signalResult.totals.final;
                
                // ============================================================
                // STEP 4: Create unified recommendation (Original  ->  Final)
                // ============================================================
                console.log('\n  Step 4: Creating Unified Recommendation');
                
                // Use signal module's pre-built hourlyDisplayData, add safety flag
                const hourlyDisplayData = signalResult.hourlyDisplayData.map(h => ({
                    ...h,
                    isSafetyChange: safetyHourlyReductions[h.hour] !== undefined
                }));
                
                const totalChange = finalTotal - originalTotal;
                const changedHours = hourlyDisplayData.filter(h => h.hasChange).length;
                
                if (Math.abs(totalChange) < 0.05 && changedHours === 0) {
                    console.log(`  No changes needed`);
                    console.log(`\nDetector 4 complete: 0 recommendation(s)`);
                    return recommendations;
                }
                
                // Build details
                let detailsText = '';
                if (safetyEventSummary && safetyEventSummary.totalLows > 0) {
                    detailsText += `**Safety Reductions** (HIGH PRIORITY)\n`;
                    detailsText += `${safetyEventSummary.totalLows} resistant low(s), peak IOB: ${safetyEventSummary.peakNegativeIOB.toFixed(2)}U\n`;
                    detailsText += `Hours: ${Array.from(safetyEventSummary.affectedHours).sort().join(', ')}\n`;
                    detailsText += `Reduction: -${totalSafetyReduction.toFixed(2)}U/day\n\n`;
                }
                
                detailsText += `**Signal Analysis** (${signalResult.signalAnalysis.cleanWindows.total} clean windows)\n`;
                signalResult.signalAnalysis.periods.forEach(p => {
                    if (p.hasSufficientData && p.signal !== 'NEUTRAL') {
                        const arrow = p.signal === 'HIGH' ? 'â' : 'â';
                        detailsText += `${p.emoji} ${p.name}: ${p.medianDeviation >= 0 ? '+' : ''}${p.medianDeviation.toFixed(1)} mg/dL ${arrow}\n`;
                    }
                });
                detailsText += `Signals suggest: ${signalResult.totals.signalPercent.toFixed(1)}% of TDD\n\n`;
                
                // Increment distribution
                if (Math.abs(signalResult.incrementDistribution.incrementsNeeded) > 0) {
                    const dir = signalResult.incrementDistribution.direction;
                    const count = Math.abs(signalResult.incrementDistribution.incrementsNeeded);
                    detailsText += `**Increment Distribution**\n`;
                    detailsText += `${count} x 0.05U ${dir}s applied to ${dir === 'decrease' ? 'negative' : 'positive'}-signal periods first\n`;
                    if (signalResult.incrementDistribution.appliedHours.length > 0) {
                        detailsText += `Hours: ${signalResult.incrementDistribution.appliedHours.map(a => `${a.hour}:00`).join(', ')}\n`;
                    }
                    detailsText += '\n';
                }
                
                detailsText += `**Target & Final**\n`;
                detailsText += `TDD: ${tdd.toFixed(2)}U (${tddSource})\n`;
                detailsText += `Target: ${cappedTargetBasal.toFixed(2)}U (${actualTargetPercent.toFixed(1)}% of TDD)\n`;
                detailsText += `Original: ${originalTotal.toFixed(2)}U  ->  Final: ${finalTotal.toFixed(2)}U\n`;
                detailsText += `Net: ${totalChange >= 0 ? '+' : ''}${totalChange.toFixed(2)}U/day`;
                
                const hasSafetyReductions = safetyEventSummary && safetyEventSummary.totalLows > 0;
                const percentChange = ((totalChange) / originalTotal * 100).toFixed(1);
                
                let reasonText = hasSafetyReductions 
                    ? `Safety reduction for ${safetyEventSummary.totalLows} resistant low(s) + signal-based optimization`
                    : `Signal-based basal ${totalChange > 0 ? 'increase' : 'decrease'} toward ${actualTargetPercent.toFixed(1)}% TDD target`;
                
                let safetyNote = null;
                if (hasSafetyReductions) {
                    safetyNote = `System withheld ${Math.abs(safetyEventSummary.peakNegativeIOB).toFixed(2)}U but lows still occurred. Safety hours highlighted.`;
                }
                if (tddWarning) safetyNote = safetyNote ? `${safetyNote}\n${tddWarning}` : tddWarning;
                
                recommendations.push({
                    detector: 'Unified Basal Optimization',
                    type: 'Basal Optimization',
                    reason: reasonText,
                    scheduleTime: 'ALL',
                    currentValue: parseFloat(originalTotal.toFixed(2)),
                    newValue: parseFloat(finalTotal.toFixed(2)),
                    adjustment: `${totalChange >= 0 ? '+' : ''}${percentChange}% (${totalChange >= 0 ? '+' : ''}${totalChange.toFixed(2)} U/day)`,
                    calculation: `Original: ${originalTotal.toFixed(2)}U  ->  Safety: ${safetyAdjustedTotal.toFixed(2)}U  ->  Signal: ${signalResult.totals.signalBased.toFixed(2)}U  ->  Final: ${finalTotal.toFixed(2)}U`,
                    details: detailsText,
                    hourlyDisplayData: hourlyDisplayData,
                    confidence: { level: hasSafetyReductions ? 'High' : (tddWarning ? 'Medium' : 'High'), score: hasSafetyReductions ? 95 : (tddWarning ? 70 : 85) },
                    priority: hasSafetyReductions ? 'HIGH' : 'MEDIUM',
                    hourlySchedule: finalSchedule,
                    signalAnalysis: signalResult.signalAnalysis,
                    incrementDistribution: signalResult.incrementDistribution,
                    signalTotals: signalResult.totals,
                    patternAnalysis: { before: analyzeBasalPattern(basalSchedule), after: analyzeBasalPattern(finalSchedule) },
                    ...(safetyNote && { safetyNote })
                });
                
                console.log(`  Created: ${originalTotal.toFixed(2)}U  ->  ${finalTotal.toFixed(2)}U`);
                console.log(`\nDetector 4 complete: ${recommendations.length} recommendation(s)`);
                return recommendations;
            };


            /**
             * DETECTOR 5: Regular Lows (Catch-all)
             * Priority: 5 (Lowest)
             * Pattern: Any unclaimed lows WITH a meal in lookback window
             * Conclusion: General CR issue
             * NOTE: Lows without meals are skipped - these are basal issues, not CR issues
             */
            const detectRegularLows = (lowProblems, nightscoutData, crSchedule, claimedEvents, processedLowIds) => {
                console.log('=== DETECTOR 5: Regular Lows (Catch-all) ===');
                const recommendations = [];
                
                lowProblems.forEach(low => {
                    const lowId = getEventId(low);
                    
                    // Skip if this low was already claimed
                    if (claimedEvents.lows.has(lowId)) {
                        console.log(`Skipping claimed low: ${low.localTime}`);
                        return;
                    }
                    
                    // Skip if this low was already processed (got a recommendation from Detectors 1-3)
                    if (processedLowIds.has(lowId)) {
                        console.log(`Skipping already processed low: ${low.localTime}`);
                        return;
                    }
                    
                    const lowTime = new Date(low.time);
                    const eightHoursAgo = new Date(lowTime - 8 * 60 * 60 * 1000);
                    
                    // Find the most recent meal
                    let relevantMeal = null;
                    for (let treatment of nightscoutData.treatments) {
                        if (!treatment.created_at || !treatment.carbs || treatment.carbs <= 0) continue;
                        
                        const treatmentTime = new Date(treatment.created_at);
                        if (treatmentTime <= lowTime && treatmentTime >= eightHoursAgo) {
                            if (!relevantMeal || treatmentTime > new Date(relevantMeal.localDateTime)) {
                                relevantMeal = treatment;
                            }
                        }
                    }
                    
                    // NO MEAL FOUND = NOT A CR ISSUE
                    // Skip this low - basal signal analysis will handle fasting lows
                    if (!relevantMeal) {
                        console.log(`Skipping low without meal (basal issue, not CR): ${low.localTime}`);
                        return;
                    }
                    
                    // Use meal time for CR schedule lookup
                    const crEntry = getCRForTime(relevantMeal.localDateTime, crSchedule);
                    
                    // Claim the low and meal
                    claimedEvents.lows.add(lowId);
                    claimedEvents.meals.add(getEventId(relevantMeal));
                    
                    const adjustmentPercent = low.bg < 55 ? 7.5 : 5;
                    const newCR = crEntry.value * (1 + adjustmentPercent / 100);
                    
                    recommendations.push({
                        detector: 'Regular Low (Catch-all)',
                        type: 'CR Weakening',
                        reason: 'Low after meal without clear pattern',
                        scheduleTime: crEntry.time,
                        currentValue: crEntry.value,
                        newValue: parseFloat(newCR.toFixed(1)),
                        adjustment: `+${adjustmentPercent}%`,
                        calculation: `${crEntry.value} x ${(1 + adjustmentPercent / 100).toFixed(2)} = ${newCR.toFixed(1)}`,
                        details: `Low ${low.bg} mg/dL at ${formatTimeForDisplay(low.time)}, possible meal at ${formatTimeForDisplay(relevantMeal.created_at)} (${relevantMeal.carbs}g)`,
                        confidence: { level: 'Medium', score: 60 },
                        priority: 'LOW',
                        events: [low, relevantMeal]
                    });
                    
                    console.log(`OK Found regular low with meal: ${low.localTime}`);
                });
                
                console.log(`Detector 5 complete: ${recommendations.length} recommendations`);
                return recommendations;
            };

            // ===== SECTION 3: ORCHESTRATION =====
            
            const runAllDetectors = (nightscoutData, crSchedule, isfSchedule, basalSchedule, analysisStartDateTime, analysisWindow, basalTDDPercent = 35, basalSignalWindow = 7) => {
                console.log('\n========== RUNNING MULTI-DETECTOR ANALYSIS ==========\n');
                
                // Initialize event claiming system
                const claimedEvents = {
                    lows: new Set(),
                    meals: new Set(),
                    corrections: new Set(),
                    highs: new Set()
                };
                
                // Track which lows got recommendations (not just claimed)
                const processedLowIds = new Set();
                
                // Step 1: Identify all low problems (like v23)
                const lowProblems = [];
                nightscoutData.glucose.forEach((reading) => {
                    const readingTime = new Date(reading.dateString);
                    if (readingTime < analysisStartDateTime) return;
                    
                    if (reading.sgv <= 70) {
                        const severity = reading.sgv < 55 ? 'severe' : 
                                       reading.sgv < 65 ? 'moderate' : 'minor';
                        lowProblems.push({
                            time: reading.dateString,
                            localTime: reading.localDateTime,
                            bg: reading.sgv,
                            severity
                        });
                    }
                });
                
                console.log(`Found ${lowProblems.length} total lows\n`);
                
                // Run detectors in priority order
                const allRecommendations = [];
                
                // Detector 1b: Transient High with Subsequent Low (Priority 1 - Safety, More Specific)
                const detector1bResults = detectTransientHighWithLow(
                    lowProblems, nightscoutData, crSchedule, claimedEvents, processedLowIds
                );
                allRecommendations.push(...detector1bResults);
                
                // Detector 1: Direct Meal-Induced Lows (Priority 1.5 - Safety, Less Specific)
                const detector1Results = detectDirectMealInducedLows(
                    lowProblems, nightscoutData, crSchedule, claimedEvents, processedLowIds
                );
                allRecommendations.push(...detector1Results);
                
                // Detector 2: Correction Overcorrection (Priority 2 - ISF)
                const detector2Results = detectCorrectionOvercorrection(
                    lowProblems, nightscoutData, isfSchedule, claimedEvents, processedLowIds
                );
                allRecommendations.push(...detector2Results);
                
                // Detector 2b: Correction Ineffectiveness (Priority 2.5 - ISF Optimization)
                const detector2bResults = detectCorrectionIneffectiveness(
                    nightscoutData, isfSchedule, claimedEvents, analysisStartDateTime
                );
                allRecommendations.push(...detector2bResults);
                
                // Detector 3: Post-Meal Highs with Corrections (Priority 3 - CR weakness)
                const detector3Results = detectPostMealHighsWithCorrections(
                    lowProblems, nightscoutData, crSchedule, claimedEvents, processedLowIds
                );
                allRecommendations.push(...detector3Results);
                
                // Detector 4: Two-Stage Basal Optimization (Priority 4)
                const detector4Results = detectBasalOptimization(
                    nightscoutData, basalSchedule, analysisStartDateTime, analysisWindow, claimedEvents, basalTDDPercent, basalSignalWindow
                );
                allRecommendations.push(...detector4Results);
                
                // Detector 5: Regular Lows (Priority 5 - Catch-all)
                const detector5Results = detectRegularLows(
                    lowProblems, nightscoutData, crSchedule, claimedEvents, processedLowIds
                );
                allRecommendations.push(...detector5Results);
                
                // Schedule Boundary Analysis: Identify timing mismatches
                const scheduleBoundaryResults = detectScheduleBoundaryIssues(
                    nightscoutData, crSchedule, lowProblems
                );
                allRecommendations.push(...scheduleBoundaryResults);
                
                console.log('\n========== DETECTION COMPLETE ==========');
                console.log(`Total recommendations: ${allRecommendations.length}`);
                console.log(`Claimed lows: ${claimedEvents.lows.size}/${lowProblems.length}`);
                console.log(`Claimed meals: ${claimedEvents.meals.size}`);
                console.log(`Claimed corrections: ${claimedEvents.corrections.size}`);
                console.log(`Claimed highs: ${claimedEvents.highs.size}\n`);
                
                return allRecommendations;
            };

            const aggregateRecommendations = (recommendations) => {
                // Group by schedule time and type
                const grouped = {};
                
                recommendations.forEach(rec => {
                    const key = `${rec.scheduleTime}_${rec.type}`;
                    if (!grouped[key]) {
                        grouped[key] = [];
                    }
                    grouped[key].push(rec);
                });
                
                // For each group, create aggregated recommendation
                const aggregated = Object.values(grouped).map(group => {
                    if (group.length === 1) {
                        return group[0];
                    }
                    
                    // Multiple recommendations for same schedule/type
                    // Use the one with highest confidence
                    const sorted = group.sort((a, b) => b.confidence.score - a.confidence.score);
                    const primary = sorted[0];
                    
                    return {
                        ...primary,
                        details: `${primary.details}\n\nNote: ${group.length} similar patterns detected at this schedule time.`,
                        multipleDetections: group.length
                    };
                });
                
                return aggregated;
            };

            const detectConflicts = (recommendations) => {
                // Check for conflicting recommendations at same schedule time
                // Only flag as conflict if SAME parameter has opposing directions
                const bySchedule = {};
                recommendations.forEach(rec => {
                    if (!bySchedule[rec.scheduleTime]) {
                        bySchedule[rec.scheduleTime] = [];
                    }
                    bySchedule[rec.scheduleTime].push(rec);
                });
                
                const conflicts = [];
                Object.entries(bySchedule).forEach(([scheduleTime, recs]) => {
                    if (recs.length > 1) {
                        // Check for CR conflicts (CR Weakening vs CR Strengthening)
                        const hasCRWeakening = recs.some(r => r.type === 'CR Weakening');
                        const hasCRStrengthening = recs.some(r => r.type === 'CR Strengthening');
                        
                        // Check for ISF conflicts (ISF Weakening vs ISF Strengthening)
                        const hasISFWeakening = recs.some(r => r.type === 'ISF Weakening');
                        const hasISFStrengthening = recs.some(r => r.type === 'ISF Strengthening');
                        
                        // Check for Basal conflicts
                        const hasBasalIncrease = recs.some(r => r.type.includes('Basal') && r.adjustment.includes('+'));
                        const hasBasalReduction = recs.some(r => r.type.includes('Basal') && r.adjustment.includes('-'));
                        
                        // Only flag if same parameter type has opposing recommendations
                        if ((hasCRWeakening && hasCRStrengthening) || 
                            (hasISFWeakening && hasISFStrengthening) ||
                            (hasBasalIncrease && hasBasalReduction)) {
                            conflicts.push({
                                scheduleTime,
                                recommendations: recs,
                                type: 'opposing'
                            });
                        }
                    }
                });
                
                return conflicts;
            };

            // NEW: Group recommendations by parameter type (CR, ISF, Basal)
            // This matches the iAPS workflow where each parameter is adjusted on a separate screen
            // Helper to extract timestamp from recommendation events
            const getRecTimestamp = (rec) => {
                if (!rec.events || rec.events.length === 0) return 0;
                // Find the first event with a timestamp
                for (const event of rec.events) {
                    if (event.localDateTime) return new Date(event.localDateTime).getTime();
                    if (event.created_at) return new Date(event.created_at).getTime();
                    if (event.dateString) return new Date(event.dateString).getTime();
                }
                return 0;
            };

            const groupByParameterType = (recommendations, conflicts) => {
                // Determine parameter type from recommendation type
                const getParameterType = (rec) => {
                    if (rec.type.includes('CR')) return 'CR';
                    if (rec.type.includes('ISF')) return 'ISF';
                    if (rec.type.includes('Basal')) return 'Basal';
                    if (rec.type.includes('Schedule Boundary')) return 'Schedule';
                    if (rec.type === 'Informational') return 'Info';
                    return 'Other';
                };
                
                // Create groups by parameter type
                const groups = {
                    CR: { parameterType: 'CR', title: 'Carb Ratio (CR) Adjustments', recommendations: [] },
                    ISF: { parameterType: 'ISF', title: 'Insulin Sensitivity Factor (ISF) Adjustments', recommendations: [] },
                    Basal: { parameterType: 'Basal', title: 'Basal Rate Adjustments', recommendations: [] },
                    Schedule: { parameterType: 'Schedule', title: 'Schedule Boundary Adjustments', recommendations: [] },
                    Info: { parameterType: 'Info', title: 'Informational Notices', recommendations: [] },
                    Other: { parameterType: 'Other', title: 'Other Recommendations', recommendations: [] }
                };
                
                // Sort recommendations into parameter type groups
                recommendations.forEach(rec => {
                    const paramType = getParameterType(rec);
                    rec._timestamp = getRecTimestamp(rec);
                    groups[paramType].recommendations.push(rec);
                });
                
                // Within each group, sort by schedule time (chronologically)
                Object.values(groups).forEach(group => {
                    group.recommendations.sort((a, b) => {
                        const aMinutes = scheduleTimeToMinutes(a.scheduleTime);
                        const bMinutes = scheduleTimeToMinutes(b.scheduleTime);
                        return aMinutes - bMinutes;
                    });
                });
                
                // Check for conflicts within each schedule time in each group
                Object.values(groups).forEach(group => {
                    // Group by schedule time within this parameter type
                    const bySchedule = {};
                    group.recommendations.forEach(rec => {
                        if (!bySchedule[rec.scheduleTime]) {
                            bySchedule[rec.scheduleTime] = [];
                        }
                        bySchedule[rec.scheduleTime].push(rec);
                    });
                    
                    // Mark conflicts within same schedule time
                    Object.entries(bySchedule).forEach(([scheduleTime, recs]) => {
                        if (recs.length > 1) {
                            // Check if there's an actual conflict (opposing directions)
                            const hasWeakening = recs.some(r => r.type.includes('Weakening'));
                            const hasStrengthening = recs.some(r => r.type.includes('Strengthening'));
                            
                            if (hasWeakening && hasStrengthening) {
                                // Sort by recency
                                recs.sort((a, b) => b._timestamp - a._timestamp);
                                
                                // Mark latest/older
                                recs[0].isLatest = true;
                                recs[0].hasConflict = true;
                                for (let i = 1; i < recs.length; i++) {
                                    recs[i].isOlder = true;
                                    recs[i].hasConflict = true;
                                }
                            }
                        }
                    });
                });
                
                // Return only groups that have recommendations
                return Object.values(groups).filter(g => g.recommendations.length > 0);
            };

            const sortByPriority = (recommendations) => {
                const priorityOrder = { HIGH: 0, MEDIUM: 1, LOW: 2 };
                return recommendations.sort((a, b) => {
                    const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
                    if (priorityDiff !== 0) return priorityDiff;
                    // Within same priority, sort by confidence
                    return b.confidence.score - a.confidence.score;
                });
            };

            // ===== MAIN ANALYSIS FUNCTION =====
            
            const runAnalysis = async (dataToAnalyze = null) => {
                setAnalyzing(true);
                setError(null);
                
                try {
                    // Use provided data or fall back to state
                    const data = dataToAnalyze || nightscoutData;
                    console.log('Starting v24 Multi-Detector Analysis...', data);
                    
                    if (!data || !data.glucose) {
                        throw new Error('No glucose data available');
                    }
                    
                    // Get analysis window boundaries
                    const analysisStartTime = data.exportInfo?.analysisStartTime;
                    let analysisStartDateTime;
                    if (analysisStartTime) {
                        analysisStartDateTime = new Date(analysisStartTime);
                        console.log('Analysis window:', analysisStartTime, 'to now');
                    } else {
                        analysisStartDateTime = new Date(0);
                        console.log('No analysis window specified, analyzing all data');
                    }
                    
                    // Extract profile data
                    let crSchedule = [];
                    let isfSchedule = [];
                    let basalSchedule = [];
                    
                    if (data.profile && data.profile.length > 0) {
                        const profile = data.profile[0];
                        if (profile.store && profile.store.default) {
                            crSchedule = profile.store.default.carbratio || [];
                            isfSchedule = profile.store.default.sens || [];
                            basalSchedule = profile.store.default.basal || [];
                        }
                    }
                    
                    console.log('CR Schedule:', crSchedule);
                    console.log('ISF Schedule:', isfSchedule);
                    console.log('Basal Schedule:', basalSchedule);
                    
                    // Run all detectors
                    const allRecommendations = runAllDetectors(
                        data, 
                        crSchedule, 
                        isfSchedule, 
                        basalSchedule, 
                        analysisStartDateTime, 
                        analysisWindow,
                        basalTDDPercent,
                        basalSignalWindow
                    );
                    
                    // Aggregate recommendations
                    const aggregated = aggregateRecommendations(allRecommendations);
                    
                    // Detect conflicts
                    const conflicts = detectConflicts(aggregated);
                    
                    // Group by schedule time chronologically
                    const grouped = groupByParameterType(aggregated, conflicts);
                    
                    // Also keep sorted list for summary
                    const sorted = sortByPriority(aggregated);
                    
                    // Build results object
                    const results = {
                        recommendations: sorted,
                        groupedRecommendations: grouped,
                        conflicts: conflicts,
                        summary: {
                            totalRecommendations: sorted.length,
                            byType: {
                                crWeakening: sorted.filter(r => r.type === 'CR Weakening').length,
                                crStrengthening: sorted.filter(r => r.type === 'CR Strengthening').length,
                                isfWeakening: sorted.filter(r => r.type === 'ISF Weakening').length,
                                isfStrengthening: sorted.filter(r => r.type === 'ISF Strengthening').length,
                                informational: sorted.filter(r => r.type === 'Informational').length
                            },
                            byPriority: {
                                high: sorted.filter(r => r.priority === 'HIGH').length,
                                medium: sorted.filter(r => r.priority === 'MEDIUM').length,
                                low: sorted.filter(r => r.priority === 'LOW').length,
                                informational: sorted.filter(r => r.priority === 'INFORMATIONAL').length
                            }
                        },
                        crSchedule,
                        isfSchedule,
                        basalSchedule
                    };
                    
                    console.log('Analysis complete:', results);
                    setAnalysisResults(results);
                    
                } catch (err) {
                    console.error('Analysis error:', err);
                    setError(err.message);
                } finally {
                    setAnalyzing(false);
                }
            };

            // ===== DATA LOADING FUNCTIONS =====
            
            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        console.log('Loaded Nightscout data:', data);
                        setNightscoutData(data);
                        setError(null);
                        
                        // Automatically run analysis after successful file load
                        // Pass data directly to avoid state timing issues
                        setTimeout(() => {
                            runAnalysis(data);
                        }, 100);
                    } catch (err) {
                        setError('Invalid JSON file: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };

            // Helper function to try multiple authentication methods (from v22)
            const fetchNightscoutData = async (baseUrl, endpoint, params) => {
                const url = new URL(baseUrl + endpoint);
                Object.keys(params).forEach(key => {
                    if (params[key]) url.searchParams.append(key, params[key]);
                });
                
                // Try multiple authentication methods in order
                const authMethods = [
                    // Method 1: Token as URL parameter (most reliable)
                    (() => {
                        const urlCopy = new URL(url.toString());
                        if (nsConfig.token) urlCopy.searchParams.append('token', nsConfig.token);
                        return { url: urlCopy };
                    })(),
                    // Method 2: api-secret header
                    { headers: { 'api-secret': nsConfig.apiSecret } },
                    // Method 3: Bearer token header
                    { headers: { 'Authorization': `Bearer ${nsConfig.apiSecret}` } }
                ];
                
                for (const method of authMethods) {
                    try {
                        const fetchUrl = method.url || url;
                        const response = await fetch(fetchUrl.toString(), {
                            method: 'GET',
                            headers: { 'Accept': 'application/json', ...method.headers }
                        });
                        if (response.ok) return await response.json();
                    } catch (error) {
                        console.log(`Auth method failed:`, error.message);
                    }
                }
                throw new Error(`Failed to fetch ${endpoint}`);
            };

            const fetchFromNightscout = async (days = analysisWindow) => {
                setLoading(true);
                setError(null);
                setFetchStatus('Connecting to Nightscout...');
                
                try {
                    if (!nsConfig.baseUrl) throw new Error('Please enter your Nightscout URL');
                    
                    const baseUrl = nsConfig.baseUrl.replace(/\/$/, '');
                    const endTime = new Date();
                    // Use the LONGER window for data collection (basal signals need more data)
                    // CR/ISF detectors will filter to their own window
                    const maxWindowDays = Math.max(analysisWindow, basalSignalWindow);
                    const collectionHours = (maxWindowDays * 24) + 6; // Add 6hr buffer
                    const crIsfAnalysisHours = analysisWindow * 24;
                    const collectionStartDate = new Date(endTime.getTime() - (collectionHours * 60 * 60 * 1000));
                    const analysisStartDate = new Date(endTime.getTime() - (crIsfAnalysisHours * 60 * 60 * 1000));
                    const dateString = collectionStartDate.toISOString();
                    
                    setFetchStatus(`Fetching ${maxWindowDays}-day data (CR/ISF: ${analysisWindow}d, Basal: ${basalSignalWindow}d)...`);
                    
                    // Fetch all data in parallel
                    const [entries, treatments, profile, deviceStatus] = await Promise.all([
                        fetchNightscoutData(baseUrl, '/api/v1/entries.json', { 
                            count: Math.ceil(collectionHours / 24 * 600),
                            'find[dateString][$gte]': dateString 
                        }),
                        fetchNightscoutData(baseUrl, '/api/v1/treatments.json', { 
                            count: 2000 * maxWindowDays,  // Scale with max window
                            'find[created_at][$gte]': dateString 
                        }),
                        fetchNightscoutData(baseUrl, '/api/v1/profile.json', {}).catch(() => []),
                        fetchNightscoutData(baseUrl, '/api/v1/devicestatus.json', { 
                            count: 10000,  // Match v3 tool for full signal analysis coverage
                            'find[created_at][$gte]': dateString 
                        }).catch(() => [])
                    ]);
                    
                    console.log('Fetched:', entries.length, 'glucose entries');
                    console.log('Fetched:', treatments.length, 'treatments');
                    console.log('Profile:', profile?.length || 0);
                    console.log('DeviceStatus:', deviceStatus?.length || 0);
                    
                    // SMART TREATMENT PRIORITIZATION (from working export tool)
                    console.log('Applying smart treatment prioritization...');
                    
                    // Step 1: Separate by priority (3-tier system)
                    const manualTreatments = treatments.filter(t => 
                        t.carbs > 0 || 
                        (t.eventType === 'Bolus' && t.insulin >= 0.1) ||
                        t.eventType === 'Correction'
                    );
                    const smbTreatments = treatments.filter(t => 
                        t.eventType === 'SMB' && t.insulin > 0
                    );
                    const otherAutomatedTreatments = treatments.filter(t => 
                        t.carbs === 0 && 
                        !['Bolus', 'Correction', 'SMB'].includes(t.eventType)
                    );
                    
                    console.log(`Manual treatments: ${manualTreatments.length} (ALL will be included)`);
                    console.log(`SMB treatments: ${smbTreatments.length} (ALL will be included)`);
                    console.log(`Other automated: ${otherAutomatedTreatments.length} (limited to 100)`);
                    
                    // Step 2: Smart combining - ALL manual + ALL SMBs + limited other automated
                    const combinedTreatments = [
                        ...manualTreatments,           // ALL manual entries
                        ...smbTreatments,              // ALL SMBs (CRITICAL!)
                        ...otherAutomatedTreatments.slice(0, 100)  // Limited other
                    ];
                    
                    console.log(`Combined treatments: ${combinedTreatments.length} total`);
                    
                    // Deduplicate glucose readings
                    const deduplicatedGlucose = [];
                    const seenTimes = new Set();
                    
                    for (const entry of entries) {
                        const timeKey = Math.floor(new Date(entry.dateString).getTime() / 60000);
                        if (!seenTimes.has(timeKey)) {
                            seenTimes.add(timeKey);
                            deduplicatedGlucose.push(entry);
                        }
                    }
                    
                    console.log('After deduplication:', deduplicatedGlucose.length, 'unique glucose entries');
                    
                    // Add localDateTime to glucose (matching export format)
                    const glucoseWithLocal = deduplicatedGlucose.map(e => {
                        const date = new Date(e.dateString);
                        const year = date.getFullYear();
                        const month = String(date.getMonth() + 1).padStart(2, '0');
                        const day = String(date.getDate()).padStart(2, '0');
                        const hours = String(date.getHours()).padStart(2, '0');
                        const minutes = String(date.getMinutes()).padStart(2, '0');
                        const seconds = String(date.getSeconds()).padStart(2, '0');
                        const localDateTimeStr = `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
                        
                        return {
                            ...e,
                            localDateTime: localDateTimeStr
                        };
                    });
                    
                    // Add localDateTime to treatments (use combinedTreatments instead of raw treatments)
                    const treatmentsWithLocal = combinedTreatments.map(t => {
                        const date = new Date(t.created_at);
                        const year = date.getFullYear();
                        const month = String(date.getMonth() + 1).padStart(2, '0');
                        const day = String(date.getDate()).padStart(2, '0');
                        const hours = String(date.getHours()).padStart(2, '0');
                        const minutes = String(date.getMinutes()).padStart(2, '0');
                        const seconds = String(date.getSeconds()).padStart(2, '0');
                        const localDateTimeStr = `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
                        
                        return {
                            ...t,
                            localDateTime: localDateTimeStr
                        };
                    });
                    
                    const exportData = {
                        exportInfo: {
                            timestamp: endTime.toISOString(),
                            collectionStartTime: collectionStartDate.toISOString(),
                            analysisStartTime: analysisStartDate.toISOString(),
                            collectionHours: collectionHours,
                            crIsfWindowDays: analysisWindow,
                            basalSignalWindowDays: basalSignalWindow,
                            dataPoints: {
                                glucose: deduplicatedGlucose.length,
                                treatments: combinedTreatments.length,
                                deviceStatus: deviceStatus?.length || 0
                            }
                        },
                        glucose: glucoseWithLocal,
                        treatments: treatmentsWithLocal,
                        profile: profile,
                        deviceStatus: deviceStatus || []
                    };
                    
                    console.log('Nightscout data prepared:', exportData);
                    setNightscoutData(exportData);
                    setFetchStatus('Data loaded successfully! Starting analysis...');
                    
                    // Automatically run analysis after successful fetch
                    // Pass data directly to avoid state timing issues
                    setTimeout(() => {
                        runAnalysis(exportData);
                    }, 100);
                    
                } catch (err) {
                    console.error('Fetch error:', err);
                    setError('Failed to fetch from Nightscout: ' + err.message);
                    setFetchStatus('');
                } finally {
                    setLoading(false);
                }
            };

            // ===== SECTION 4: UI RENDERING =====
            
            // Render a single recommendation card
            const RecommendationCard = ({ rec, showConflictWarning }) => {
                // Determine styling based on recency
                const isLatest = rec.isLatest;
                const isOlder = rec.isOlder;
                
                let borderClass = '';
                let opacityClass = '';
                
                if (showConflictWarning) {
                    if (isLatest) {
                        borderClass = 'border-2 border-green-500';
                    } else if (isOlder) {
                        borderClass = 'border-2 border-gray-300';
                        opacityClass = 'opacity-60';
                    } else {
                        borderClass = 'border-2 border-yellow-400';
                    }
                }
                
                return (
                    <div className={`bg-white rounded-lg shadow p-4 ${borderClass} ${opacityClass}`}>
                        {/* Header with Type, Value Change, and Adjustment */}
                        <div className="flex justify-between items-start mb-3">
                            <div className="flex-1">
                                <div className="flex items-center gap-2 mb-2">
                                    <h4 className="text-lg font-bold text-gray-800">
                                        {rec.type}
                                    </h4>
                                    {rec.scheduleTime && rec.scheduleTime !== 'ALL' && (
                                        <span className="text-lg font-bold text-purple-700 bg-purple-50 px-2 py-1 rounded border border-purple-200">
                                            @ {rec.scheduleTime}
                                        </span>
                                    )}
                                    <span className="text-xl font-bold text-indigo-700 bg-indigo-50 px-3 py-1 rounded">
                                        {rec.currentValue}  ->  {rec.newValue}
                                    </span>
                                    <span className="text-lg font-bold text-indigo-600">
                                        ({rec.adjustment})
                                    </span>
                                    {isLatest && (
                                        <span className="px-2 py-1 bg-green-100 text-green-800 border border-green-400 rounded text-xs font-bold">
                                            LATEST
                                        </span>
                                    )}
                                </div>
                                <div className="flex items-center gap-2 mb-1">
                                    <ConfidenceBadge score={rec.confidence.score} />
                                    <span className={`px-2 py-1 rounded text-xs font-bold ${
                                        rec.priority === 'HIGH' ? 'bg-red-100 text-red-800 border border-red-300' :
                                        rec.priority === 'MEDIUM' ? 'bg-yellow-100 text-yellow-800 border border-yellow-300' :
                                        rec.priority === 'INFORMATIONAL' ? 'bg-blue-100 text-blue-800 border border-blue-300' :
                                        'bg-gray-100 text-gray-800 border border-gray-300'
                                    }`}>
                                        {rec.priority === 'HIGH' ? 'SAFETY' : 
                                         rec.priority === 'MEDIUM' ? 'RECOMMENDED' : 
                                         rec.priority === 'INFORMATIONAL' ? 'INFO' : 'LOW'}
                                    </span>
                                </div>
                                <p className="text-sm text-gray-500 mb-1">
                                    Detected by: {rec.detector}
                                </p>
                                <p className="text-gray-600 text-sm">{rec.reason}</p>
                            </div>
                        </div>

                        <div className="bg-gray-50 rounded-lg p-3 mb-3">
                            <p className="text-sm text-gray-700 whitespace-pre-line">
                                {rec.details}
                            </p>
                            
                            {/* Highlighted hourly distribution for basal recommendations */}
                            {rec.hourlyDisplayData && (
                                <div className="mt-3 pt-3 border-t border-gray-200">
                                    <p className="text-sm font-medium text-gray-700 mb-2">Hourly Distribution:</p>
                                    <div className="grid grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-1 text-xs font-mono">
                                        {rec.hourlyDisplayData.map((hour, idx) => (
                                            <div 
                                                key={idx} 
                                                className={`p-1.5 rounded ${hour.hasChange 
                                                    ? 'bg-yellow-100 border border-yellow-400 font-semibold' 
                                                    : 'bg-gray-100'}`}
                                            >
                                                <div className="text-gray-600">{hour.hour}</div>
                                                <div className={hour.hasChange ? 'text-red-500 line-through text-xs' : 'text-gray-500'}>
                                                    {hour.oldValue}
                                                </div>
                                                {hour.hasChange && (
                                                    <div className="text-green-600">{hour.newValue}</div>
                                                )}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>

                        {rec.safetyNote && (
                            <div className="bg-red-50 border border-red-200 rounded-lg p-2 mb-3">
                                <p className="text-sm text-red-800">
                                    <strong>Safety Note:</strong> {rec.safetyNote}
                                </p>
                            </div>
                        )}

                        <div className="text-sm text-gray-500">
                            <strong>Calculation:</strong> {rec.calculation}
                        </div>

                        {rec.multipleDetections && (
                            <div className="mt-2 text-sm text-blue-600">
                                {rec.multipleDetections} similar patterns detected
                            </div>
                        )}
                    </div>
                );
            };
            
            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-6">
                    <div className="max-w-6xl mx-auto">
                        {/* Header */}
                        <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                            <div className="flex items-center gap-3 mb-2">
                                <Activity />
                                <h1 className="text-3xl font-bold text-gray-800">
                                    iAPS Parameter Optimizer
                                </h1>
                                <span className="px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm font-semibold">
                                    v25 Signal Logging
                                </span>
                            </div>
                            <p className="text-gray-600">
                                Multi-detector system with IOB-calculated multi-hour basal reduction
                            </p>
                        </div>

                        {/* Data Source Selection */}
                        <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                            <h2 className="text-xl font-semibold mb-4 flex items-center gap-2">
                                <Server />
                                Data Source
                            </h2>
                            
                            <div className="grid md:grid-cols-2 gap-6">
                                {/* File Upload */}
                                <div className="border-2 border-dashed border-gray-300 rounded-lg p-6 hover:border-blue-500 transition-colors">
                                    <h3 className="font-semibold mb-2">Upload JSON File</h3>
                                    <p className="text-sm text-gray-600 mb-4">
                                        Upload Nightscout export data
                                    </p>
                                    <input
                                        type="file"
                                        accept=".json"
                                        onChange={handleFileUpload}
                                        className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
                                    />
                                </div>

                                {/* Nightscout Fetch */}
                                <div className="border-2 border-gray-300 rounded-lg p-6">
                                    <h3 className="font-semibold mb-2">Fetch from Nightscout</h3>
                                    
                                    <div className="space-y-3 mb-4">
                                        <input
                                            type="text"
                                            placeholder="Nightscout URL"
                                            value={nsConfig.baseUrl}
                                            onChange={(e) => updateNsConfig({...nsConfig, baseUrl: e.target.value})}
                                            className="w-full px-3 py-2 border rounded-lg text-sm"
                                        />
                                        
                                        <input
                                            type="text"
                                            placeholder="API Secret"
                                            value={nsConfig.apiSecret}
                                            onChange={(e) => updateNsConfig({...nsConfig, apiSecret: e.target.value})}
                                            className="w-full px-3 py-2 border rounded-lg text-sm"
                                        />
                                        
                                        <input
                                            type="text"
                                            placeholder="Token (optional)"
                                            value={nsConfig.token}
                                            onChange={(e) => updateNsConfig({...nsConfig, token: e.target.value})}
                                            className="w-full px-3 py-2 border rounded-lg text-sm"
                                        />
                                        
                                        <div className="grid grid-cols-2 gap-2">
                                            <div>
                                                <label className="block text-xs font-medium text-gray-600 mb-1">
                                                    CR/ISF Analysis
                                                </label>
                                                <select
                                                    value={analysisWindow}
                                                    onChange={(e) => setAnalysisWindow(Number(e.target.value))}
                                                    className="w-full px-3 py-2 border rounded-lg text-sm"
                                                >
                                                    <option value={1}>Last 24 hours</option>
                                                    <option value={2}>Last 48 hours</option>
                                                    <option value={3}>Last 3 days</option>
                                                    <option value={7}>Last 7 days</option>
                                                </select>
                                            </div>
                                            <div>
                                                <label className="block text-xs font-medium text-gray-600 mb-1">
                                                    Basal Signal Analysis
                                                </label>
                                                <select
                                                    value={basalSignalWindow}
                                                    onChange={(e) => setBasalSignalWindow(Number(e.target.value))}
                                                    className="w-full px-3 py-2 border rounded-lg text-sm"
                                                >
                                                    <option value={3}>Last 3 days</option>
                                                    <option value={7}>Last 7 days</option>
                                                    <option value={14}>Last 14 days</option>
                                                </select>
                                            </div>
                                        </div>
                                        
                                        <div className="mt-2">
                                            <label className="block text-sm font-medium text-gray-700 mb-1">
                                                Basal Target: {basalTDDPercent}% of TDD
                                            </label>
                                            <input
                                                type="range"
                                                min="25"
                                                max="45"
                                                value={basalTDDPercent}
                                                onChange={(e) => setBasalTDDPercent(Number(e.target.value))}
                                                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                            />
                                            <div className="flex justify-between text-xs text-gray-500 mt-1">
                                                <span>25%</span>
                                                <span>35% (default)</span>
                                                <span>45%</span>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <button
                                        onClick={fetchFromNightscout}
                                        disabled={loading}
                                        className="w-full bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold hover:bg-blue-700 disabled:bg-gray-400"
                                    >
                                        {loading ? 'Fetching...' : 'Fetch Data'}
                                    </button>
                                    
                                    {fetchStatus && (
                                        <p className="text-sm text-gray-600 mt-2">{fetchStatus}</p>
                                    )}
                                </div>
                            </div>
                            
                            {/* Google Sheets Logging Settings */}
                            <div className="mt-4 border-t pt-4">
                                <h3 className="font-semibold mb-3 flex items-center gap-2">
                                    <span>ð</span> Google Sheets Logging (Optional)
                                </h3>
                                <div className="space-y-3">
                                    <div>
                                        <label className="block text-xs font-medium text-gray-600 mb-1">
                                            Web App URL
                                        </label>
                                        <input
                                            type="text"
                                            placeholder="https://script.google.com/macros/s/..."
                                            value={sheetsWebAppUrl}
                                            onChange={(e) => updateSheetsUrl(e.target.value)}
                                            className="w-full px-3 py-2 border rounded-lg text-sm font-mono"
                                        />
                                    </div>
                                    <p className="text-xs text-gray-500">
                                        Create a Google Sheet with our Apps Script to log signal analysis over time.
                                        <a 
                                            href="https://github.com/your-repo/GOOGLE_SHEETS_SETUP.md" 
                                            target="_blank" 
                                            rel="noopener noreferrer"
                                            className="text-blue-600 hover:underline ml-1"
                                        >
                                            View Setup Instructions â
                                        </a>
                                    </p>
                                    {sheetsWebAppUrl && (
                                        <div className="flex items-center gap-2 text-sm">
                                            <span className="text-green-600">â URL configured</span>
                                            <button
                                                onClick={fetchTrendData}
                                                disabled={trendLoading}
                                                className="text-blue-600 hover:underline text-sm"
                                            >
                                                {trendLoading ? 'Loading...' : 'Test connection â'}
                                            </button>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>

                        {/* Data Status */}
                        {nightscoutData && (
                            <div className="bg-green-50 border border-green-200 rounded-lg p-4 mb-6">
                                <p className="text-green-800">
                                    Data loaded: {nightscoutData.glucose?.length || 0} glucose readings, 
                                    {' '}{nightscoutData.treatments?.length || 0} treatments
                                </p>
                            </div>
                        )}

                        {/* Error Display */}
                        {error && (
                            <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
                                <p className="text-red-800">{error}</p>
                            </div>
                        )}

                        {/* Analysis Button */}
                        {nightscoutData && !analysisResults && (
                            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6 text-center">
                                <p className="text-sm text-blue-800 mb-2">
                                    Ã¢Å¡Â¡ Analysis runs automatically after loading data
                                </p>
                                {analyzing && (
                                    <div className="flex items-center justify-center gap-2">
                                        <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-600"></div>
                                        <span className="text-blue-600 font-medium">Analyzing...</span>
                                    </div>
                                )}
                            </div>
                        )}
                        
                        {/* Manual Re-run Button (only show after results) */}
                        {nightscoutData && analysisResults && (
                            <div className="bg-white rounded-lg shadow p-4 mb-6">
                                <button
                                    onClick={runAnalysis}
                                    disabled={analyzing}
                                    className="w-full bg-gray-600 text-white px-4 py-2 rounded-lg font-medium text-sm hover:bg-gray-700 disabled:bg-gray-400"
                                >
                                    {analyzing ? 'Re-analyzing...' : '[Refresh] Re-run Analysis'}
                                </button>
                            </div>
                        )}

                        {/* Results */}
                        {analysisResults && (
                            <>
                                {/* Summary */}
                                <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                                    <h2 className="text-2xl font-bold mb-4">Analysis Summary</h2>
                                    <div className="grid md:grid-cols-4 gap-4">
                                        <div className="bg-blue-50 p-4 rounded-lg">
                                            <div className="text-3xl font-bold text-blue-600">
                                                {analysisResults.summary.totalRecommendations}
                                            </div>
                                            <div className="text-sm text-gray-600">Total Recommendations</div>
                                        </div>
                                        <div className="bg-red-50 p-4 rounded-lg">
                                            <div className="text-3xl font-bold text-red-600">
                                                {analysisResults.summary.byPriority.high}
                                            </div>
                                            <div className="text-sm text-gray-600">High Priority (Safety)</div>
                                        </div>
                                        <div className="bg-green-50 p-4 rounded-lg">
                                            <div className="text-3xl font-bold text-green-600">
                                                {analysisResults.summary.byType.crWeakening}
                                            </div>
                                            <div className="text-sm text-gray-600">CR Weakening</div>
                                        </div>
                                        <div className="bg-purple-50 p-4 rounded-lg">
                                            <div className="text-3xl font-bold text-purple-600">
                                                {analysisResults.summary.byType.crStrengthening}
                                            </div>
                                            <div className="text-sm text-gray-600">CR Strengthening</div>
                                        </div>
                                    </div>
                                    
                                    {/* Copy for Claude Review Button */}
                                    <div className="mt-4 pt-4 border-t border-gray-200">
                                        <button
                                            onClick={copyForClaudeReview}
                                            className={`flex items-center gap-2 px-4 py-2 rounded-lg font-medium text-sm transition-colors ${
                                                copyStatus === 'copied' 
                                                    ? 'bg-green-100 text-green-800 border border-green-300' 
                                                    : 'bg-purple-100 text-purple-800 border border-purple-300 hover:bg-purple-200'
                                            }`}
                                        >
                                            {copyStatus === 'copied' ? (
                                                <>
                                                    <span>â</span>
                                                    Copied! Paste into Claude
                                                </>
                                            ) : (
                                                <>
                                                    <span>ð</span>
                                                    Copy for Claude Review
                                                </>
                                            )}
                                        </button>
                                        <p className="text-xs text-gray-500 mt-1">
                                            Copies full analysis as formatted text - paste into claude.ai for review
                                        </p>
                                    </div>
                                </div>

                                {/* Grouped Recommendations by Parameter Type */}
                                <div className="space-y-6">
                                    <h2 className="text-2xl font-bold text-gray-800">Parameter Recommendations</h2>
                                    
                                    {analysisResults.groupedRecommendations.map((group, groupIdx) => (
                                        <div key={groupIdx} className="bg-white rounded-lg shadow-lg p-6">
                                            {/* Parameter Type Header */}
                                            <div className="flex items-center gap-3 mb-4 pb-3 border-b">
                                                <h3 className="text-xl font-bold text-indigo-700">
                                                    {group.title}
                                                </h3>
                                                <span className="text-sm text-gray-500">
                                                    ({group.recommendations.length} recommendation{group.recommendations.length > 1 ? 's' : ''})
                                                </span>
                                            </div>
                                            
                                            {/* Recommendations in this parameter type */}
                                            <div className="space-y-4">
                                                {group.recommendations.map((rec, recIdx) => {
                                                    // Check if this specific rec has conflict
                                                    const hasConflict = rec.hasConflict || false;
                                                    
                                                    return (
                                                        <div key={recIdx}>
                                                            {/* Show conflict warning above the rec if it has one */}
                                                            {hasConflict && rec.isLatest && (
                                                                <div className="bg-yellow-50 border border-yellow-300 rounded-lg p-3 mb-2">
                                                                    <p className="text-yellow-800 font-semibold text-sm mb-1">
                                                                        Conflicting Recommendations at {rec.scheduleTime}
                                                                    </p>
                                                                    <p className="text-yellow-700 text-xs">
                                                                        Both weakening and strengthening recommended. This <strong>LATEST</strong> recommendation 
                                                                        (green border) takes priority as earlier patterns may have been addressed.
                                                                    </p>
                                                                </div>
                                                            )}
                                                            
                                                            <RecommendationCard 
                                                                rec={rec} 
                                                                showConflictWarning={hasConflict}
                                                            />
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    ))}
                                </div>

                                {/* CR Schedule Reference */}
                                <div className="bg-white rounded-lg shadow-lg p-6 mt-6">
                                    <h3 className="text-lg font-semibold mb-3">Current CR Schedule</h3>
                                    <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                                        {analysisResults.crSchedule.map((entry, idx) => (
                                            <div key={idx} className="bg-gray-50 p-3 rounded">
                                                <div className="font-semibold">{entry.time}</div>
                                                <div className="text-sm text-gray-600">{entry.value} g/U</div>
                                            </div>
                                        ))}
                                    </div>
                                </div>

                                {/* ISF Schedule Reference */}
                                <div className="bg-white rounded-lg shadow-lg p-6 mt-6">
                                    <h3 className="text-lg font-semibold mb-3">Current ISF Schedule</h3>
                                    <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                                        {analysisResults.isfSchedule.map((entry, idx) => (
                                            <div key={idx} className="bg-gray-50 p-3 rounded">
                                                <div className="font-semibold">{entry.time}</div>
                                                <div className="text-sm text-gray-600">{entry.value} mg/dL per U</div>
                                            </div>
                                        ))}
                                    </div>
                                </div>

                                {/* Signal Analysis by Period */}
                                {analysisResults.recommendations.some(r => r.signalAnalysis) && (
                                    <div className="bg-white rounded-lg shadow-lg p-6 mt-6">
                                        <h3 className="text-lg font-semibold mb-3">[Lab] Signal Analysis by Circadian Period</h3>
                                        {(() => {
                                            const signalRec = analysisResults.recommendations.find(r => r.signalAnalysis);
                                            if (!signalRec) return null;
                                            
                                            return (
                                                <div>
                                                    <div className="mb-4 p-3 bg-blue-50 rounded">
                                                        <p className="text-sm">
                                                            <strong>Clean Windows Analyzed:</strong> {signalRec.signalAnalysis.cleanWindows.total}
                                                        </p>
                                                        <p className="text-sm">
                                                            <strong>Signals Suggest:</strong> {signalRec.signalAnalysis.signalOnlyAnchor.toFixed(1)}% of TDD
                                                        </p>
                                                    </div>
                                                    
                                                    <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-3">
                                                        {signalRec.signalAnalysis.periods.map((period, idx) => (
                                                            <div key={idx} className={`p-3 rounded border ${
                                                                period.signal === 'HIGH' ? 'bg-red-50 border-red-200' :
                                                                period.signal === 'LOW' ? 'bg-green-50 border-green-200' :
                                                                period.signal === 'NEUTRAL' ? 'bg-gray-50 border-gray-200' :
                                                                'bg-yellow-50 border-yellow-200'
                                                            }`}>
                                                                <div className="font-bold text-sm">{period.emoji} {period.name}</div>
                                                                <div className="text-xs text-gray-600">{period.hours}</div>
                                                                <div className="text-xs mt-1">Windows: {period.cleanWindowCount}</div>
                                                                <div className={`font-mono text-sm mt-1 ${
                                                                    (period.medianDeviation || 0) > 5 ? 'text-red-600 font-bold' :
                                                                    (period.medianDeviation || 0) < -5 ? 'text-green-600 font-bold' : 'text-gray-600'
                                                                }`}>
                                                                    {period.medianDeviation !== null ? `${period.medianDeviation >= 0 ? '+' : ''}${period.medianDeviation.toFixed(1)}` : 'Ã¢â¬â'} mg/dL
                                                                </div>
                                                                {period.signal && period.signal !== 'NEUTRAL' && (
                                                                    <div className={`text-xs mt-1 font-semibold ${
                                                                        period.signal === 'HIGH' ? 'text-red-700' : 'text-green-700'
                                                                    }`}>
                                                                        {period.signal === 'HIGH' ? 'â Basal too weak' : 'â Basal too strong'}
                                                                    </div>
                                                                )}
                                                                {!period.hasSufficientData && (
                                                                    <div className="text-xs text-yellow-600 mt-1">Insufficient data</div>
                                                                )}
                                                            </div>
                                                        ))}
                                                    </div>
                                                    
                                                    {signalRec.incrementDistribution && signalRec.incrementDistribution.appliedHours.length > 0 && (
                                                        <div className="mt-4 p-3 bg-purple-50 border border-purple-200 rounded">
                                                            <p className="text-sm font-semibold text-purple-800">
                                                                Increment Distribution: {Math.abs(signalRec.incrementDistribution.incrementsNeeded)} x 0.05U {signalRec.incrementDistribution.direction}s
                                                            </p>
                                                            <p className="text-xs text-purple-700 mt-1">
                                                                Applied to hours: {signalRec.incrementDistribution.appliedHours.map(a => `${a.hour}:00`).join(', ')}
                                                            </p>
                                                            <p className="text-xs text-purple-600 mt-1">
                                                                Priority: {signalRec.incrementDistribution.direction === 'increase' ? 'positive' : 'negative'}-signal periods first
                                                            </p>
                                                        </div>
                                                    )}
                                                </div>
                                            );
                                        })()}
                                        
                                        {/* Log This Analysis Panel */}
                                        {sheetsWebAppUrl && (
                                            <div className="mt-4 p-4 bg-indigo-50 border border-indigo-200 rounded-lg">
                                                <h4 className="font-semibold text-indigo-800 mb-2 flex items-center gap-2">
                                                    <span>ð</span> Log This Analysis
                                                </h4>
                                                <div className="flex flex-col md:flex-row gap-2">
                                                    <input
                                                        type="text"
                                                        placeholder="Notes (optional): e.g., 'After changing ISF'"
                                                        value={loggingNotes}
                                                        onChange={(e) => setLoggingNotes(e.target.value)}
                                                        className="flex-1 px-3 py-2 border rounded text-sm"
                                                    />
                                                    <button
                                                        onClick={logToGoogleSheets}
                                                        disabled={logStatus === 'logging'}
                                                        className={`px-4 py-2 rounded font-semibold text-sm whitespace-nowrap ${
                                                            logStatus === 'success' ? 'bg-green-600 text-white' :
                                                            logStatus === 'error' ? 'bg-red-600 text-white' :
                                                            logStatus === 'logging' ? 'bg-gray-400 text-white' :
                                                            'bg-indigo-600 text-white hover:bg-indigo-700'
                                                        }`}
                                                    >
                                                        {logStatus === 'logging' ? 'â³ Logging...' :
                                                         logStatus === 'success' ? 'â Logged!' :
                                                         logStatus === 'error' ? 'â Failed' :
                                                         'ð Log to Sheets'}
                                                    </button>
                                                </div>
                                                {logMessage && (
                                                    <p className={`text-xs mt-2 ${
                                                        logStatus === 'success' ? 'text-green-700' :
                                                        logStatus === 'error' ? 'text-red-700' :
                                                        'text-gray-600'
                                                    }`}>
                                                        {logMessage}
                                                    </p>
                                                )}
                                            </div>
                                        )}
                                        
                                        {/* View Trend Button */}
                                        {sheetsWebAppUrl && !showTrend && (
                                            <div className="mt-4 text-center">
                                                <button
                                                    onClick={fetchTrendData}
                                                    disabled={trendLoading}
                                                    className="px-6 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg font-medium text-sm border"
                                                >
                                                    {trendLoading ? 'â³ Loading Trend Data...' : 'ð View Signal Trend'}
                                                </button>
                                            </div>
                                        )}
                                        
                                        {/* Trend Visualization */}
                                        {showTrend && (
                                            <div className="mt-4 p-4 bg-white border border-gray-200 rounded-lg">
                                                <div className="flex justify-between items-center mb-3">
                                                    <h4 className="font-semibold text-gray-800 flex items-center gap-2">
                                                        <span>ð</span> Signal Trend Analysis
                                                        {trendData && (
                                                            <span className="text-sm font-normal text-gray-500">
                                                                ({trendData.length} entries)
                                                            </span>
                                                        )}
                                                    </h4>
                                                    <button
                                                        onClick={() => setShowTrend(false)}
                                                        className="text-gray-400 hover:text-gray-600 text-xl"
                                                    >
                                                         x 
                                                    </button>
                                                </div>
                                                
                                                {trendLoading && (
                                                    <div className="text-center py-8 text-gray-500">
                                                        <div className="animate-spin inline-block w-6 h-6 border-2 border-gray-300 border-t-indigo-600 rounded-full mb-2"></div>
                                                        <p>Loading trend data...</p>
                                                    </div>
                                                )}
                                                
                                                {trendError && (
                                                    <div className="bg-red-50 border border-red-200 rounded p-3 text-red-700 text-sm">
                                                        {trendError}
                                                    </div>
                                                )}
                                                
                                                {trendData && trendData.length === 0 && (
                                                    <div className="text-center py-8 text-gray-500">
                                                        <p>No logged entries yet. Log your first analysis above!</p>
                                                    </div>
                                                )}
                                                
                                                {trendData && trendData.length > 0 && (
                                                    <div>
                                                        {/* Chart */}
                                                        <div className="mb-4">
                                                            <TrendChart data={trendData} targetPercent={basalTDDPercent} />
                                                        </div>
                                                        
                                                        {/* Summary Stats */}
                                                        <div className="grid grid-cols-3 gap-3 mb-4">
                                                            <div className="bg-gray-50 p-3 rounded text-center">
                                                                <div className="text-2xl font-bold text-indigo-600">{trendData.length}</div>
                                                                <div className="text-xs text-gray-500">Entries Logged</div>
                                                            </div>
                                                            <div className="bg-gray-50 p-3 rounded text-center">
                                                                <div className="text-2xl font-bold text-indigo-600">
                                                                    {optimalTDDRecommendation?.daySpan || 'â'}
                                                                </div>
                                                                <div className="text-xs text-gray-500">Days Tracked</div>
                                                            </div>
                                                            <div className="bg-gray-50 p-3 rounded text-center">
                                                                <div className={`text-2xl font-bold ${
                                                                    (optimalTDDRecommendation?.avgGap || 0) > 0 ? 'text-red-600' :
                                                                    (optimalTDDRecommendation?.avgGap || 0) < 0 ? 'text-green-600' :
                                                                    'text-gray-600'
                                                                }`}>
                                                                    {optimalTDDRecommendation?.avgGap !== undefined 
                                                                        ? `${optimalTDDRecommendation.avgGap >= 0 ? '+' : ''}${optimalTDDRecommendation.avgGap.toFixed(1)}%`
                                                                        : 'â'}
                                                                </div>
                                                                <div className="text-xs text-gray-500">Avg Gap from Target</div>
                                                            </div>
                                                        </div>
                                                        
                                                        {/* Optimal TDD% Recommendation */}
                                                        {optimalTDDRecommendation && (
                                                            <div className={`p-4 rounded-lg border ${
                                                                optimalTDDRecommendation.recommendation === 'OPTIMAL' ? 'bg-green-50 border-green-200' :
                                                                optimalTDDRecommendation.recommendation === 'INCREASE' ? 'bg-amber-50 border-amber-200' :
                                                                optimalTDDRecommendation.recommendation === 'DECREASE' ? 'bg-blue-50 border-blue-200' :
                                                                optimalTDDRecommendation.recommendation === 'INSUFFICIENT_DATA' ? 'bg-gray-50 border-gray-200' :
                                                                'bg-yellow-50 border-yellow-200'
                                                            }`}>
                                                                <h5 className="font-semibold mb-2 flex items-center gap-2">
                                                                    <span>ð¯</span> Optimal Basal Target Recommendation
                                                                    {optimalTDDRecommendation.confidence && optimalTDDRecommendation.confidence !== 'INSUFFICIENT_DATA' && (
                                                                        <span className={`text-xs px-2 py-0.5 rounded ${
                                                                            optimalTDDRecommendation.confidence === 'HIGH' ? 'bg-green-200 text-green-800' :
                                                                            optimalTDDRecommendation.confidence === 'MEDIUM' ? 'bg-yellow-200 text-yellow-800' :
                                                                            'bg-orange-200 text-orange-800'
                                                                        }`}>
                                                                            {optimalTDDRecommendation.confidence} confidence
                                                                        </span>
                                                                    )}
                                                                </h5>
                                                                
                                                                <p className="text-sm text-gray-700 mb-3">
                                                                    {optimalTDDRecommendation.message}
                                                                </p>
                                                                
                                                                {optimalTDDRecommendation.recommendation !== 'INSUFFICIENT_DATA' && 
                                                                 optimalTDDRecommendation.recommendation !== 'OPTIMAL' &&
                                                                 optimalTDDRecommendation.recommendation !== 'MONITOR' && (
                                                                    <div className="flex items-center gap-3">
                                                                        <div className="bg-white px-4 py-2 rounded border font-mono">
                                                                            Recommended: <strong>{optimalTDDRecommendation.suggestedTarget}%</strong> of TDD
                                                                        </div>
                                                                        <button
                                                                            onClick={() => setBasalTDDPercent(optimalTDDRecommendation.suggestedTarget)}
                                                                            className="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 text-sm font-semibold"
                                                                        >
                                                                            Apply {optimalTDDRecommendation.suggestedTarget}% Target
                                                                        </button>
                                                                        <button
                                                                            onClick={() => setShowTrend(false)}
                                                                            className="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 text-sm"
                                                                        >
                                                                            Keep {basalTDDPercent}%
                                                                        </button>
                                                                    </div>
                                                                )}
                                                                
                                                                {optimalTDDRecommendation.trendDirection && (
                                                                    <p className="text-xs text-gray-500 mt-2">
                                                                        Trend: {optimalTDDRecommendation.trendDirection === 'converging' ? 'â Converging toward target' :
                                                                               optimalTDDRecommendation.trendDirection === 'diverging' ? 'â Diverging from target' :
                                                                               'â Stable pattern'}
                                                                    </p>
                                                                )}
                                                            </div>
                                                        )}
                                                        
                                                        {/* Refresh Button */}
                                                        <div className="mt-3 text-center">
                                                            <button
                                                                onClick={fetchTrendData}
                                                                disabled={trendLoading}
                                                                className="text-sm text-gray-500 hover:text-gray-700"
                                                            >
                                                                ð Refresh trend data
                                                            </button>
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                )}
                            </>
                        )}
                    </div>
                </div>
            );
        };

        // Render the app
        ReactDOM.render(<IAPSOptimizer />, document.getElementById('root'));
    </script>
</body>
</html>
